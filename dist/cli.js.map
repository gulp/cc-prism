{"version":3,"sources":["../src/parser/loader.ts","../src/types/asciicast.ts","../src/generator/builder.ts","../src/generator/timing.ts","../src/renderer/content.ts","../src/renderer/ansi.ts","../src/renderer/commands.ts","../src/generator/markers.ts","../src/renderer/todos.ts","../src/renderer/markdown.ts","../src/renderer/theme.ts","../src/renderer/diff.ts","../src/renderer/tool-results.ts","../src/renderer/tool-formatting.ts","../src/renderer/messages.ts","../src/renderer/input.ts","../src/types/messages.ts","../src/renderer/verbs.json","../src/renderer/spinner.ts","../src/generator/convert.ts","../src/cli/upload.ts","../src/cli/sessions.ts","../src/cli/interactive.tsx","../src/cli/picker.tsx","../src/cli.ts","../src/parser/clip.ts"],"sourcesContent":["/**\n * JSONL file loader with agent file handling\n */\n\nimport { readFile } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport type { TranscriptEntry } from \"../types/messages.js\";\n\n/** Parse a single JSONL line into a typed message */\nexport function parseLine(line: string): TranscriptEntry | null {\n  const trimmed = line.trim();\n  if (!trimmed) return null;\n\n  try {\n    const parsed = JSON.parse(trimmed) as TranscriptEntry;\n    return parsed;\n  } catch {\n    // Silently skip malformed lines\n    return null;\n  }\n}\n\n/** Load and parse a JSONL transcript file */\nexport async function loadTranscript(\n  filePath: string,\n  options: {\n    loadAgents?: boolean;\n    agentCache?: Map<string, TranscriptEntry[]>;\n  } = {}\n): Promise<TranscriptEntry[]> {\n  const { loadAgents = true, agentCache = new Map() } = options;\n\n  const content = await readFile(filePath, \"utf-8\");\n  const lines = content.split(\"\\n\");\n  const entries: TranscriptEntry[] = [];\n\n  for (const line of lines) {\n    const entry = parseLine(line);\n    if (entry) {\n      entries.push(entry);\n\n      // Check for agent references in tool results\n      if (\n        loadAgents &&\n        entry.type === \"user\" &&\n        entry.toolUseResult &&\n        typeof entry.toolUseResult !== \"string\" &&\n        entry.toolUseResult.agentId\n      ) {\n        const agentId = entry.toolUseResult.agentId;\n\n        // Check cache first\n        if (!agentCache.has(agentId)) {\n          const agentPath = join(dirname(filePath), `agent-${agentId}.jsonl`);\n          try {\n            const agentEntries = await loadTranscript(agentPath, {\n              loadAgents: true,\n              agentCache,\n            });\n            agentCache.set(agentId, agentEntries);\n          } catch {\n            // Agent file may not exist or be inaccessible\n            agentCache.set(agentId, []);\n          }\n        }\n\n        // Mark agent entries as sidechain and insert after parent\n        const agentEntries = agentCache.get(agentId) ?? [];\n        for (const agentEntry of agentEntries) {\n          if (\"isSidechain\" in agentEntry) {\n            (agentEntry as { isSidechain: boolean }).isSidechain = true;\n          }\n          entries.push(agentEntry);\n        }\n      }\n    }\n  }\n\n  // Interleave parallel tool calls with their results for logical ordering\n  return interleaveToolCallsAndResults(entries);\n}\n\n/** Sort entries chronologically by timestamp */\nexport function sortByTimestamp(entries: TranscriptEntry[]): TranscriptEntry[] {\n  return [...entries].sort((a, b) => {\n    const aTime = getTimestamp(a)?.getTime() ?? 0;\n    const bTime = getTimestamp(b)?.getTime() ?? 0;\n    return aTime - bTime;\n  });\n}\n\n/** Get timestamp from entry (if available) */\nexport function getTimestamp(entry: TranscriptEntry): Date | null {\n  if (\n    \"timestamp\" in entry &&\n    typeof entry.timestamp === \"string\" &&\n    entry.timestamp\n  ) {\n    return new Date(entry.timestamp);\n  }\n  return null;\n}\n\n/** Get UUID from entry (if available) */\nexport function getUuid(entry: TranscriptEntry): string | null {\n  if (\"uuid\" in entry && typeof entry.uuid === \"string\" && entry.uuid) {\n    return entry.uuid;\n  }\n  return null;\n}\n\n/** Check if an assistant message contains a tool call */\nfunction isToolCallMessage(entry: TranscriptEntry): boolean {\n  if (entry.type !== \"assistant\") return false;\n  const content = entry.message?.content;\n  if (!Array.isArray(content)) return false;\n  return content.some((item) => item.type === \"tool_use\");\n}\n\n/** Check if a user message is a tool result */\nfunction isToolResultMessage(entry: TranscriptEntry): boolean {\n  if (entry.type !== \"user\") return false;\n  return entry.toolUseResult !== undefined;\n}\n\n/**\n * Interleave parallel tool calls with their results.\n *\n * When Claude makes parallel tool calls, the JSONL stores them as:\n *   [call1, call2, call3, result1, result2, result3]\n *\n * This function reorders to logical conversation flow:\n *   [call1, result1, call2, result2, call3, result3]\n *\n * Detection: consecutive assistant messages with tool_use content,\n * followed by consecutive user messages with toolUseResult.\n * The results match calls by position (first result → first call, etc).\n */\nexport function interleaveToolCallsAndResults(\n  entries: TranscriptEntry[]\n): TranscriptEntry[] {\n  const result: TranscriptEntry[] = [];\n  let i = 0;\n\n  while (i < entries.length) {\n    // Collect consecutive tool calls\n    const toolCalls: TranscriptEntry[] = [];\n    while (i < entries.length && isToolCallMessage(entries[i]!)) {\n      toolCalls.push(entries[i]!);\n      i++;\n    }\n\n    // Collect consecutive tool results\n    const toolResults: TranscriptEntry[] = [];\n    while (i < entries.length && isToolResultMessage(entries[i]!)) {\n      toolResults.push(entries[i]!);\n      i++;\n    }\n\n    // Interleave if we have matching calls and results\n    if (toolCalls.length > 0 && toolResults.length > 0) {\n      const maxPairs = Math.min(toolCalls.length, toolResults.length);\n      for (let j = 0; j < maxPairs; j++) {\n        result.push(toolCalls[j]!);\n        result.push(toolResults[j]!);\n      }\n      // Add any remaining unmatched entries\n      for (let j = maxPairs; j < toolCalls.length; j++) {\n        result.push(toolCalls[j]!);\n      }\n      for (let j = maxPairs; j < toolResults.length; j++) {\n        result.push(toolResults[j]!);\n      }\n    } else {\n      // No interleaving needed, add as-is\n      for (const call of toolCalls) {\n        result.push(call);\n      }\n      for (const res of toolResults) {\n        result.push(res);\n      }\n    }\n\n    // If we didn't collect any tool calls or results, add the current entry\n    if (toolCalls.length === 0 && toolResults.length === 0 && i < entries.length) {\n      result.push(entries[i]!);\n      i++;\n    }\n  }\n\n  return result;\n}\n","/**\n * asciicast v3 format types\n * Spec: https://docs.asciinema.org/manual/asciicast/v3/\n */\n\n// =============================================================================\n// Theme Configuration\n// =============================================================================\n\nexport interface AsciicastTheme {\n  fg: string;\n  bg: string;\n  palette: string; // Colon-separated 16 colors (ANSI 0-15)\n}\n\n/** Built-in theme presets */\nexport const THEMES: Record<string, AsciicastTheme> = {\n  \"tokyo-night\": {\n    fg: \"#a9b1d6\",\n    bg: \"#1a1b26\",\n    palette:\n      \"#15161e:#f7768e:#9ece6a:#e0af68:#7aa2f7:#bb9af7:#7dcfff:#a9b1d6:#414868:#f7768e:#9ece6a:#e0af68:#7aa2f7:#bb9af7:#7dcfff:#c0caf5\",\n  },\n  \"tokyo-storm\": {\n    fg: \"#a9b1d6\",\n    bg: \"#24283b\",\n    palette:\n      \"#1d202f:#f7768e:#9ece6a:#e0af68:#7aa2f7:#bb9af7:#7dcfff:#a9b1d6:#414868:#f7768e:#9ece6a:#e0af68:#7aa2f7:#bb9af7:#7dcfff:#c0caf5\",\n  },\n  dracula: {\n    fg: \"#f8f8f2\",\n    bg: \"#282a36\",\n    palette:\n      \"#21222c:#ff5555:#50fa7b:#f1fa8c:#bd93f9:#ff79c6:#8be9fd:#f8f8f2:#6272a4:#ff6e6e:#69ff94:#ffffa5:#d6acff:#ff92df:#a4ffff:#ffffff\",\n  },\n  nord: {\n    fg: \"#d8dee9\",\n    bg: \"#2e3440\",\n    palette:\n      \"#3b4252:#bf616a:#a3be8c:#ebcb8b:#81a1c1:#b48ead:#88c0d0:#e5e9f0:#4c566a:#bf616a:#a3be8c:#ebcb8b:#81a1c1:#b48ead:#8fbcbb:#eceff4\",\n  },\n  \"catppuccin-mocha\": {\n    fg: \"#cdd6f4\",\n    bg: \"#1e1e2e\",\n    palette:\n      \"#45475a:#f38ba8:#a6e3a1:#f9e2af:#89b4fa:#f5c2e7:#94e2d5:#bac2de:#585b70:#f38ba8:#a6e3a1:#f9e2af:#89b4fa:#f5c2e7:#94e2d5:#a6adc8\",\n  },\n};\n\n// =============================================================================\n// Semantic Colors (for rendering)\n// =============================================================================\n\nexport interface SemanticColors {\n  userPrompt: string;\n  assistantText: string;\n  toolName: string;\n  toolBulletSuccess: string;\n  toolBulletError: string;\n  thinking: string;\n  boxDrawing: string;\n  filePath: string;\n}\n\nexport const TOKYO_NIGHT_SEMANTIC: SemanticColors = {\n  userPrompt: \"#7aa2f7\", // Blue\n  assistantText: \"#a9b1d6\", // Foreground\n  toolName: \"#e0af68\", // Yellow\n  toolBulletSuccess: \"#9ece6a\", // Green\n  toolBulletError: \"#f7768e\", // Red\n  thinking: \"#565f89\", // Comment\n  boxDrawing: \"#414868\", // Bright black\n  filePath: \"#7dcfff\", // Cyan\n};\n\n// =============================================================================\n// asciicast v3 Header\n// =============================================================================\n\nexport interface AsciicastHeader {\n  version: 3;\n  term: {\n    cols: number;\n    rows: number;\n    type?: string;\n    theme?: AsciicastTheme;\n  };\n  timestamp?: number;\n  title?: string;\n  env?: Record<string, string>;\n}\n\n// =============================================================================\n// asciicast v3 Events\n// =============================================================================\n\n/** Output event - ANSI-encoded text */\nexport type OutputEvent = [number, \"o\", string];\n\n/** Marker event - navigation point */\nexport type MarkerEvent = [number, \"m\", string];\n\n/** Resize event - terminal dimension change */\nexport type ResizeEvent = [number, \"r\", string]; // \"cols x rows\"\n\nexport type AsciicastEvent = OutputEvent | MarkerEvent | ResizeEvent;\n\n// =============================================================================\n// Complete asciicast Document\n// =============================================================================\n\nexport interface AsciicastDocument {\n  header: AsciicastHeader;\n  events: AsciicastEvent[];\n}\n\n// =============================================================================\n// Timing Presets\n// =============================================================================\n\nexport interface TimingConfig {\n  /** Maximum pause between events (seconds) */\n  maxWait: number;\n  /** Pause before assistant response (seconds) */\n  thinkingPause: number;\n  /** Enable character-by-character typing effect */\n  typingEffect: boolean;\n  /** Characters per second when typing effect is enabled */\n  typingSpeed: number;\n}\n\nexport const TIMING_PRESETS: Record<string, TimingConfig> = {\n  speedrun: {\n    maxWait: 2,\n    thinkingPause: 0.3,\n    typingEffect: false,\n    typingSpeed: 80,\n  },\n  default: {\n    maxWait: 3,\n    thinkingPause: 0.8,\n    typingEffect: true,\n    typingSpeed: 60,\n  },\n  realtime: {\n    maxWait: Infinity,\n    thinkingPause: 0,\n    typingEffect: false,\n    typingSpeed: 0,\n  },\n};\n\n// =============================================================================\n// Marker Configuration\n// =============================================================================\n\nexport type MarkerMode = \"all\" | \"user\" | \"tools\" | \"none\";\n\nexport interface MarkerConfig {\n  mode: MarkerMode;\n  labelLength: number;\n  pauseOnMarkers: boolean;\n}\n\nexport const DEFAULT_MARKER_CONFIG: MarkerConfig = {\n  mode: \"all\",\n  labelLength: 30,\n  pauseOnMarkers: false,\n};\n","/**\n * asciicast document builder\n * Creates asciicast v3 format documents from rendered messages\n */\n\nimport type {\n  AsciicastHeader,\n  AsciicastEvent,\n  AsciicastDocument,\n  AsciicastTheme,\n  OutputEvent,\n  MarkerEvent,\n} from \"../types/asciicast.js\";\nimport { THEMES } from \"../types/asciicast.js\";\n\n// =============================================================================\n// Builder Configuration\n// =============================================================================\n\nexport interface BuilderConfig {\n  /** Terminal width */\n  cols: number;\n  /** Terminal height */\n  rows: number;\n  /** Terminal type */\n  termType: string;\n  /** Theme to embed */\n  theme: AsciicastTheme;\n  /** Recording title */\n  title?: string;\n  /** Recording timestamp (Unix seconds) */\n  timestamp?: number;\n}\n\nexport const DEFAULT_BUILDER_CONFIG: BuilderConfig = {\n  cols: 100,\n  rows: 40,\n  termType: \"xterm-256color\",\n  theme: THEMES[\"tokyo-night\"]!,\n  title: \"Claude Code Session\",\n};\n\n// =============================================================================\n// Document Builder\n// =============================================================================\n\nexport class AsciicastBuilder {\n  private config: BuilderConfig;\n  private events: AsciicastEvent[] = [];\n  private currentTime = 0;\n  private lastEventTime = 0;\n\n  constructor(config: Partial<BuilderConfig> = {}) {\n    this.config = { ...DEFAULT_BUILDER_CONFIG, ...config };\n  }\n\n  /** Get the current timestamp */\n  get time(): number {\n    return this.currentTime;\n  }\n\n  /** Set the current timestamp */\n  set time(t: number) {\n    this.currentTime = t;\n  }\n\n  /** Add time to current timestamp */\n  addTime(seconds: number): this {\n    this.currentTime += seconds;\n    return this;\n  }\n\n  /** Add an output event (ANSI text) */\n  output(text: string): this {\n    if (text.length > 0) {\n      // asciicast v3 uses relative time (interval since previous event)\n      // Math.max(0, ...) prevents negative intervals if time goes backward\n      const interval = Math.max(0, this.currentTime - this.lastEventTime);\n      const event: OutputEvent = [interval, \"o\", text];\n      this.events.push(event);\n      this.lastEventTime = this.currentTime;\n    }\n    return this;\n  }\n\n  /** Add output with a newline */\n  outputLine(text: string): this {\n    return this.output(text + \"\\n\");\n  }\n\n  /** Add multiple lines of output */\n  outputLines(lines: string[]): this {\n    for (const line of lines) {\n      this.outputLine(line);\n    }\n    return this;\n  }\n\n  /** Add a marker event for navigation */\n  marker(label: string): this {\n    // asciicast v3 uses relative time (interval since previous event)\n    // Markers are instant navigation points - don't update lastEventTime\n    // so subsequent output at same currentTime gets the proper interval\n    // Math.max(0, ...) prevents negative intervals if time goes backward\n    const interval = Math.max(0, this.currentTime - this.lastEventTime);\n    const event: MarkerEvent = [interval, \"m\", label];\n    this.events.push(event);\n    return this;\n  }\n\n  /** Add output and marker at the same time */\n  outputWithMarker(text: string, markerLabel: string): this {\n    this.marker(markerLabel);\n    this.output(text);\n    return this;\n  }\n\n  /** Add a blank line */\n  blank(): this {\n    return this.output(\"\\n\");\n  }\n\n  /** Add multiple blank lines */\n  blanks(count: number): this {\n    for (let i = 0; i < count; i++) {\n      this.blank();\n    }\n    return this;\n  }\n\n  /** Clear the screen (ANSI escape sequence) */\n  clear(): this {\n    return this.output(\"\\x1b[2J\\x1b[H\");\n  }\n\n  /** Build the header */\n  buildHeader(): AsciicastHeader {\n    return {\n      version: 3,\n      term: {\n        cols: this.config.cols,\n        rows: this.config.rows,\n        type: this.config.termType,\n        theme: this.config.theme,\n      },\n      timestamp: this.config.timestamp ?? Math.floor(Date.now() / 1000),\n      title: this.config.title,\n    };\n  }\n\n  /** Build the complete document */\n  build(): AsciicastDocument {\n    return {\n      header: this.buildHeader(),\n      events: [...this.events],\n    };\n  }\n\n  /** Get current event count */\n  get eventCount(): number {\n    return this.events.length;\n  }\n\n  /** Reset builder state (keeps config) */\n  reset(): this {\n    this.events = [];\n    this.currentTime = 0;\n    this.lastEventTime = 0;\n    return this;\n  }\n}\n\n// =============================================================================\n// Serialization\n// =============================================================================\n\n/** Serialize asciicast document to .cast file format (NDJSON) */\nexport function serializeCast(doc: AsciicastDocument): string {\n  const lines: string[] = [];\n\n  // Header as first line\n  lines.push(JSON.stringify(doc.header));\n\n  // Events as subsequent lines\n  for (const event of doc.events) {\n    lines.push(JSON.stringify(event));\n  }\n\n  return lines.join(\"\\n\") + \"\\n\";\n}\n\n/** Parse .cast file content back to document */\nexport function parseCast(content: string): AsciicastDocument {\n  const lines = content.trim().split(\"\\n\");\n\n  if (lines.length === 0) {\n    throw new Error(\"Empty cast file\");\n  }\n\n  const header = JSON.parse(lines[0]!) as AsciicastHeader;\n  const events: AsciicastEvent[] = [];\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i]!.trim();\n    if (line) {\n      events.push(JSON.parse(line) as AsciicastEvent);\n    }\n  }\n\n  return { header, events };\n}\n","/**\n * Timing logic for asciicast generation\n * Handles timing presets and calculations\n */\n\nimport type { TranscriptEntry } from \"../types/messages.js\";\nimport type { TimingConfig } from \"../types/asciicast.js\";\nimport { TIMING_PRESETS } from \"../types/asciicast.js\";\nimport { getTimestamp } from \"../parser/loader.js\";\n\n// =============================================================================\n// Timing Configuration\n// =============================================================================\n\nexport interface TimingOptions extends TimingConfig {\n  /** Preset name (overrides individual settings) */\n  preset?: \"speedrun\" | \"default\" | \"realtime\";\n}\n\nexport function resolveTimingConfig(options: Partial<TimingOptions>): TimingConfig {\n  // If preset specified, use it as base\n  const presetName = options.preset;\n  if (presetName) {\n    const presetConfig = TIMING_PRESETS[presetName];\n    if (presetConfig) {\n      return {\n        ...presetConfig,\n        // Allow overrides\n        maxWait: options.maxWait ?? presetConfig.maxWait,\n        thinkingPause: options.thinkingPause ?? presetConfig.thinkingPause,\n        typingEffect: options.typingEffect ?? presetConfig.typingEffect,\n        typingSpeed: options.typingSpeed ?? presetConfig.typingSpeed,\n      };\n    }\n  }\n\n  // Use default preset as fallback\n  return {\n    ...TIMING_PRESETS[\"default\"]!,\n    ...options,\n  };\n}\n\n// =============================================================================\n// Timing Calculator\n// =============================================================================\n\nexport class TimingCalculator {\n  private config: TimingConfig;\n  private lastTimestamp: Date | null = null;\n  private currentTime = 0;\n\n  constructor(config: TimingConfig) {\n    this.config = config;\n  }\n\n  /** Get the current playback time */\n  get time(): number {\n    return this.currentTime;\n  }\n\n  /** Set the current playback time (for syncing with external animation) */\n  set time(value: number) {\n    this.currentTime = value;\n  }\n\n  /** Reset the calculator */\n  reset(): void {\n    this.lastTimestamp = null;\n    this.currentTime = 0;\n  }\n\n  /** Calculate time for next entry */\n  nextEntry(entry: TranscriptEntry): number {\n    const timestamp = getTimestamp(entry);\n\n    // Real timing mode - use actual timestamps\n    if (this.config.maxWait === Infinity && timestamp && this.lastTimestamp) {\n      const realDelta = (timestamp.getTime() - this.lastTimestamp.getTime()) / 1000;\n      this.lastTimestamp = timestamp;\n      this.currentTime += Math.max(0, realDelta);\n      return this.currentTime;\n    }\n\n    // Calculate normalized timing\n    let delta = 0;\n\n    if (timestamp && this.lastTimestamp) {\n      // Use real delta but cap it\n      const realDelta = (timestamp.getTime() - this.lastTimestamp.getTime()) / 1000;\n      delta = Math.min(realDelta, this.config.maxWait);\n    } else {\n      // Default pause between messages\n      delta = this.getDefaultPause(entry);\n    }\n\n    if (timestamp) {\n      this.lastTimestamp = timestamp;\n    }\n\n    this.currentTime += delta;\n    return this.currentTime;\n  }\n\n  /** Add pause for assistant response (thinking time) */\n  addThinkingPause(): void {\n    this.currentTime += this.config.thinkingPause;\n  }\n\n  /** Add a fixed pause */\n  addPause(seconds: number): void {\n    this.currentTime += Math.min(seconds, this.config.maxWait);\n  }\n\n  /** Calculate typing duration for text */\n  getTypingDuration(text: string): number {\n    if (!this.config.typingEffect || this.config.typingSpeed <= 0) {\n      return 0;\n    }\n    return text.length / this.config.typingSpeed;\n  }\n\n  /** Check if typing effect is enabled */\n  get hasTypingEffect(): boolean {\n    return this.config.typingEffect && this.config.typingSpeed > 0;\n  }\n\n  /** Get the timing config */\n  getConfig(): TimingConfig {\n    return { ...this.config };\n  }\n\n  // =============================================================================\n  // Private Helpers\n  // =============================================================================\n\n  private getDefaultPause(entry: TranscriptEntry): number {\n    switch (entry.type) {\n      case \"user\":\n        // Brief pause before user message\n        if (\"toolUseResult\" in entry && entry.toolUseResult) {\n          return 0.1; // Tool results appear quickly\n        }\n        return 0.3; // User typing\n\n      case \"assistant\":\n        // Thinking pause before assistant response\n        return this.config.thinkingPause;\n\n      case \"system\":\n        return 0.2;\n\n      default:\n        return 0.1;\n    }\n  }\n}\n\n// =============================================================================\n// Typing Effect Generator\n// =============================================================================\n\nexport interface TypedSegment {\n  text: string;\n  time: number;\n}\n\n/** Generate typing effect segments for text */\nexport function generateTypingSegments(\n  text: string,\n  startTime: number,\n  charsPerSecond: number,\n  chunkSize: number = 3\n): TypedSegment[] {\n  if (charsPerSecond <= 0) {\n    return [{ text, time: startTime }];\n  }\n\n  const segments: TypedSegment[] = [];\n  const timePerChar = 1 / charsPerSecond;\n  let currentTime = startTime;\n\n  // Split into chunks for more natural typing\n  for (let i = 0; i < text.length; i += chunkSize) {\n    const chunk = text.substring(i, Math.min(i + chunkSize, text.length));\n    segments.push({ text: chunk, time: currentTime });\n    currentTime += chunk.length * timePerChar;\n  }\n\n  return segments;\n}\n\n/** Generate line-by-line output with timing */\nexport function generateLineSegments(\n  text: string,\n  startTime: number,\n  lineDelay: number\n): TypedSegment[] {\n  const lines = text.split(\"\\n\");\n  const segments: TypedSegment[] = [];\n  let currentTime = startTime;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n    // Add newline for all but last line\n    const output = i < lines.length - 1 ? line + \"\\n\" : line;\n    segments.push({ text: output, time: currentTime });\n    currentTime += lineDelay;\n  }\n\n  return segments;\n}\n","/**\n * Content normalization utilities for rendering\n * Handles extraction and formatting of message content\n */\n\nimport type {\n  ContentItem,\n  TextContent,\n  ThinkingContent,\n  ToolUseContent,\n  AssistantMessage,\n  UserMessage,\n} from \"../types/messages.js\";\n\n// =============================================================================\n// Content Extraction\n// =============================================================================\n\n/** Extract all text content from a ContentItem array */\nexport function extractText(content: string | ContentItem[]): string {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  return content\n    .filter((item): item is TextContent => item.type === \"text\")\n    .map((item) => item.text)\n    .join(\"\\n\");\n}\n\n/** Extract thinking content from a ContentItem array */\nexport function extractThinking(content: ContentItem[]): string[] {\n  return content\n    .filter((item): item is ThinkingContent => item.type === \"thinking\")\n    .map((item) => item.thinking);\n}\n\n/** Extract tool use items from a ContentItem array */\nexport function extractToolUse(content: ContentItem[]): ToolUseContent[] {\n  return content.filter(\n    (item): item is ToolUseContent => item.type === \"tool_use\"\n  );\n}\n\n/** Check if content contains any tool use */\nexport function hasToolUse(content: ContentItem[]): boolean {\n  return content.some((item) => item.type === \"tool_use\");\n}\n\n/** Check if content contains thinking */\nexport function hasThinking(content: ContentItem[]): boolean {\n  return content.some((item) => item.type === \"thinking\");\n}\n\n// =============================================================================\n// Content Classification\n// =============================================================================\n\nexport type ContentCategory = \"text\" | \"tool-call\" | \"tool-result\" | \"thinking\" | \"mixed\";\n\n/** Classify what type of content a message contains */\nexport function classifyContent(content: ContentItem[]): ContentCategory {\n  const types = new Set(content.map((item) => item.type));\n\n  if (types.size === 0) return \"text\";\n  if (types.size === 1) {\n    if (types.has(\"text\")) return \"text\";\n    if (types.has(\"thinking\")) return \"thinking\";\n    if (types.has(\"tool_use\")) return \"tool-call\";\n  }\n\n  return \"mixed\";\n}\n\n// =============================================================================\n// Message Analysis\n// =============================================================================\n\n/** Get a summary label for a user message */\nexport function getUserMessageLabel(msg: UserMessage, maxLength = 30): string {\n  if (msg.toolUseResult) {\n    // String results are errors, object results check is_error flag\n    if (typeof msg.toolUseResult === \"string\") {\n      return \"Tool error\";\n    }\n    return msg.toolUseResult.is_error ? \"Tool error\" : \"Tool result\";\n  }\n\n  const text = extractText(msg.message.content);\n  if (text.length <= maxLength) {\n    return text.replace(/\\n/g, \" \");\n  }\n\n  return text.substring(0, maxLength - 1).replace(/\\n/g, \" \") + \"…\";\n}\n\n/** Get a summary label for an assistant message */\nexport function getAssistantMessageLabel(\n  msg: AssistantMessage,\n  maxLength = 30\n): string {\n  const content = msg.message.content;\n\n  // If it's primarily a tool call, describe the tool\n  const tools = extractToolUse(content);\n  if (tools.length > 0) {\n    const firstTool = tools[0]!;\n    if (tools.length === 1) {\n      return `${firstTool.name}`;\n    }\n    return `${firstTool.name} (+${tools.length - 1} more)`;\n  }\n\n  // Otherwise, use the text content\n  const text = extractText(content);\n  if (text.length <= maxLength) {\n    return text.replace(/\\n/g, \" \");\n  }\n\n  return text.substring(0, maxLength - 1).replace(/\\n/g, \" \") + \"…\";\n}\n\n// =============================================================================\n// Tool Input Formatting\n// =============================================================================\n\n/** Get a short description of tool input for display */\nexport function formatToolInputSummary(tool: ToolUseContent): string {\n  const { name, input } = tool;\n\n  switch (name) {\n    case \"Read\":\n    case \"Write\":\n    case \"Edit\":\n    case \"MultiEdit\":\n      if (typeof input[\"file_path\"] === \"string\") {\n        return input[\"file_path\"];\n      }\n      break;\n\n    case \"Bash\":\n      if (typeof input[\"command\"] === \"string\") {\n        const cmd = input[\"command\"];\n        return cmd.length > 50 ? cmd.substring(0, 49) + \"…\" : cmd;\n      }\n      break;\n\n    case \"Glob\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        return input[\"pattern\"];\n      }\n      break;\n\n    case \"Grep\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        return `/${input[\"pattern\"]}/`;\n      }\n      break;\n\n    case \"Task\":\n      if (typeof input[\"description\"] === \"string\") {\n        return input[\"description\"];\n      }\n      if (typeof input[\"prompt\"] === \"string\") {\n        const prompt = input[\"prompt\"];\n        return prompt.length > 50 ? prompt.substring(0, 49) + \"…\" : prompt;\n      }\n      break;\n\n    case \"WebFetch\":\n      if (typeof input[\"url\"] === \"string\") {\n        return input[\"url\"];\n      }\n      break;\n\n    case \"WebSearch\":\n      if (typeof input[\"query\"] === \"string\") {\n        return input[\"query\"];\n      }\n      break;\n\n    case \"TodoWrite\":\n      if (Array.isArray(input[\"todos\"])) {\n        return `${input[\"todos\"].length} items`;\n      }\n      break;\n  }\n\n  return \"\";\n}\n\n// =============================================================================\n// Output Truncation\n// =============================================================================\n\n/** Truncate multi-line output with line count indicator */\nexport function truncateOutput(\n  text: string,\n  maxLines: number,\n  maxLineLength = 200\n): { text: string; truncated: boolean; hiddenLines: number } {\n  const lines = text.split(\"\\n\");\n\n  // Truncate individual lines that are too long\n  const truncatedLines = lines.map((line) =>\n    line.length > maxLineLength\n      ? line.substring(0, maxLineLength - 1) + \"…\"\n      : line\n  );\n\n  if (truncatedLines.length <= maxLines) {\n    return {\n      text: truncatedLines.join(\"\\n\"),\n      truncated: false,\n      hiddenLines: 0,\n    };\n  }\n\n  return {\n    text: truncatedLines.slice(0, maxLines).join(\"\\n\"),\n    truncated: true,\n    hiddenLines: truncatedLines.length - maxLines,\n  };\n}\n","/**\n * ANSI escape code utilities for terminal rendering\n * Provides 24-bit color support, text styling, and word wrapping with hard-breaking\n */\n\n// =============================================================================\n// ANSI Escape Sequences\n// =============================================================================\n\nconst ESC = \"\\x1b\";\nconst CSI = `${ESC}[`;\n\n/** Reset all styling */\nexport const RESET = `${CSI}0m`;\n\n// =============================================================================\n// Text Styles\n// =============================================================================\n\nexport const BOLD = `${CSI}1m`;\nexport const DIM = `${CSI}2m`;\nexport const ITALIC = `${CSI}3m`;\nexport const UNDERLINE = `${CSI}4m`;\n\nexport const STRIKETHROUGH = `${CSI}9m`;\n\nexport const RESET_BOLD = `${CSI}22m`;\nexport const RESET_DIM = `${CSI}22m`;\nexport const RESET_ITALIC = `${CSI}23m`;\nexport const RESET_UNDERLINE = `${CSI}24m`;\nexport const RESET_STRIKETHROUGH = `${CSI}29m`;\n\n// =============================================================================\n// 24-bit Color Functions\n// =============================================================================\n\n/** Parse hex color to RGB tuple */\nexport function hexToRgb(hex: string): [number, number, number] {\n  const clean = hex.replace(\"#\", \"\");\n  const r = parseInt(clean.substring(0, 2), 16);\n  const g = parseInt(clean.substring(2, 4), 16);\n  const b = parseInt(clean.substring(4, 6), 16);\n  return [r, g, b];\n}\n\n/** Set foreground color using 24-bit RGB */\nexport function fg(hex: string): string {\n  const [r, g, b] = hexToRgb(hex);\n  return `${CSI}38;2;${r};${g};${b}m`;\n}\n\n/** Set background color using 24-bit RGB */\nexport function bg(hex: string): string {\n  const [r, g, b] = hexToRgb(hex);\n  return `${CSI}48;2;${r};${g};${b}m`;\n}\n\n/** Apply foreground color to text and reset */\nexport function colorize(text: string, hex: string): string {\n  return `${fg(hex)}${text}${RESET}`;\n}\n\n/** Apply foreground color and style to text */\nexport function style(\n  text: string,\n  options: {\n    fg?: string;\n    bg?: string;\n    bold?: boolean;\n    dim?: boolean;\n    italic?: boolean;\n  }\n): string {\n  let prefix = \"\";\n  const suffix = RESET;\n\n  if (options.bold) prefix += BOLD;\n  if (options.dim) prefix += DIM;\n  if (options.italic) prefix += ITALIC;\n  if (options.fg) prefix += fg(options.fg);\n  if (options.bg) prefix += bg(options.bg);\n\n  return `${prefix}${text}${suffix}`;\n}\n\n// =============================================================================\n// Box Drawing Characters\n// =============================================================================\n\nexport const BOX = {\n  // Single line\n  horizontal: \"─\",\n  vertical: \"│\",\n  topLeft: \"┌\",\n  topRight: \"┐\",\n  bottomLeft: \"└\",\n  bottomRight: \"┘\",\n  teeRight: \"├\",\n  teeLeft: \"┤\",\n  teeDown: \"┬\",\n  teeUp: \"┴\",\n  cross: \"┼\",\n\n  // Rounded corners\n  roundTopLeft: \"╭\",\n  roundTopRight: \"╮\",\n  roundBottomLeft: \"╰\",\n  roundBottomRight: \"╯\",\n\n  // Double line\n  doubleHorizontal: \"═\",\n  doubleVertical: \"║\",\n\n  // Bullets and markers\n  bullet: \"●\",\n  bulletHollow: \"○\",\n  check: \"✓\",\n  crossMark: \"✗\",\n  arrow: \"→\",\n  arrowDown: \"↓\",\n  arrowSubagent: \"⤵\",\n  indent: \"⎿\",\n} as const;\n\n// =============================================================================\n// Text Manipulation\n// =============================================================================\n\n/** Wrap text to specified width, preserving words when possible, hard-breaking when necessary */\nexport function wordWrap(text: string, width: number): string[] {\n  if (width <= 0) return [text];\n\n  const lines: string[] = [];\n  const paragraphs = text.split(\"\\n\");\n\n  for (const paragraph of paragraphs) {\n    if (paragraph.length <= width) {\n      lines.push(paragraph);\n      continue;\n    }\n\n    const words = paragraph.split(/\\s+/);\n    let currentLine = \"\";\n\n    for (const word of words) {\n      // Handle words longer than width - hard break them\n      if (word.length > width) {\n        // First, flush current line if any\n        if (currentLine.length > 0) {\n          lines.push(currentLine);\n          currentLine = \"\";\n        }\n        // Break long word into chunks\n        for (let i = 0; i < word.length; i += width) {\n          lines.push(word.slice(i, i + width));\n        }\n        continue;\n      }\n\n      if (currentLine.length === 0) {\n        currentLine = word;\n      } else if (currentLine.length + 1 + word.length <= width) {\n        currentLine += \" \" + word;\n      } else {\n        lines.push(currentLine);\n        currentLine = word;\n      }\n    }\n\n    if (currentLine.length > 0) {\n      lines.push(currentLine);\n    }\n  }\n\n  return lines;\n}\n\n/** Truncate text with ellipsis */\nexport function truncate(text: string, maxLength: number): string {\n  if (text.length <= maxLength) return text;\n  return text.substring(0, maxLength - 1) + \"…\";\n}\n\n/** Indent each line of text */\nexport function indent(text: string, spaces: number): string {\n  const prefix = \" \".repeat(spaces);\n  return text\n    .split(\"\\n\")\n    .map((line) => prefix + line)\n    .join(\"\\n\");\n}\n\n/** Remove ANSI escape codes for length calculation */\nexport function stripAnsi(text: string): string {\n  // eslint-disable-next-line no-control-regex\n  return text.replace(/\\x1b\\[[0-9;]*m/g, \"\");\n}\n\n/** Get visible length of text (excluding ANSI codes) */\nexport function visibleLength(text: string): number {\n  return stripAnsi(text).length;\n}\n\n// =============================================================================\n// Line Building Helpers\n// =============================================================================\n\n/** Create a horizontal rule */\nexport function horizontalRule(width: number, color?: string): string {\n  const line = BOX.horizontal.repeat(width);\n  return color ? colorize(line, color) : line;\n}\n\n// =============================================================================\n// Cursor Control\n// =============================================================================\n\n/** Save cursor position */\nexport function saveCursor(): string {\n  return `${CSI}s`;\n}\n\n/** Restore cursor position */\nexport function restoreCursor(): string {\n  return `${CSI}u`;\n}\n\n/** Move cursor to row, col (1-indexed) */\nexport function moveTo(row: number, col: number = 1): string {\n  return `${CSI}${row};${col}H`;\n}\n\n/** Move cursor to column (1-indexed) */\nexport function moveToCol(col: number): string {\n  return `${CSI}${col}G`;\n}\n\n/** Erase from cursor to end of line */\nexport function eraseToEndOfLine(): string {\n  return `${CSI}K`;\n}\n\n/** Erase entire line */\nexport function eraseLine(): string {\n  return `${CSI}2K`;\n}\n\n/** Set scroll region (top and bottom rows, 1-indexed) */\nexport function setScrollRegion(top: number, bottom: number): string {\n  return `${CSI}${top};${bottom}r`;\n}\n\n/** Reset scroll region to full terminal */\nexport function resetScrollRegion(): string {\n  return `${CSI}r`;\n}\n\n// =============================================================================\n// Box Drawing\n// =============================================================================\n\n/** Create a box around text */\nexport function box(\n  content: string,\n  options: {\n    width?: number;\n    borderColor?: string;\n    rounded?: boolean;\n  } = {}\n): string {\n  const { width = 80, borderColor, rounded = false } = options;\n  const lines = content.split(\"\\n\");\n  const innerWidth = width - 4; // 2 for borders, 2 for padding\n\n  const tl = rounded ? BOX.roundTopLeft : BOX.topLeft;\n  const tr = rounded ? BOX.roundTopRight : BOX.topRight;\n  const bl = rounded ? BOX.roundBottomLeft : BOX.bottomLeft;\n  const br = rounded ? BOX.roundBottomRight : BOX.bottomRight;\n\n  const colorFn = borderColor ? (s: string) => colorize(s, borderColor) : (s: string) => s;\n\n  const top = colorFn(tl + BOX.horizontal.repeat(width - 2) + tr);\n  const bottom = colorFn(bl + BOX.horizontal.repeat(width - 2) + br);\n\n  const wrappedLines: string[] = [];\n  for (const line of lines) {\n    const wrapped = wordWrap(line, innerWidth);\n    wrappedLines.push(...wrapped);\n  }\n\n  const middle = wrappedLines.map((line) => {\n    const padding = \" \".repeat(Math.max(0, innerWidth - visibleLength(line)));\n    return colorFn(BOX.vertical) + \" \" + line + padding + \" \" + colorFn(BOX.vertical);\n  });\n\n  return [top, ...middle, bottom].join(\"\\n\");\n}\n","/**\n * Slash command parsing and rendering for Claude Code CLI commands\n * Handles XML-formatted command tags in user messages\n */\n\nimport { BOX, colorize, style } from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Parsed slash command from XML tags */\nexport interface ParsedCommand {\n  /** Command name (e.g., \"/clear\", \"/status\") */\n  name: string;\n  /** Human-readable message (e.g., \"clear\", \"status\") */\n  message: string;\n  /** Command arguments (often empty) */\n  args: string;\n  /** Command stdout output (may be empty) */\n  stdout: string;\n}\n\n/** Parsed bash mode command from XML tags */\nexport interface ParsedBashCommand {\n  /** The bash command that was executed */\n  input: string;\n  /** Standard output (may be empty) */\n  stdout: string;\n  /** Standard error (may be empty) */\n  stderr: string;\n}\n\n// =============================================================================\n// Command Tag Parsing\n// =============================================================================\n\n/**\n * Parse command XML tags from user message content.\n * Returns parsed command if found, null otherwise.\n *\n * Expected format:\n * <command-name>/clear</command-name>\n * <command-message>clear</command-message>\n * <command-args></command-args>\n *\n * And optionally in a following message:\n * <local-command-stdout>output text</local-command-stdout>\n */\nexport function parseCommandTags(content: string): ParsedCommand | null {\n  // Check for command-name tag\n  const nameMatch = content.match(/<command-name>([^<]*)<\\/command-name>/);\n  if (!nameMatch) {\n    return null;\n  }\n\n  const name = nameMatch[1] || \"\";\n\n  // Extract other tags\n  const messageMatch = content.match(/<command-message>([^<]*)<\\/command-message>/);\n  const argsMatch = content.match(/<command-args>([^<]*)<\\/command-args>/);\n  const stdoutMatch = content.match(/<local-command-stdout>([^<]*)<\\/local-command-stdout>/);\n\n  return {\n    name,\n    message: messageMatch?.[1] || \"\",\n    args: argsMatch?.[1] || \"\",\n    stdout: stdoutMatch?.[1] || \"\",\n  };\n}\n\n/**\n * Parse local-command-stdout tag from content.\n * Used for standalone stdout messages that follow command messages.\n */\nexport function parseLocalCommandStdout(content: string): string | null {\n  const match = content.match(/<local-command-stdout>([^<]*)<\\/local-command-stdout>/);\n  return match ? (match[1] || \"\") : null;\n}\n\n/**\n * Check if content is a command message (starts with command tags, not just contains them)\n */\nexport function isCommandMessage(content: string): boolean {\n  const trimmed = content.trim();\n  return trimmed.startsWith(\"<command-name>\") || trimmed.startsWith(\"<local-command-stdout>\");\n}\n\n// =============================================================================\n// Bash Mode Tag Parsing\n// =============================================================================\n\n/**\n * Check if content is a bash mode message (starts with bash tags)\n */\nexport function isBashMessage(content: string): boolean {\n  // Use includes to detect bash tags anywhere in content (may have \"Caveat:\" prefix)\n  return (\n    content.includes(\"<bash-input>\") ||\n    content.includes(\"<bash-stdout>\") ||\n    content.includes(\"<bash-stderr>\")\n  );\n}\n\n/**\n * Check if content is specifically a bash input message (command, not output)\n */\nexport function isBashInputMessage(content: string): boolean {\n  return content.includes(\"<bash-input>\");\n}\n\n/**\n * Parse bash-input tag from content.\n * Returns the command string if found, null otherwise.\n */\nexport function parseBashInput(content: string): string | null {\n  const match = content.match(/<bash-input>([\\s\\S]*?)<\\/bash-input>/);\n  return match ? (match[1] ?? \"\").trim() : null;\n}\n\n/**\n * Parse bash-stdout and bash-stderr tags from content.\n * Returns parsed output if found, null otherwise.\n */\nexport function parseBashOutput(content: string): { stdout: string; stderr: string } | null {\n  const stdoutMatch = content.match(/<bash-stdout>([\\s\\S]*?)<\\/bash-stdout>/);\n  const stderrMatch = content.match(/<bash-stderr>([\\s\\S]*?)<\\/bash-stderr>/);\n\n  if (!stdoutMatch && !stderrMatch) {\n    return null;\n  }\n\n  return {\n    stdout: (stdoutMatch?.[1] || \"\").trim(),\n    stderr: (stderrMatch?.[1] || \"\").trim(),\n  };\n}\n\n// =============================================================================\n// Command Rendering\n// =============================================================================\n\n/** Configuration for command rendering */\nexport interface CommandRenderConfig {\n  theme: RenderTheme;\n  width: number;\n  maxOutputLines?: number; // Max lines before truncation (default: 5)\n}\n\n/**\n * Render a parsed slash command for terminal display.\n * Format: [/command] args (if any)\n *         stdout (if non-empty)\n */\nexport function renderSlashCommand(\n  command: ParsedCommand,\n  cfg: CommandRenderConfig\n): string {\n  const { theme } = cfg;\n\n  // Format: \"> /command \" with arrow prefix, trailing space, white text on dark gray\n  // Note: command.name already includes the slash (e.g., \"/status\")\n  let line = `${BOX.arrow} ${command.name}`;\n\n  if (command.args.trim()) {\n    line += ` (${command.args})`;\n  }\n\n  // Add trailing space (matches Claude Code UI)\n  line += \" \";\n\n  // White text on dark gray background (matching Claude Code UI)\n  // fg: #ffffff (255;255;255), bg: #373737 (55;55;55)\n  const result = style(line, { fg: \"#ffffff\", bg: \"#373737\" });\n\n  // Include stdout if present (indented on next line)\n  if (command.stdout.trim()) {\n    const stdoutLine = colorize(`  ${command.stdout}`, theme.muted);\n    return `${result}\\n${stdoutLine}`;\n  }\n\n  return result;\n}\n\n/**\n * Render standalone local-command-stdout for terminal display.\n * Used when stdout appears in a separate message from the command.\n */\nexport function renderLocalStdout(\n  stdout: string,\n  cfg: CommandRenderConfig\n): string {\n  const { theme } = cfg;\n\n  // Skip empty or placeholder output\n  if (!stdout.trim() || stdout === \"...\") {\n    return \"\";\n  }\n\n  return colorize(`  ${stdout}`, theme.muted);\n}\n\n// =============================================================================\n// Bash Mode Rendering\n// =============================================================================\n\n// Bash mode colors (from authentic Claude Code rendering)\nconst BASH_MODE_PINK = \"#fd5db1\"; // rgb(253,93,177) - for ! prefix\nconst BASH_COMMAND_BG = \"#413c41\"; // rgb(65,60,65) - command box background\nconst BASH_COMMAND_TEXT = \"#ffffff\"; // rgb(255,255,255) - command text\nconst BASH_STDERR_COLOR = \"#ff6b80\"; // rgb(255,107,128) - error text\n\n/**\n * Render a bash mode command input for terminal display.\n * Format: [pink !][white command] on dark background\n */\nexport function renderBashInput(\n  command: string,\n  cfg: CommandRenderConfig\n): string {\n  // Format: \"! command \" with pink !, white text, dark bg, trailing space\n  const prefix = style(\"!\", { fg: BASH_MODE_PINK, bg: BASH_COMMAND_BG });\n  const cmdText = style(` ${command} `, { fg: BASH_COMMAND_TEXT, bg: BASH_COMMAND_BG });\n\n  return prefix + cmdText;\n}\n\n/**\n * Render bash mode output (stdout/stderr) for terminal display.\n * Format:   ⎿  output text (with tree connector)\n * Stderr is rendered in red, stdout in default/muted color.\n */\nexport function renderBashOutput(\n  output: { stdout: string; stderr: string },\n  cfg: CommandRenderConfig\n): string {\n  const { theme, maxOutputLines = 5 } = cfg;\n  const lines: string[] = [];\n\n  // Helper to render output lines with truncation\n  const renderLines = (\n    rawLines: string[],\n    color: string | null,\n    useConnector: boolean\n  ): number => {\n    const truncated = rawLines.length > maxOutputLines;\n    const displayLines = truncated ? rawLines.slice(0, maxOutputLines) : rawLines;\n\n    for (let i = 0; i < displayLines.length; i++) {\n      const line = displayLines[i];\n      const prefix = i === 0 && useConnector ? `  ${BOX.indent}  ` : \"     \";\n      const formatted = `${prefix}${line}`;\n      lines.push(color ? colorize(formatted, color) : formatted);\n    }\n\n    if (truncated) {\n      const hiddenCount = rawLines.length - maxOutputLines;\n      lines.push(\n        colorize(`     … +${hiddenCount} lines (ctrl+o to expand)`, theme.muted)\n      );\n    }\n\n    return displayLines.length;\n  };\n\n  // Render stderr first (if present) - in red\n  if (output.stderr.trim()) {\n    const stderrLines = output.stderr.split(\"\\n\");\n    renderLines(stderrLines, BASH_STDERR_COLOR, true);\n  }\n\n  // Render stdout (if present) - in muted/default color\n  if (output.stdout.trim()) {\n    const stdoutLines = output.stdout.split(\"\\n\");\n    const startWithConnector = lines.length === 0; // Only use connector if no stderr\n    renderLines(stdoutLines, null, startWithConnector);\n  }\n\n  return lines.join(\"\\n\");\n}\n","/**\n * Marker generation for asciicast navigation\n */\n\nimport type { TranscriptEntry, UserMessage, AssistantMessage } from \"../types/messages.js\";\nimport type { MarkerMode } from \"../types/asciicast.js\";\nimport { extractText, extractToolUse } from \"../renderer/content.js\";\nimport { isCommandMessage, parseCommandTags, parseLocalCommandStdout } from \"../renderer/commands.js\";\n\n// =============================================================================\n// Marker Configuration\n// =============================================================================\n\nexport interface MarkerOptions {\n  /** Which messages to create markers for */\n  mode: MarkerMode;\n  /** Maximum length for marker labels */\n  labelLength: number;\n}\n\nexport const DEFAULT_MARKER_OPTIONS: MarkerOptions = {\n  mode: \"all\",\n  labelLength: 30,\n};\n\n// =============================================================================\n// Marker Generation\n// =============================================================================\n\n/** Check if a message should have a marker based on mode */\nexport function shouldHaveMarker(\n  entry: TranscriptEntry,\n  mode: MarkerMode\n): boolean {\n  if (mode === \"none\") return false;\n\n  switch (entry.type) {\n    case \"user\":\n      // User prompts (not tool results)\n      if (entry.toolUseResult) {\n        return mode === \"all\" || mode === \"tools\";\n      }\n      return mode === \"all\" || mode === \"user\";\n\n    case \"assistant\":\n      // Assistant messages with tool calls\n      if (hasToolCalls(entry)) {\n        return mode === \"all\" || mode === \"tools\";\n      }\n      // Regular assistant messages\n      return mode === \"all\";\n\n    default:\n      return false;\n  }\n}\n\n/** Generate marker label for an entry */\nexport function generateMarkerLabel(\n  entry: TranscriptEntry,\n  maxLength: number = 30\n): string | null {\n  switch (entry.type) {\n    case \"user\":\n      return generateUserMarkerLabel(entry, maxLength);\n\n    case \"assistant\":\n      return generateAssistantMarkerLabel(entry, maxLength);\n\n    default:\n      return null;\n  }\n}\n\n// =============================================================================\n// User Message Markers\n// =============================================================================\n\nfunction generateUserMarkerLabel(msg: UserMessage, maxLength: number): string {\n  // Tool result\n  if (msg.toolUseResult) {\n    // String results are errors, object results check is_error flag\n    const isError = typeof msg.toolUseResult === \"string\" || msg.toolUseResult.is_error;\n    if (isError) {\n      return \"✗ Tool error\";\n    }\n    return \"✓ Tool result\";\n  }\n\n  // Regular user prompt\n  const text = extractText(msg.message.content).trim();\n  if (!text) return \"> (empty prompt)\";\n\n  // Check for slash command tags (e.g., <command-name>/clear</command-name>)\n  if (isCommandMessage(text)) {\n    const command = parseCommandTags(text);\n    if (command) {\n      // Preserve original Claude Code aesthetic: \"> /command (args)\"\n      // Note: command.name already includes the slash (e.g., \"/status\")\n      let marker = `> ${command.name}`;\n      if (command.args.trim()) {\n        marker += ` (${command.args})`;\n      }\n      return marker;\n    }\n    // Standalone local-command-stdout (empty output)\n    const stdout = parseLocalCommandStdout(text);\n    if (stdout !== null) {\n      return stdout ? \"> (command output)\" : \"> (command)\";\n    }\n  }\n\n  const firstLine = text.split(\"\\n\")[0] ?? \"\";\n  const cleaned = firstLine.replace(/\\s+/g, \" \").trim();\n\n  if (cleaned.length <= maxLength - 2) {\n    return `> ${cleaned}`;\n  }\n\n  return `> ${cleaned.substring(0, maxLength - 3)}…`;\n}\n\n// =============================================================================\n// Assistant Message Markers\n// =============================================================================\n\nfunction generateAssistantMarkerLabel(\n  msg: AssistantMessage,\n  maxLength: number\n): string {\n  const tools = extractToolUse(msg.message.content);\n\n  // If has tool calls, show tool info\n  if (tools.length > 0) {\n    const firstTool = tools[0]!;\n    const toolInfo = formatToolForMarker(firstTool.name, firstTool.input);\n\n    if (tools.length === 1) {\n      return truncateMarker(`● ${toolInfo}`, maxLength);\n    }\n    return truncateMarker(`● ${toolInfo} (+${tools.length - 1})`, maxLength);\n  }\n\n  // Regular text response\n  const text = extractText(msg.message.content).trim();\n  if (!text) return \"Claude: (empty)\";\n\n  const firstLine = text.split(\"\\n\")[0] ?? \"\";\n  const cleaned = firstLine.replace(/\\s+/g, \" \").trim();\n\n  if (cleaned.length <= maxLength - 8) {\n    return `Claude: ${cleaned}`;\n  }\n\n  return `Claude: ${cleaned.substring(0, maxLength - 9)}…`;\n}\n\n// =============================================================================\n// Tool Formatting for Markers\n// =============================================================================\n\nfunction formatToolForMarker(\n  name: string,\n  input: Record<string, unknown>\n): string {\n  switch (name) {\n    case \"Read\":\n    case \"Write\":\n    case \"Edit\":\n    case \"MultiEdit\":\n      if (typeof input[\"file_path\"] === \"string\") {\n        const path = input[\"file_path\"];\n        const filename = path.split(\"/\").pop() ?? path;\n        return `${name}(${filename})`;\n      }\n      return name;\n\n    case \"Bash\":\n      if (typeof input[\"command\"] === \"string\") {\n        const cmd = input[\"command\"];\n        const short = cmd.length > 20 ? cmd.substring(0, 19) + \"…\" : cmd;\n        return `Bash(${short})`;\n      }\n      return \"Bash\";\n\n    case \"Glob\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        return `Glob(${input[\"pattern\"]})`;\n      }\n      return \"Glob\";\n\n    case \"Grep\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        const pattern = input[\"pattern\"];\n        const short = pattern.length > 15 ? pattern.substring(0, 14) + \"…\" : pattern;\n        return `Grep(${short})`;\n      }\n      return \"Grep\";\n\n    case \"Task\":\n      if (typeof input[\"description\"] === \"string\") {\n        return `⤵ Task(${input[\"description\"]})`;\n      }\n      return \"⤵ Task\";\n\n    case \"TodoWrite\":\n      return \"TodoWrite\";\n\n    case \"WebFetch\":\n    case \"WebSearch\":\n      return name;\n\n    default:\n      return name;\n  }\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\nfunction hasToolCalls(msg: AssistantMessage): boolean {\n  return msg.message.content.some((item) => item.type === \"tool_use\");\n}\n\nfunction truncateMarker(label: string, maxLength: number): string {\n  if (label.length <= maxLength) return label;\n  return label.substring(0, maxLength - 1) + \"…\";\n}\n","/**\n * Todo list visualization for TodoWrite tool results\n * Renders todo items with status indicators, tree connectors, and styling\n */\n\nimport {\n  indent,\n  fg,\n  RESET,\n  BOLD,\n  RESET_BOLD,\n  STRIKETHROUGH,\n  RESET_STRIKETHROUGH,\n  wordWrap,\n} from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\nimport type { TodoItem } from \"../types/messages.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** TodoWrite tool result with old and new state */\nexport interface TodoWriteToolResult {\n  oldTodos?: TodoItem[];\n  newTodos: TodoItem[];\n}\n\n/** Configuration for todo list rendering */\nexport interface TodoRenderConfig {\n  theme: RenderTheme;\n  indentSize: number;\n  width: number;\n}\n\n// =============================================================================\n// Unicode Characters\n// =============================================================================\n\nconst TODO_CHARS = {\n  /** Unchecked ballot box (pending/in_progress) */\n  unchecked: \"\\u2610\", // ☐\n  /** Checked ballot box with X (completed) */\n  checked: \"\\u2612\", // ☒\n  /** Tree connector for first item */\n  treeConnector: \"\\u23BF\", // ⎿\n} as const;\n\n// =============================================================================\n// Type Guard\n// =============================================================================\n\n/**\n * Check if a tool result is a TodoWrite result with todo items\n */\nexport function isTodoWriteToolResult(result: unknown): result is TodoWriteToolResult {\n  if (typeof result !== \"object\" || result === null) return false;\n  const r = result as Record<string, unknown>;\n  return Array.isArray(r.newTodos) && r.newTodos.length > 0;\n}\n\n// =============================================================================\n// Main Renderer\n// =============================================================================\n\n/**\n * Render a TodoWrite tool result as a styled todo list\n */\nexport function renderTodoList(result: TodoWriteToolResult, cfg: TodoRenderConfig): string {\n  return renderTodos(result.newTodos, cfg);\n}\n\n/**\n * Render todos from tool call input (input.todos array)\n */\nexport function renderTodosFromInput(\n  input: Record<string, unknown>,\n  cfg: TodoRenderConfig\n): string | null {\n  if (!Array.isArray(input.todos) || input.todos.length === 0) {\n    return null;\n  }\n  return renderTodos(input.todos as TodoItem[], cfg);\n}\n\n/**\n * Core renderer for a list of todo items\n */\nfunction renderTodos(todos: TodoItem[], cfg: TodoRenderConfig): string {\n  const { theme, indentSize, width } = cfg;\n  const output: string[] = [];\n\n  // Prefix chars: \"⎿  \" or \"   \" = 3 chars, plus checkbox \"☐ \" = 2 chars = 5 total\n  // Available width for content = width - indentSize - 5\n  const prefixLen = 3; // tree connector/spaces\n  const checkboxLen = 2; // \"☐ \" or \"☒ \"\n  const contentWidth = width - indentSize - prefixLen - checkboxLen;\n\n  for (let i = 0; i < todos.length; i++) {\n    const todo = todos[i];\n    const isFirst = i === 0;\n\n    // Build the prefix: tree connector for first, spaces for rest\n    // Format: \"⎿  \" for first, \"   \" for rest (indentSize handles base indent)\n    const prefix = isFirst\n      ? `${TODO_CHARS.treeConnector}  `\n      : \"   \";\n\n    // Render the todo item based on status, with word wrapping\n    const itemLines = renderTodoItem(todo, theme, contentWidth);\n\n    // First line gets the prefix, continuation lines get spaces\n    for (let j = 0; j < itemLines.length; j++) {\n      const linePrefix = j === 0 ? prefix : \"   \";\n      output.push(indent(linePrefix + itemLines[j], indentSize));\n    }\n  }\n\n  return output.join(\"\\n\");\n}\n\n// =============================================================================\n// Item Rendering\n// =============================================================================\n\n/**\n * Render a single todo item with appropriate styling, returning wrapped lines\n */\nfunction renderTodoItem(todo: TodoItem, theme: RenderTheme, contentWidth: number): string[] {\n  switch (todo.status) {\n    case \"completed\":\n      return renderCompletedTodo(todo, theme, contentWidth);\n    case \"in_progress\":\n      return renderInProgressTodo(todo, theme, contentWidth);\n    case \"pending\":\n    default:\n      return renderPendingTodo(todo, theme, contentWidth);\n  }\n}\n\n/**\n * Render a pending todo: ☐ content (no special styling)\n */\nfunction renderPendingTodo(todo: TodoItem, _theme: RenderTheme, contentWidth: number): string[] {\n  const lines = wordWrap(todo.content, contentWidth);\n  return lines.map((line, i) =>\n    i === 0 ? `${TODO_CHARS.unchecked} ${line}` : `  ${line}`\n  );\n}\n\n/**\n * Render an in-progress todo: ☐ **content** (bold text)\n */\nfunction renderInProgressTodo(todo: TodoItem, _theme: RenderTheme, contentWidth: number): string[] {\n  const lines = wordWrap(todo.content, contentWidth);\n  return lines.map((line, i) =>\n    i === 0\n      ? `${TODO_CHARS.unchecked} ${BOLD}${line}${RESET_BOLD}`\n      : `  ${BOLD}${line}${RESET_BOLD}`\n  );\n}\n\n/**\n * Render a completed todo: ☒ ~~content~~ (gray + strikethrough)\n */\nfunction renderCompletedTodo(todo: TodoItem, theme: RenderTheme, contentWidth: number): string[] {\n  const grayFg = fg(theme.muted);\n  const lines = wordWrap(todo.content, contentWidth);\n  return lines.map((line, i) =>\n    i === 0\n      ? `${grayFg}${TODO_CHARS.checked} ${STRIKETHROUGH}${line}${RESET_STRIKETHROUGH}${RESET}`\n      : `${grayFg}  ${STRIKETHROUGH}${line}${RESET_STRIKETHROUGH}${RESET}`\n  );\n}\n","/**\n * Markdown-to-ANSI parser for assistant text\n * Converts markdown syntax to ANSI escape sequences for terminal rendering\n */\n\nimport { BOLD, RESET_BOLD, ITALIC, RESET_ITALIC, UNDERLINE, RESET_UNDERLINE, visibleLength, colorize, style } from \"./ansi.js\";\nimport type { RenderConfig } from \"./messages.js\";\n\n/**\n * Render markdown text to ANSI-styled output\n * Handles inline formatting (bold, italic, code), tables, and word wrapping\n */\nexport function renderMarkdown(text: string, cfg: RenderConfig): string {\n  const { theme, width } = cfg;\n\n  // Split into lines to preserve explicit line breaks\n  const inputLines = text.split(\"\\n\");\n  const outputLines: string[] = [];\n\n  let i = 0;\n  while (i < inputLines.length) {\n    const line = inputLines[i];\n\n    // Check if this starts a code block (```)\n    if (line.trimStart().startsWith(\"```\")) {\n      const indent = line.match(/^(\\s*)/)?.[1] || \"\";\n      // Collect lines until closing ```\n      const codeLines: string[] = [];\n      i++; // Skip opening fence\n      while (i < inputLines.length && !inputLines[i].trimStart().startsWith(\"```\")) {\n        codeLines.push(inputLines[i]);\n        i++;\n      }\n      i++; // Skip closing fence (if found)\n      // Render code block with muted styling, no word wrap\n      const rendered = renderCodeBlock(codeLines, indent, cfg);\n      outputLines.push(...rendered);\n      continue;\n    }\n\n    // Check if this is a horizontal rule (---, ***, ___)\n    if (/^(\\s*)[-*_]{3,}\\s*$/.test(line)) {\n      // Render as a line of dashes using box drawing character\n      const rule = \"─\".repeat(Math.min(width, 40)); // Cap at 40 chars for visual balance\n      outputLines.push(colorize(rule, theme.muted));\n      i++;\n      continue;\n    }\n\n    // Check if this is a header (starts with #)\n    const headerMatch = line.match(/^(#{1,6})\\s+(.+)$/);\n    if (headerMatch) {\n      const content = headerMatch[2];\n      // Render header as bold\n      const formatted = parseInlineFormatting(content, cfg);\n      // Wrap with bold\n      outputLines.push(`${BOLD}${formatted}${RESET_BOLD}`);\n      i++;\n      continue;\n    }\n\n    // Check if this is an unordered list item (-, *, +)\n    const unorderedMatch = line.match(/^(\\s*)([-*+])\\s+(.+)$/);\n    if (unorderedMatch) {\n      const indent = unorderedMatch[1];\n      const content = unorderedMatch[3];\n      const formatted = parseInlineFormatting(content, cfg);\n      // Use bullet character\n      outputLines.push(`${indent}• ${formatted}`);\n      i++;\n      continue;\n    }\n\n    // Check if this is an ordered list item (1., 2., etc.)\n    const orderedMatch = line.match(/^(\\s*)(\\d+)\\.\\s+(.+)$/);\n    if (orderedMatch) {\n      const indent = orderedMatch[1];\n      const num = orderedMatch[2];\n      const content = orderedMatch[3];\n      const formatted = parseInlineFormatting(content, cfg);\n      outputLines.push(`${indent}${num}. ${formatted}`);\n      i++;\n      continue;\n    }\n\n    // Check if this starts a table (line contains | and looks like a table row)\n    if (isTableRow(line)) {\n      // Collect all consecutive table rows\n      const tableLines: string[] = [];\n      while (i < inputLines.length && isTableRow(inputLines[i])) {\n        tableLines.push(inputLines[i]);\n        i++;\n      }\n      // Render the table with alignment\n      const renderedTable = renderTable(tableLines, cfg);\n      outputLines.push(...renderedTable);\n    } else {\n      // Regular line - parse inline formatting and word wrap\n      const formatted = parseInlineFormatting(line, cfg);\n      const wrapped = wordWrapAnsi(formatted, width, cfg);\n      outputLines.push(...wrapped);\n      i++;\n    }\n  }\n\n  return outputLines.join(\"\\n\");\n}\n\n/**\n * Check if a line looks like a markdown table row\n */\nfunction isTableRow(line: string): boolean {\n  // Must have at least one | and not be just dashes/pipes (separator row counts too)\n  return line.includes(\"|\") && line.trim().length > 0;\n}\n\n/**\n * Render a markdown table with aligned columns\n */\nfunction renderTable(lines: string[], cfg: RenderConfig): string[] {\n  const { theme } = cfg;\n\n  // Parse all rows into cells\n  const rows: string[][] = [];\n  const separatorIndices: number[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    // Check if this is a separator row (|---|---|)\n    if (/^\\|?[\\s\\-:|]+\\|?$/.test(line)) {\n      separatorIndices.push(i);\n      rows.push([]); // Placeholder\n      continue;\n    }\n\n    // Parse cells: split by |, trim, filter empty edge cells\n    const cells = line\n      .split(\"|\")\n      .map((c) => c.trim())\n      .filter((c, idx, arr) => {\n        // Filter out empty first/last cells from leading/trailing |\n        if (idx === 0 && c === \"\") return false;\n        if (idx === arr.length - 1 && c === \"\") return false;\n        return true;\n      });\n    rows.push(cells);\n  }\n\n  // Apply inline formatting to cells and calculate visible widths\n  const formattedRows: string[][] = [];\n  const colWidths: number[] = [];\n\n  for (let i = 0; i < rows.length; i++) {\n    if (separatorIndices.includes(i)) {\n      formattedRows.push([]); // Placeholder for separator\n      continue;\n    }\n    const formattedCells = rows[i].map((cell) => parseInlineFormatting(cell, cfg));\n    formattedRows.push(formattedCells);\n\n    // Calculate widths based on visible length (strips ANSI codes)\n    for (let col = 0; col < formattedCells.length; col++) {\n      const cellWidth = visibleLength(formattedCells[col]);\n      if (colWidths[col] === undefined || cellWidth > colWidths[col]) {\n        colWidths[col] = cellWidth;\n      }\n    }\n  }\n\n  // Render each row with padding based on visible width\n  const output: string[] = [];\n  for (let i = 0; i < formattedRows.length; i++) {\n    if (separatorIndices.includes(i)) {\n      // Render separator row with same spacing as data rows\n      const sep = colWidths.map((w) => \"-\".repeat(w)).join(\" | \");\n      output.push(colorize(sep, theme.muted));\n    } else {\n      // Render data row with ANSI-aware padding\n      const row = formattedRows[i];\n      const paddedCells = row.map((cell, col) => {\n        const targetWidth = colWidths[col] || visibleLength(cell);\n        const currentWidth = visibleLength(cell);\n        const padding = Math.max(0, targetWidth - currentWidth);\n        return cell + \" \".repeat(padding);\n      });\n      const rowStr = paddedCells.join(\" | \");\n      output.push(rowStr);\n    }\n  }\n\n  return output;\n}\n\n/**\n * Render a code block with preserved formatting\n * No word wrap, muted styling to distinguish from regular text\n */\nfunction renderCodeBlock(lines: string[], indent: string, cfg: RenderConfig): string[] {\n  const { theme } = cfg;\n  // Render each line with dim styling, preserve exact content\n  return lines.map((line) => {\n    // Preserve original indentation, add block indent if any\n    const content = indent + line;\n    return style(content, { dim: true, fg: theme.muted });\n  });\n}\n\n/**\n * Parse inline markdown formatting and convert to ANSI\n * Processing order: code first (protected), then bold, then italic\n */\nfunction parseInlineFormatting(text: string, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  // Step 1: Protect and render inline code first\n  // Use placeholder to prevent code content from being parsed\n  const codePlaceholders: string[] = [];\n  let result = text.replace(/`([^`]+)`/g, (_, code) => {\n    const rendered = colorize(code, theme.agent); // Purple accent like Ink\n    const placeholder = `\\x00CODE${codePlaceholders.length}\\x00`;\n    codePlaceholders.push(rendered);\n    return placeholder;\n  });\n\n  // Step 2: Handle escaped characters\n  // Replace \\* and \\_ with placeholders (without the literal char to avoid matching)\n  result = result.replace(/\\\\\\*/g, \"\\x00ESCSTAR\\x00\");\n  result = result.replace(/\\\\_/g, \"\\x00ESCUNDER\\x00\");\n\n  // Step 3: Parse links [text](url) - render as \"text\" with underline\n  result = result.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, (_, text, url) => {\n    // Show text underlined, URL in muted color after\n    return `${UNDERLINE}${text}${RESET_UNDERLINE} (${colorize(url, theme.muted)})`;\n  });\n\n  // Step 4: Parse bold (**text** or __text__)\n  result = result.replace(/\\*\\*([^*]+)\\*\\*/g, (_, content) => {\n    return `${BOLD}${content}${RESET_BOLD}`;\n  });\n  result = result.replace(/__([^_]+)__/g, (_, content) => {\n    return `${BOLD}${content}${RESET_BOLD}`;\n  });\n\n  // Step 5: Parse italic (*text* or _text_)\n  // Must not match inside words for underscore\n  result = result.replace(/\\*([^*]+)\\*/g, (_, content) => {\n    return `${ITALIC}${content}${RESET_ITALIC}`;\n  });\n  result = result.replace(/(?<![a-zA-Z0-9])_([^_]+)_(?![a-zA-Z0-9])/g, (_, content) => {\n    return `${ITALIC}${content}${RESET_ITALIC}`;\n  });\n\n  // Step 6: Restore escaped characters\n  /* eslint-disable no-control-regex */\n  result = result.replace(/\\x00ESCSTAR\\x00/g, \"*\");\n  result = result.replace(/\\x00ESCUNDER\\x00/g, \"_\");\n  /* eslint-enable no-control-regex */\n\n  // Step 7: Restore code placeholders\n  for (let i = 0; i < codePlaceholders.length; i++) {\n    result = result.replace(`\\x00CODE${i}\\x00`, codePlaceholders[i]);\n  }\n\n  // Apply base text color\n  return colorize(result, theme.assistantText);\n}\n\n/**\n * Word wrap text containing ANSI escape sequences\n * Uses visibleLength() to calculate actual display width\n */\nfunction wordWrapAnsi(text: string, width: number, _cfg: RenderConfig): string[] {\n  if (width <= 0) return [text];\n\n  const words = text.split(/(\\s+)/);\n  const lines: string[] = [];\n  let currentLine = \"\";\n  let currentWidth = 0;\n\n  for (const word of words) {\n    const wordWidth = visibleLength(word);\n\n    if (currentWidth === 0) {\n      // Start of line\n      currentLine = word;\n      currentWidth = wordWidth;\n    } else if (currentWidth + wordWidth <= width) {\n      // Word fits on current line\n      currentLine += word;\n      currentWidth += wordWidth;\n    } else if (word.match(/^\\s+$/)) {\n      // Whitespace that would exceed width - skip it\n      continue;\n    } else {\n      // Word doesn't fit - start new line\n      if (currentLine.trim()) {\n        lines.push(currentLine);\n      }\n      currentLine = word.trimStart();\n      currentWidth = visibleLength(currentLine);\n    }\n  }\n\n  // Don't forget the last line\n  if (currentLine.trim()) {\n    lines.push(currentLine);\n  }\n\n  // Handle empty input\n  if (lines.length === 0) {\n    lines.push(\"\");\n  }\n\n  return lines;\n}\n","/**\n * Theme configuration for rendering\n * Provides semantic colors for different message types\n */\n\nimport { THEMES, type AsciicastTheme } from \"../types/asciicast.js\";\n\n/** Semantic colors for message rendering */\nexport interface RenderTheme {\n  /** Terminal foreground */\n  fg: string;\n  /** Terminal background */\n  bg: string;\n  /** User prompt prefix and text */\n  userPrompt: string;\n  /** User prompt background color */\n  userPromptBg: string;\n  /** Assistant response text */\n  assistantText: string;\n  /** Tool name in tool calls */\n  toolName: string;\n  /** Success bullet for tool calls */\n  toolBulletSuccess: string;\n  /** Error bullet for failed tool calls */\n  toolBulletError: string;\n  /** Thinking block text (dimmed) */\n  thinking: string;\n  /** Box drawing characters */\n  boxDrawing: string;\n  /** File paths in tool calls */\n  filePath: string;\n  /** Muted/secondary text */\n  muted: string;\n  /** Agent/sidechain indicator */\n  agent: string;\n  /** Diff: line background for additions */\n  diffAddLineBg: string;\n  /** Diff: character background for changed chars in additions */\n  diffAddCharBg: string;\n  /** Diff: line background for removals */\n  diffRemoveLineBg: string;\n  /** Diff: character background for changed chars in removals */\n  diffRemoveCharBg: string;\n}\n\n/** Tokyo Night theme (default) */\nexport const TOKYO_NIGHT: RenderTheme = {\n  fg: \"#a9b1d6\",\n  bg: \"#1a1b26\",\n  userPrompt: \"#7aa2f7\",\n  userPromptBg: \"#373737\",\n  assistantText: \"#a9b1d6\",\n  toolName: \"#e0af68\",\n  toolBulletSuccess: \"#9ece6a\",\n  toolBulletError: \"#f7768e\",\n  thinking: \"#565f89\",\n  boxDrawing: \"#414868\",\n  filePath: \"#7dcfff\",\n  muted: \"#565f89\",\n  agent: \"#bb9af7\",\n  diffAddLineBg: \"#225c2b\",\n  diffAddCharBg: \"#38a660\",\n  diffRemoveLineBg: \"#5c2b2b\",\n  diffRemoveCharBg: \"#a63838\",\n};\n\n/** Tokyo Storm theme */\nexport const TOKYO_STORM: RenderTheme = {\n  ...TOKYO_NIGHT,\n  bg: \"#24283b\",\n};\n\n/** Dracula theme */\nexport const DRACULA: RenderTheme = {\n  fg: \"#f8f8f2\",\n  bg: \"#282a36\",\n  userPrompt: \"#8be9fd\",\n  userPromptBg: \"#373737\",\n  assistantText: \"#f8f8f2\",\n  toolName: \"#f1fa8c\",\n  toolBulletSuccess: \"#50fa7b\",\n  toolBulletError: \"#ff5555\",\n  thinking: \"#6272a4\",\n  boxDrawing: \"#44475a\",\n  filePath: \"#ff79c6\",\n  muted: \"#6272a4\",\n  agent: \"#bd93f9\",\n  diffAddLineBg: \"#1e4620\",\n  diffAddCharBg: \"#2e7d32\",\n  diffRemoveLineBg: \"#4a1e1e\",\n  diffRemoveCharBg: \"#8b2e2e\",\n};\n\n/** Nord theme */\nexport const NORD: RenderTheme = {\n  fg: \"#d8dee9\",\n  bg: \"#2e3440\",\n  userPrompt: \"#81a1c1\",\n  userPromptBg: \"#373737\",\n  assistantText: \"#d8dee9\",\n  toolName: \"#ebcb8b\",\n  toolBulletSuccess: \"#a3be8c\",\n  toolBulletError: \"#bf616a\",\n  thinking: \"#4c566a\",\n  boxDrawing: \"#3b4252\",\n  filePath: \"#88c0d0\",\n  muted: \"#4c566a\",\n  agent: \"#b48ead\",\n  diffAddLineBg: \"#2e4a3a\",\n  diffAddCharBg: \"#4a7a5c\",\n  diffRemoveLineBg: \"#4a2e2e\",\n  diffRemoveCharBg: \"#7a4a4a\",\n};\n\n/** Catppuccin Mocha theme */\nexport const CATPPUCCIN_MOCHA: RenderTheme = {\n  fg: \"#cdd6f4\",\n  bg: \"#1e1e2e\",\n  userPrompt: \"#89b4fa\",\n  userPromptBg: \"#373737\",\n  assistantText: \"#cdd6f4\",\n  toolName: \"#f9e2af\",\n  toolBulletSuccess: \"#a6e3a1\",\n  toolBulletError: \"#f38ba8\",\n  thinking: \"#585b70\",\n  boxDrawing: \"#45475a\",\n  filePath: \"#94e2d5\",\n  muted: \"#585b70\",\n  agent: \"#f5c2e7\",\n  diffAddLineBg: \"#264a35\",\n  diffAddCharBg: \"#40a060\",\n  diffRemoveLineBg: \"#4a2635\",\n  diffRemoveCharBg: \"#a04050\",\n};\n\n/** All available render themes */\nexport const RENDER_THEMES: Record<string, RenderTheme> = {\n  \"tokyo-night\": TOKYO_NIGHT,\n  \"tokyo-storm\": TOKYO_STORM,\n  dracula: DRACULA,\n  nord: NORD,\n  \"catppuccin-mocha\": CATPPUCCIN_MOCHA,\n};\n\n/** Get render theme by name, defaulting to tokyo-night */\nexport function getTheme(name: string): RenderTheme {\n  return RENDER_THEMES[name] ?? TOKYO_NIGHT;\n}\n\n/** Convert render theme to asciicast theme for embedding */\nexport function toAsciicastTheme(theme: RenderTheme): AsciicastTheme {\n  const name = Object.entries(RENDER_THEMES).find(\n    ([, t]) => t === theme\n  )?.[0];\n\n  if (name && THEMES[name]) {\n    return THEMES[name];\n  }\n\n  // Generate palette from theme colors\n  // ANSI colors 0-7: black, red, green, yellow, blue, magenta, cyan, white\n  // ANSI colors 8-15: bright variants\n  const palette = [\n    theme.bg, // black (background)\n    theme.toolBulletError, // red\n    theme.toolBulletSuccess, // green\n    theme.toolName, // yellow\n    theme.userPrompt, // blue\n    theme.agent, // magenta\n    theme.filePath, // cyan\n    theme.fg, // white (foreground)\n    theme.muted, // bright black\n    theme.toolBulletError, // bright red\n    theme.toolBulletSuccess, // bright green\n    theme.toolName, // bright yellow\n    theme.userPrompt, // bright blue\n    theme.agent, // bright magenta\n    theme.filePath, // bright cyan\n    theme.assistantText, // bright white\n  ].join(\":\");\n\n  return {\n    fg: theme.fg,\n    bg: theme.bg,\n    palette,\n  };\n}\n","/**\n * Diff visualization for Edit tool results\n * Renders structured patches with line numbers, +/- indicators, and colored backgrounds\n * Supports character-level highlighting for modified lines\n */\n\nimport { colorize, style, indent, RESET, wordWrap } from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\n\n// Line number width (5) + space (1) + prefix \" + \" (3) = 9 chars before content\nconst LINE_PREFIX_WIDTH = 9;\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** A single hunk from a unified diff */\nexport interface PatchHunk {\n  oldStart: number;\n  oldLines: number;\n  newStart: number;\n  newLines: number;\n  lines: string[]; // Each line prefixed with ' ', '+', or '-'\n}\n\n/** Edit tool result with structured patch data */\nexport interface EditToolResult {\n  filePath: string;\n  oldString: string;\n  newString: string;\n  originalFile?: string;\n  structuredPatch?: PatchHunk[];\n  userModified?: boolean;\n  replaceAll?: boolean;\n  content?: string;\n}\n\n/** Configuration for diff rendering */\nexport interface DiffRenderConfig {\n  theme: RenderTheme;\n  indentSize: number;\n  width: number;\n}\n\n/** A segment of text with change flag for character-level diff */\ninterface DiffSegment {\n  text: string;\n  changed: boolean;\n}\n\n// =============================================================================\n// Main Renderer\n// =============================================================================\n\n/**\n * Check if a tool result is an Edit result with structured patch data\n */\nexport function isEditToolResult(result: unknown): result is EditToolResult {\n  if (typeof result !== \"object\" || result === null) return false;\n  const r = result as Record<string, unknown>;\n  return (\n    typeof r.filePath === \"string\" &&\n    Array.isArray(r.structuredPatch) &&\n    r.structuredPatch.length > 0\n  );\n}\n\n/**\n * Render an Edit tool result as a diff visualization\n */\nexport function renderEditDiff(result: EditToolResult, cfg: DiffRenderConfig): string {\n  const { theme, indentSize } = cfg;\n  const output: string[] = [];\n\n  // Calculate statistics\n  let additions = 0;\n  let removals = 0;\n  for (const hunk of result.structuredPatch ?? []) {\n    for (const line of hunk.lines) {\n      if (line[0] === \"+\") additions++;\n      if (line[0] === \"-\") removals++;\n    }\n  }\n\n  // Render header\n  const statsText = `${additions} addition${additions !== 1 ? \"s\" : \"\"} and ${removals} removal${removals !== 1 ? \"s\" : \"\"}`;\n  const header = colorize(`Updated ${result.filePath} with ${statsText}`, theme.muted);\n  output.push(indent(header, indentSize));\n\n  // Render each hunk\n  // Calculate available width for content: total width - indent - prefix\n  const contentWidth = cfg.width - indentSize - LINE_PREFIX_WIDTH;\n  for (const hunk of result.structuredPatch ?? []) {\n    const hunkLines = renderHunk(hunk, theme, contentWidth);\n    for (const line of hunkLines) {\n      output.push(indent(line, indentSize));\n    }\n  }\n\n  return output.join(\"\\n\");\n}\n\n// =============================================================================\n// Hunk Rendering\n// =============================================================================\n\n/**\n * Render a single diff hunk with line numbers and colored backgrounds.\n * Identifies paired -/+ lines for character-level diff highlighting.\n */\nfunction renderHunk(hunk: PatchHunk, theme: RenderTheme, contentWidth: number): string[] {\n  const output: string[] = [];\n  let oldLineNum = hunk.oldStart;\n  let newLineNum = hunk.newStart;\n  const lines = hunk.lines;\n\n  let i = 0;\n  while (i < lines.length) {\n    const line = lines[i];\n    const prefix = line[0];\n    const content = line.slice(1);\n\n    switch (prefix) {\n      case \" \":\n        // Context line - show line number, no background\n        output.push(...renderContextLine(newLineNum, content, theme, contentWidth));\n        oldLineNum++;\n        newLineNum++;\n        i++;\n        break;\n\n      case \"-\": {\n        // Check if this is a modification (- followed by +)\n        const nextLine = lines[i + 1];\n        if (nextLine && nextLine[0] === \"+\") {\n          // Paired modification - render with character-level diff\n          const oldContent = content;\n          const newContent = nextLine.slice(1);\n          const { oldSegments, newSegments } = diffWords(oldContent, newContent);\n\n          output.push(...renderRemovalLineWithHighlight(oldLineNum, oldSegments, theme, contentWidth));\n          output.push(...renderAdditionLineWithHighlight(newLineNum, newSegments, theme, contentWidth));\n\n          oldLineNum++;\n          newLineNum++;\n          i += 2; // Skip both lines\n        } else {\n          // Pure removal\n          output.push(...renderRemovalLine(oldLineNum, content, theme, contentWidth));\n          oldLineNum++;\n          i++;\n        }\n        break;\n      }\n\n      case \"+\":\n        // Pure addition (not paired with a removal)\n        output.push(...renderAdditionLine(newLineNum, content, theme, contentWidth));\n        newLineNum++;\n        i++;\n        break;\n\n      default:\n        // Unknown prefix, render as context\n        output.push(...renderContextLine(newLineNum, line, theme, contentWidth));\n        newLineNum++;\n        i++;\n    }\n  }\n\n  return output;\n}\n\n// =============================================================================\n// Word-based Diff Algorithm\n// =============================================================================\n\n/**\n * Compute word-based diff between two lines.\n * Returns segments marked as changed or unchanged for both lines.\n */\nfunction diffWords(\n  oldLine: string,\n  newLine: string\n): { oldSegments: DiffSegment[]; newSegments: DiffSegment[] } {\n  // Split on word boundaries while preserving whitespace\n  const oldTokens = tokenize(oldLine);\n  const newTokens = tokenize(newLine);\n\n  // Compute LCS (longest common subsequence) to identify unchanged tokens\n  const lcs = longestCommonSubsequence(oldTokens, newTokens);\n\n  // Build segments for old line\n  const oldSegments = buildSegments(oldTokens, lcs, \"old\");\n\n  // Build segments for new line\n  const newSegments = buildSegments(newTokens, lcs, \"new\");\n\n  return { oldSegments, newSegments };\n}\n\n/**\n * Tokenize a line into words and whitespace, preserving order.\n */\nfunction tokenize(line: string): string[] {\n  // Split on whitespace boundaries while keeping the whitespace\n  const tokens: string[] = [];\n  let current = \"\";\n  let inWhitespace: boolean | null = null;\n\n  for (const char of line) {\n    const isWs = /\\s/.test(char);\n    if (inWhitespace === null) {\n      // First character\n      current = char;\n      inWhitespace = isWs;\n    } else if (isWs === inWhitespace) {\n      // Same type as current token, append\n      current += char;\n    } else {\n      // Different type, push current and start new\n      tokens.push(current);\n      current = char;\n      inWhitespace = isWs;\n    }\n  }\n\n  if (current) {\n    tokens.push(current);\n  }\n\n  return tokens;\n}\n\n/**\n * Find the longest common subsequence of tokens.\n * Returns a Set of token indices that are part of the LCS.\n */\nfunction longestCommonSubsequence(\n  oldTokens: string[],\n  newTokens: string[]\n): Map<string, Set<number>> {\n  const m = oldTokens.length;\n  const n = newTokens.length;\n\n  // DP table\n  const dp: number[][] = Array(m + 1)\n    .fill(null)\n    .map(() => Array(n + 1).fill(0));\n\n  // Fill DP table\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (oldTokens[i - 1] === newTokens[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n\n  // Backtrack to find LCS indices\n  const oldLcsIndices = new Set<number>();\n  const newLcsIndices = new Set<number>();\n\n  let i = m;\n  let j = n;\n  while (i > 0 && j > 0) {\n    if (oldTokens[i - 1] === newTokens[j - 1]) {\n      oldLcsIndices.add(i - 1);\n      newLcsIndices.add(j - 1);\n      i--;\n      j--;\n    } else if (dp[i - 1][j] > dp[i][j - 1]) {\n      i--;\n    } else {\n      j--;\n    }\n  }\n\n  return new Map([\n    [\"old\", oldLcsIndices],\n    [\"new\", newLcsIndices],\n  ]);\n}\n\n/**\n * Build diff segments from tokens, marking which are changed.\n */\nfunction buildSegments(\n  tokens: string[],\n  lcs: Map<string, Set<number>>,\n  side: \"old\" | \"new\"\n): DiffSegment[] {\n  const lcsIndices = lcs.get(side) ?? new Set();\n  const segments: DiffSegment[] = [];\n\n  for (let i = 0; i < tokens.length; i++) {\n    const changed = !lcsIndices.has(i);\n    const text = tokens[i];\n\n    // Merge with previous segment if same change status\n    if (segments.length > 0 && segments[segments.length - 1].changed === changed) {\n      segments[segments.length - 1].text += text;\n    } else {\n      segments.push({ text, changed });\n    }\n  }\n\n  return segments;\n}\n\n// =============================================================================\n// Line Rendering\n// =============================================================================\n\n/**\n * Render a context line (unchanged), with wrapping support\n */\nfunction renderContextLine(lineNum: number, content: string, theme: RenderTheme, contentWidth: number): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Wrap content if needed\n  if (contentWidth > 0 && content.length > contentWidth) {\n    const wrapped = wordWrap(content, contentWidth);\n    return wrapped.map((line, idx) => {\n      if (idx === 0) {\n        return `${lineNumStr}      ${line}`;\n      }\n      return `${lineNumPadding}      ${line}`;\n    });\n  }\n\n  return [`${lineNumStr}      ${content}`];\n}\n\n/**\n * Render a removal line with red background (no character highlighting), with wrapping\n */\nfunction renderRemovalLine(lineNum: number, content: string, theme: RenderTheme, contentWidth: number): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Wrap content if needed\n  if (contentWidth > 0 && content.length > contentWidth) {\n    const wrapped = wordWrap(content, contentWidth);\n    return wrapped.map((line, idx) => {\n      const styledContent = style(` - ${line}`, {\n        fg: \"#ffffff\",\n        bg: theme.diffRemoveLineBg,\n      });\n      if (idx === 0) {\n        return `${lineNumStr} ${styledContent}`;\n      }\n      return `${lineNumPadding} ${styledContent}`;\n    });\n  }\n\n  const styledContent = style(` - ${content}`, {\n    fg: \"#ffffff\",\n    bg: theme.diffRemoveLineBg,\n  });\n  return [`${lineNumStr} ${styledContent}`];\n}\n\n/**\n * Render an addition line with green background (no character highlighting), with wrapping\n */\nfunction renderAdditionLine(lineNum: number, content: string, theme: RenderTheme, contentWidth: number): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Wrap content if needed\n  if (contentWidth > 0 && content.length > contentWidth) {\n    const wrapped = wordWrap(content, contentWidth);\n    return wrapped.map((line, idx) => {\n      const styledContent = style(` + ${line}`, {\n        fg: \"#ffffff\",\n        bg: theme.diffAddLineBg,\n      });\n      if (idx === 0) {\n        return `${lineNumStr} ${styledContent}`;\n      }\n      return `${lineNumPadding} ${styledContent}`;\n    });\n  }\n\n  const styledContent = style(` + ${content}`, {\n    fg: \"#ffffff\",\n    bg: theme.diffAddLineBg,\n  });\n  return [`${lineNumStr} ${styledContent}`];\n}\n\n/**\n * Render a removal line with character-level highlighting for changed segments, with wrapping\n */\nfunction renderRemovalLineWithHighlight(\n  lineNum: number,\n  segments: DiffSegment[],\n  theme: RenderTheme,\n  contentWidth: number\n): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Calculate total visible content length\n  const totalLength = segments.reduce((sum, seg) => sum + seg.text.length, 0);\n\n  // If no wrapping needed, render simply\n  if (contentWidth <= 0 || totalLength <= contentWidth) {\n    let content = \"\";\n    for (const seg of segments) {\n      if (seg.changed) {\n        content += style(seg.text, { fg: \"#ffffff\", bg: theme.diffRemoveCharBg });\n      } else {\n        content += style(seg.text, { fg: \"#ffffff\", bg: theme.diffRemoveLineBg });\n      }\n    }\n    const prefix = style(\" - \", { fg: \"#ffffff\", bg: theme.diffRemoveLineBg });\n    return [`${lineNumStr} ${prefix}${content}${RESET}`];\n  }\n\n  // Wrap segments across multiple lines\n  return wrapSegmentedLine(\n    lineNumStr,\n    lineNumPadding,\n    \" - \",\n    segments,\n    theme.diffRemoveLineBg,\n    theme.diffRemoveCharBg,\n    contentWidth\n  );\n}\n\n/**\n * Render an addition line with character-level highlighting for changed segments, with wrapping\n */\nfunction renderAdditionLineWithHighlight(\n  lineNum: number,\n  segments: DiffSegment[],\n  theme: RenderTheme,\n  contentWidth: number\n): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Calculate total visible content length\n  const totalLength = segments.reduce((sum, seg) => sum + seg.text.length, 0);\n\n  // If no wrapping needed, render simply\n  if (contentWidth <= 0 || totalLength <= contentWidth) {\n    let content = \"\";\n    for (const seg of segments) {\n      if (seg.changed) {\n        content += style(seg.text, { fg: \"#ffffff\", bg: theme.diffAddCharBg });\n      } else {\n        content += style(seg.text, { fg: \"#ffffff\", bg: theme.diffAddLineBg });\n      }\n    }\n    const prefix = style(\" + \", { fg: \"#ffffff\", bg: theme.diffAddLineBg });\n    return [`${lineNumStr} ${prefix}${content}${RESET}`];\n  }\n\n  // Wrap segments across multiple lines\n  return wrapSegmentedLine(\n    lineNumStr,\n    lineNumPadding,\n    \" + \",\n    segments,\n    theme.diffAddLineBg,\n    theme.diffAddCharBg,\n    contentWidth\n  );\n}\n\n// =============================================================================\n// Wrapping Helper for Segmented Lines\n// =============================================================================\n\n/**\n * Wrap a line with character-level highlighting across multiple output lines.\n * Handles segments with different backgrounds and maintains styling across wraps.\n */\nfunction wrapSegmentedLine(\n  lineNumStr: string,\n  lineNumPadding: string,\n  prefixText: string,\n  segments: DiffSegment[],\n  lineBg: string,\n  charBg: string,\n  contentWidth: number\n): string[] {\n  const outputLines: string[] = [];\n  let currentLineContent = \"\";\n  let currentLineWidth = 0;\n  let isFirstLine = true;\n\n  // Process each segment\n  for (const seg of segments) {\n    const segBg = seg.changed ? charBg : lineBg;\n    let remaining = seg.text;\n\n    while (remaining.length > 0) {\n      const spaceLeft = contentWidth - currentLineWidth;\n\n      if (remaining.length <= spaceLeft) {\n        // Whole segment fits on current line\n        currentLineContent += style(remaining, { fg: \"#ffffff\", bg: segBg });\n        currentLineWidth += remaining.length;\n        remaining = \"\";\n      } else {\n        // Need to split segment\n        // Try to split at word boundary\n        let splitPoint = spaceLeft;\n        const lastSpace = remaining.lastIndexOf(\" \", spaceLeft);\n        if (lastSpace > 0) {\n          splitPoint = lastSpace + 1; // Include the space\n        }\n\n        // Safety: force progress if splitPoint is 0 (prevents infinite loop)\n        if (splitPoint <= 0) {\n          // Line is full with no room - emit it and continue\n          if (currentLineContent) {\n            const prefix = style(prefixText, { fg: \"#ffffff\", bg: lineBg });\n            if (isFirstLine) {\n              outputLines.push(`${lineNumStr} ${prefix}${currentLineContent}${RESET}`);\n              isFirstLine = false;\n            } else {\n              outputLines.push(`${lineNumPadding} ${prefix}${currentLineContent}${RESET}`);\n            }\n            currentLineContent = \"\";\n            currentLineWidth = 0;\n          }\n          // Force at least one character to prevent infinite loop\n          const chunk = remaining.slice(0, 1);\n          currentLineContent += style(chunk, { fg: \"#ffffff\", bg: segBg });\n          currentLineWidth += 1;\n          remaining = remaining.slice(1);\n          continue;\n        }\n\n        const chunk = remaining.slice(0, splitPoint);\n        currentLineContent += style(chunk, { fg: \"#ffffff\", bg: segBg });\n        remaining = remaining.slice(splitPoint);\n\n        // Emit current line\n        const prefix = style(prefixText, { fg: \"#ffffff\", bg: lineBg });\n        if (isFirstLine) {\n          outputLines.push(`${lineNumStr} ${prefix}${currentLineContent}${RESET}`);\n          isFirstLine = false;\n        } else {\n          outputLines.push(`${lineNumPadding} ${prefix}${currentLineContent}${RESET}`);\n        }\n\n        // Start new line\n        currentLineContent = \"\";\n        currentLineWidth = 0;\n      }\n    }\n  }\n\n  // Emit final line if there's content\n  if (currentLineContent || outputLines.length === 0) {\n    const prefix = style(prefixText, { fg: \"#ffffff\", bg: lineBg });\n    if (isFirstLine) {\n      outputLines.push(`${lineNumStr} ${prefix}${currentLineContent}${RESET}`);\n    } else {\n      outputLines.push(`${lineNumPadding} ${prefix}${currentLineContent}${RESET}`);\n    }\n  }\n\n  return outputLines;\n}\n","/**\n * Tool result extraction and rendering\n * Handles all Claude Code tool output formats (Read, Bash, Glob, TodoWrite, WebFetch, WebSearch, Task/Agent)\n */\n\nimport type { RenderConfig } from \"./messages.js\";\nimport { BOX, colorize, indent, wordWrap } from \"./ansi.js\";\nimport { isEditToolResult, renderEditDiff } from \"./diff.js\";\nimport { isTodoWriteToolResult } from \"./todos.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Tool result object - flexible to accommodate all tool formats */\nexport interface ToolResultContent {\n  content?: string | Array<{ type?: string; text?: string }>;\n  stdout?: string;\n  stderr?: string;\n  is_error?: boolean;\n  type?: string;\n  file?: { content?: string; filePath?: string };\n  filenames?: string[];\n  oldTodos?: unknown[];\n  newTodos?: unknown[];\n  // WebFetch result fields\n  result?: string;\n  url?: string;\n  // WebSearch result fields\n  query?: string;\n  results?: Array<{ title?: string; url?: string; snippet?: string } | string>;\n}\n\n// =============================================================================\n// Main Renderer\n// =============================================================================\n\n/**\n * Renders tool execution result with proper formatting.\n *\n * Supports multiple Claude Code tool result formats:\n * - Standard: `{ content: string }`\n * - Read tool: `{ type: \"text\", file: { content: string, filePath: string } }`\n * - Bash tool: `{ stdout: string, stderr: string }`\n * - Glob tool: `{ filenames: string[] }`\n * - TodoWrite: `{ oldTodos: [], newTodos: [] }`\n * - Empty results: `{}` (renders as bullet only)\n *\n * Priority: content > file.content > stdout/stderr > filenames > TodoWrite\n */\nexport function renderToolResult(\n  result: ToolResultContent,\n  cfg: RenderConfig\n): string {\n  const { theme, maxToolOutputLines } = cfg;\n\n  // Special handling for Edit tool results with diff visualization\n  if (isEditToolResult(result)) {\n    return renderEditDiff(result, {\n      theme,\n      indentSize: cfg.indentSize,\n      width: cfg.width,\n    });\n  }\n\n  // TodoWrite: suppress result rendering (todos shown with tool call)\n  if (isTodoWriteToolResult(result)) {\n    return \"\";\n  }\n\n  // Extract content from various formats\n  let contentText = \"\";\n  if (Array.isArray(result.content)) {\n    // Task/Agent/MCP result with content array: [{type: \"text\", text: \"...\"}, {type: \"image\", ...}]\n    const parts: string[] = [];\n    let hasImage = false;\n    for (const item of result.content) {\n      if (item && typeof item.text === \"string\") {\n        parts.push(item.text);\n      } else if (item && item.type === \"image\") {\n        hasImage = true;\n      }\n    }\n    if (hasImage) {\n      parts.push(\"[Screenshot captured]\");\n    }\n    contentText = parts.join(\"\\n\");\n  } else if (typeof result.content === \"string\") {\n    // Standard content field\n    contentText = result.content;\n  } else if (typeof result.result === \"string\") {\n    // WebFetch result with fetched content\n    contentText = result.result;\n  } else if (Array.isArray(result.results)) {\n    // WebSearch result with results array\n    const parts: string[] = [];\n    if (result.query) {\n      parts.push(`Query: ${result.query}`);\n    }\n    for (const item of result.results) {\n      if (typeof item === \"string\") {\n        parts.push(item);\n      } else if (item && typeof item.title === \"string\") {\n        // Format: title + url + snippet\n        parts.push(`• ${item.title}`);\n        if (item.url) parts.push(`  ${item.url}`);\n        if (item.snippet) parts.push(`  ${item.snippet}`);\n      }\n    }\n    contentText = parts.join(\"\\n\");\n  } else if (result.file && typeof result.file.content === \"string\") {\n    // Read tool result with nested file.content\n    contentText = result.file.content;\n  } else if (result.stdout || result.stderr) {\n    // Bash-style result with stdout/stderr\n    const parts: string[] = [];\n    if (typeof result.stdout === \"string\") parts.push(result.stdout);\n    if (typeof result.stderr === \"string\") parts.push(result.stderr);\n    contentText = parts.join(\"\\n\");\n  } else if (Array.isArray(result.filenames)) {\n    // Glob result with filenames array\n    if (result.filenames.length === 0) {\n      contentText = \"(no matches)\";\n    } else {\n      contentText = result.filenames.join(\"\\n\");\n    }\n  } else if (result.oldTodos || result.newTodos) {\n    // TodoWrite result - minimal display\n    const count = Array.isArray(result.newTodos) ? result.newTodos.length : 0;\n    contentText = `Updated ${count} todos`;\n  }\n\n  // Handle empty content - return early with muted connector + bullet\n  if (!contentText) {\n    const bullet = result.is_error ? BOX.crossMark : BOX.check;\n    const bulletColor = result.is_error ? theme.toolBulletError : theme.toolBulletSuccess;\n    return colorize(`  ${BOX.indent} `, theme.muted) + colorize(bullet, bulletColor);\n  }\n\n  // Alignment constants: \"  ⎿  \" prefix = 5 chars\n  const treePrefix = \"  \"; // Align under tool bullet\n  const contentIndent = 5; // \"  ⎿  \" = 5 chars to align continuation lines\n\n  // Wrap each line to terminal width (accounting for content indent)\n  const wrapWidth = cfg.width - contentIndent;\n  const rawLines = contentText.split(\"\\n\");\n  const lines: string[] = [];\n  for (const rawLine of rawLines) {\n    const wrapped = wordWrap(rawLine, wrapWidth);\n    lines.push(...wrapped);\n  }\n\n  const truncated = lines.length > maxToolOutputLines;\n  const displayLines = truncated ? lines.slice(0, maxToolOutputLines) : lines;\n\n  const bulletColor = result.is_error ? theme.toolBulletError : theme.toolBulletSuccess;\n  const bullet = result.is_error ? BOX.crossMark : BOX.check;\n  const treeConnector = \"\\u23BF\"; // ⎿\n\n  const output: string[] = [];\n\n  for (let i = 0; i < displayLines.length; i++) {\n    const line = displayLines[i] ?? \"\";\n    if (i === 0) {\n      // First line: indented tree connector with bullet color\n      output.push(treePrefix + colorize(treeConnector, theme.muted) + \"  \" + line);\n    } else {\n      // Continuation lines: aligned with first line content\n      output.push(indent(line, contentIndent));\n    }\n  }\n\n  if (truncated) {\n    output.push(\n      indent(\n        colorize(`… +${lines.length - maxToolOutputLines} lines (ctrl+o to expand)`, theme.muted),\n        contentIndent\n      )\n    );\n  }\n\n  if (output.length === 0) {\n    return treePrefix + colorize(bullet, bulletColor);\n  }\n\n  return output.join(\"\\n\");\n}\n","/**\n * Tool name and argument formatting utilities\n * Converts tool metadata into display-friendly strings for terminal rendering\n */\n\nimport type { ToolUseContent } from \"../types/messages.js\";\nimport { colorize, truncate } from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Result of parsing and formatting a tool name */\nexport interface FormattedToolName {\n  displayName: string;\n  isMcp: boolean;\n}\n\n// =============================================================================\n// Tool Name Formatting\n// =============================================================================\n\n/**\n * Parse MCP tool name into display format.\n * \"mcp__chrome-devtools__click\" -> { displayName: \"chrome-devtools - click\", isMcp: true }\n */\nexport function formatToolName(name: string): FormattedToolName {\n  if (name.startsWith(\"mcp__\")) {\n    const parts = name.slice(5).split(\"__\"); // Remove \"mcp__\" prefix, split on \"__\"\n    if (parts.length >= 2) {\n      const server = parts[0];\n      const tool = parts.slice(1).join(\"__\"); // Handle tools with __ in name\n      return { displayName: `${server} - ${tool}`, isMcp: true };\n    }\n  }\n  return { displayName: name, isMcp: false };\n}\n\n// =============================================================================\n// Tool Arguments Formatting\n// =============================================================================\n\n/**\n * Format tool arguments for display in tool call headers\n * Handles tool-specific argument extraction and truncation\n */\nexport function formatToolArgs(\n  tool: ToolUseContent,\n  theme: RenderTheme,\n  isMcp = false\n): string {\n  const input = tool.input;\n\n  // MCP tools: show first param as (key: \"value\")\n  if (isMcp && input && typeof input === \"object\") {\n    const keys = Object.keys(input);\n    if (keys.length > 0) {\n      const key = keys[0]!;\n      const value = input[key];\n      if (typeof value === \"string\") {\n        const truncated = truncate(value, 40);\n        return `(${key}: \"${colorize(truncated, theme.muted)}\")`;\n      }\n    }\n    return \"\";\n  }\n\n  // Format based on tool type\n  switch (tool.name) {\n    case \"Read\":\n    case \"Write\":\n    case \"Edit\":\n    case \"MultiEdit\":\n      if (typeof input[\"file_path\"] === \"string\") {\n        return `(${colorize(input[\"file_path\"], theme.filePath)})`;\n      }\n      break;\n\n    case \"Bash\":\n      if (typeof input[\"command\"] === \"string\") {\n        const cmd = truncate(input[\"command\"], 60);\n        return `(${colorize(cmd, theme.muted)})`;\n      }\n      break;\n\n    case \"Glob\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        return `(${colorize(input[\"pattern\"], theme.filePath)})`;\n      }\n      break;\n\n    case \"Grep\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        const pattern = truncate(input[\"pattern\"], 40);\n        return `(${colorize(pattern, theme.muted)})`;\n      }\n      break;\n\n    case \"Task\":\n      if (typeof input[\"description\"] === \"string\") {\n        const desc = truncate(input[\"description\"], 50);\n        return `(${colorize(desc, theme.agent)})`;\n      }\n      if (typeof input[\"prompt\"] === \"string\") {\n        const prompt = truncate(input[\"prompt\"], 50);\n        return `(${colorize(prompt, theme.agent)})`;\n      }\n      break;\n\n    case \"TodoWrite\":\n      return colorize(\" (updating todos)\", theme.muted);\n\n    case \"WebFetch\":\n    case \"WebSearch\":\n      if (typeof input[\"url\"] === \"string\") {\n        const url = truncate(input[\"url\"], 50);\n        return `(${colorize(url, theme.filePath)})`;\n      }\n      if (typeof input[\"query\"] === \"string\") {\n        const query = truncate(input[\"query\"], 50);\n        return `(${colorize(query, theme.muted)})`;\n      }\n      break;\n  }\n\n  // Fallback: show nothing or simple indicator\n  return \"\";\n}\n","/**\n * Message renderers - convert transcript entries to ANSI output\n */\n\nimport type {\n  TranscriptEntry,\n  UserMessage,\n  AssistantMessage,\n  SystemMessage,\n  ContentItem,\n  ToolUseContent,\n} from \"../types/messages.js\";\nimport { BOX, colorize, style, wordWrap } from \"./ansi.js\";\nimport { renderTodosFromInput } from \"./todos.js\";\nimport { renderMarkdown } from \"./markdown.js\";\nimport type { RenderTheme } from \"./theme.js\";\nimport { TOKYO_NIGHT } from \"./theme.js\";\nimport { renderToolResult } from \"./tool-results.js\";\nimport { formatToolName, formatToolArgs } from \"./tool-formatting.js\";\nimport {\n  isCommandMessage,\n  parseCommandTags,\n  parseLocalCommandStdout,\n  renderSlashCommand,\n  renderLocalStdout,\n  isBashMessage,\n  parseBashInput,\n  parseBashOutput,\n  renderBashInput,\n  renderBashOutput,\n} from \"./commands.js\";\n\n// =============================================================================\n// Render Configuration\n// =============================================================================\n\nexport interface RenderConfig {\n  /** Theme to use for colors */\n  theme: RenderTheme;\n  /** Terminal width for word wrapping */\n  width: number;\n  /** Maximum lines for tool output */\n  maxToolOutputLines: number;\n  /** Show thinking blocks */\n  showThinking: boolean;\n  /** Indent for nested content */\n  indentSize: number;\n}\n\nexport const DEFAULT_RENDER_CONFIG: RenderConfig = {\n  theme: TOKYO_NIGHT,\n  width: 100,\n  maxToolOutputLines: 5, // Matches Claude Code's compact display (wrapped lines counted)\n  showThinking: true,\n  indentSize: 2,\n};\n\n// =============================================================================\n// Main Renderer\n// =============================================================================\n\n/** Render a transcript entry to ANSI string */\nexport function renderMessage(\n  entry: TranscriptEntry,\n  config: Partial<RenderConfig> = {}\n): string {\n  const cfg = { ...DEFAULT_RENDER_CONFIG, ...config };\n\n  switch (entry.type) {\n    case \"user\":\n      // Skip meta messages (e.g., \"Caveat:\" system info)\n      if (entry.isMeta) {\n        return \"\";\n      }\n      return renderUserMessage(entry, cfg);\n    case \"assistant\":\n      return renderAssistantMessage(entry, cfg);\n    case \"system\":\n      return renderSystemMessage(entry, cfg);\n    case \"summary\":\n      return \"\"; // Skip rendering\n    case \"queue-operation\":\n      if (entry.operation === \"remove\") {\n        return renderQueueRemove(entry.content, cfg);\n      }\n      return \"\";\n    case \"file-history-snapshot\":\n      return \"\"; // Skip rendering\n    default:\n      return \"\";\n  }\n}\n\n// =============================================================================\n// User Message Renderer\n// =============================================================================\n\nfunction renderUserMessage(msg: UserMessage, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  // Tool result\n  if (msg.toolUseResult) {\n    // Handle string error results (e.g., hook errors)\n    if (typeof msg.toolUseResult === \"string\") {\n      return renderToolResult({ content: msg.toolUseResult, is_error: true }, cfg);\n    }\n    // Handle MCP array-format results: [{type:'text', text:'...'}, {type:'image', ...}]\n    if (Array.isArray(msg.toolUseResult)) {\n      return renderToolResult({ content: msg.toolUseResult }, cfg);\n    }\n    return renderToolResult(msg.toolUseResult, cfg);\n  }\n\n  // Regular user prompt\n  const content = extractTextContent(msg.message.content);\n  if (!content.trim()) return \"\";\n\n  // Check for interrupt message\n  if (content.includes(\"[Request interrupted by user]\")) {\n    return renderInterruptMessage(content, { theme, width: cfg.width });\n  }\n\n  // Check for slash command tags (e.g., <command-name>/clear</command-name>)\n  if (isCommandMessage(content)) {\n    // Full command with name, message, args\n    const command = parseCommandTags(content);\n    if (command) {\n      return renderSlashCommand(command, { theme, width: cfg.width });\n    }\n\n    // Standalone local-command-stdout\n    const stdout = parseLocalCommandStdout(content);\n    if (stdout !== null) {\n      return renderLocalStdout(stdout, { theme, width: cfg.width });\n    }\n  }\n\n  // Check for bash mode tags (e.g., <bash-input>pwd</bash-input>)\n  if (isBashMessage(content)) {\n    const bashInput = parseBashInput(content);\n    const bashOutput = parseBashOutput(content);\n    const cmdCfg = { theme, width: cfg.width };\n\n    // Render both input and output together when both present\n    if (bashInput !== null && bashOutput) {\n      return (\n        renderBashInput(bashInput, cmdCfg) +\n        \"\\n\" +\n        renderBashOutput(bashOutput, cmdCfg)\n      );\n    }\n\n    // Bash command input only\n    if (bashInput !== null) {\n      return renderBashInput(bashInput, cmdCfg);\n    }\n\n    // Bash output only (stdout/stderr)\n    if (bashOutput) {\n      return renderBashOutput(bashOutput, cmdCfg);\n    }\n  }\n\n  const lines = wordWrap(content, cfg.width - 4); // Account for \"> \" prefix\n\n  return lines\n    .map((line, i) => {\n      const text = i === 0 ? `${BOX.arrow} ${line}` : `  ${line}`;\n      return style(text, { fg: theme.userPrompt, bg: theme.userPromptBg });\n    })\n    .join(\"\\n\");\n}\n\n/**\n * Render interrupt message with semantic color styling\n * Format: ⎿ Interrupted · What should Claude do instead?\n * Colors: tree (text), \"Interrupted\" (error/red), separator and text (dim)\n */\nfunction renderInterruptMessage(\n  content: string,\n  cfg: { theme: RenderTheme; width: number }\n): string {\n  const { theme } = cfg;\n\n  // Tree connector character (same as todos)\n  const TREE_CONNECTOR = \"\\u23BF\"; // ⎿\n\n  // Build parts with semantic colors\n  const parts: string[] = [];\n\n  // Tree connector - text color\n  parts.push(colorize(TREE_CONNECTOR, theme.muted));\n\n  // \"Interrupted\" label - error/red color\n  parts.push(colorize(\"Interrupted\", theme.toolBulletError));\n\n  // Separator and follow-up text - dim color\n  parts.push(colorize(\"· What should Claude do instead?\", theme.muted));\n\n  return parts.join(\" \");\n}\n\n// =============================================================================\n// Assistant Message Renderer\n// =============================================================================\n\nfunction renderAssistantMessage(msg: AssistantMessage, cfg: RenderConfig): string {\n  const output: string[] = [];\n\n  for (const item of msg.message.content) {\n    const rendered = renderContentItem(item, cfg);\n    if (rendered) {\n      output.push(rendered);\n    }\n  }\n\n  return output.join(\"\\n\\n\");\n}\n\nfunction renderContentItem(item: ContentItem, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  switch (item.type) {\n    case \"text\":\n      return renderTextContent(item.text, cfg);\n\n    case \"thinking\":\n      if (!cfg.showThinking) return \"\";\n      return renderThinkingContent(item.thinking, cfg);\n\n    case \"tool_use\":\n      return renderToolUse(item, cfg);\n\n    case \"image\":\n      return colorize(\"[Image]\", theme.muted);\n\n    default:\n      return \"\";\n  }\n}\n\nfunction renderTextContent(text: string, cfg: RenderConfig): string {\n  // Parse markdown and render with ANSI styling\n  return renderMarkdown(text, cfg);\n}\n\nfunction renderThinkingContent(thinking: string, cfg: RenderConfig): string {\n  const { theme, width } = cfg;\n  const lines = wordWrap(thinking, width - 2);\n  const header = colorize(\"∴ Thinking…\", theme.thinking);\n\n  const content = lines\n    .map((line) => \"  \" + style(line, { fg: theme.thinking, italic: true }))\n    .join(\"\\n\");\n\n  return header + \"\\n\\n\" + content;\n}\n\nfunction renderToolUse(tool: ToolUseContent, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  const bullet = colorize(BOX.bullet, theme.toolBulletSuccess);\n  const { displayName, isMcp } = formatToolName(tool.name);\n  const name = style(displayName, { bold: true });\n  const mcpSuffix = isMcp ? colorize(\" (MCP)\", theme.muted) : \"\";\n  const args = formatToolArgs(tool, theme, isMcp);\n\n  const header = `${bullet} ${name}${mcpSuffix}${args}`;\n\n  // For TodoWrite, render todos inline with the tool call\n  if (tool.name === \"TodoWrite\") {\n    const todosOutput = renderTodosFromInput(tool.input, {\n      theme,\n      indentSize: cfg.indentSize,\n      width: cfg.width,\n    });\n    if (todosOutput) {\n      return header + \"\\n\" + todosOutput;\n    }\n  }\n\n  return header;\n}\n\n// =============================================================================\n// System Message Renderer\n// =============================================================================\n\nfunction renderSystemMessage(msg: SystemMessage, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  if (!msg.content) return \"\";\n\n  const levelColors: Record<string, string> = {\n    info: theme.muted,\n    warning: theme.toolName,\n    error: theme.toolBulletError,\n  };\n\n  const color = levelColors[msg.level ?? \"info\"] ?? theme.muted;\n  return colorize(`[${msg.level ?? \"system\"}] ${msg.content}`, color);\n}\n\n// =============================================================================\n// Queue Operation Renderer\n// =============================================================================\n\nfunction renderQueueRemove(\n  content: string | ContentItem[] | undefined,\n  cfg: RenderConfig\n): string {\n  const { theme } = cfg;\n  const text = typeof content === \"string\" ? content : extractTextContent(content ?? []);\n\n  if (!text.trim()) return \"\";\n\n  return style(`${BOX.arrow} ${text}`, { fg: theme.userPrompt, bg: theme.userPromptBg });\n}\n\n// =============================================================================\n// Content Extraction\n// =============================================================================\n\n/** Extract plain text from content (string or ContentItem array) */\nexport function extractTextContent(content: string | ContentItem[]): string {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  const texts: string[] = [];\n  for (const item of content) {\n    if (item.type === \"text\") {\n      texts.push(item.text);\n    }\n  }\n\n  return texts.join(\"\\n\");\n}\n","/**\n * User input UI renderer - emulates Claude Code's command line interface\n * Renders a fixed-position input area at the bottom of the terminal\n * with burst typing animation and proper cursor positioning\n */\n\nimport {\n  BOX,\n  colorize,\n  horizontalRule,\n  wordWrap,\n  moveTo,\n  eraseLine,\n  setScrollRegion,\n} from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface InputUIConfig {\n  /** Theme for colors */\n  theme: RenderTheme;\n  /** Terminal width */\n  width: number;\n  /** Terminal height (rows) */\n  height: number;\n  /** Text always starts at this column (0-indexed) */\n  textColumn: number;\n}\n\n/** Row positions for fixed input area (1-indexed for ANSI) */\nexport interface InputAreaRows {\n  /** Last row of scrolling content area */\n  scrollEnd: number;\n  /** Fixed spinner row (outside scroll region) */\n  spinnerRow: number;\n  /** Top horizontal line */\n  topLine: number;\n  /** Input row with arrow prompt */\n  input: number;\n  /** Bottom horizontal line */\n  bottomLine: number;\n}\n\n/** Calculate input area row positions based on terminal height\n * Layout for height=40:\n *   rows 1-36: scroll region (content)\n *   row 37: spinner (fixed, outside scroll region)\n *   row 38: topLine (input frame border)\n *   row 39: input (prompt line)\n *   row 40: bottomLine (input frame border)\n */\nexport function getInputAreaRows(height: number): InputAreaRows {\n  return {\n    scrollEnd: height - 4,    // 36 for height=40\n    spinnerRow: height - 3,   // 37 for height=40\n    topLine: height - 2,      // 38 for height=40\n    input: height - 1,        // 39 for height=40\n    bottomLine: height,       // 40 for height=40\n  };\n}\n\nexport interface BurstTypingConfig {\n  /** Initial delay between words (ms) */\n  initialGapMs: number;\n  /** Minimum delay between words (ms) */\n  minGapMs: number;\n  /** Decay factor per word (multiplied each time) */\n  decayFactor: number;\n}\n\nexport interface InputTypedSegment {\n  /** Text to output */\n  text: string;\n  /** Time offset from start (seconds) */\n  time: number;\n}\n\n// =============================================================================\n// Default Configurations\n// =============================================================================\n\nexport const DEFAULT_INPUT_UI_CONFIG: Omit<InputUIConfig, \"theme\"> = {\n  width: 100,\n  height: 40,\n  textColumn: 2, // After \"→ \" (arrow + space)\n};\n\n/**\n * Get the 1-indexed cursor column for the input area.\n * ANSI cursor positioning is 1-indexed, so textColumn (0-indexed) + 1.\n */\nexport function getCursorColumn(config: InputUIConfig): number {\n  return config.textColumn + 1;\n}\n\nexport const DEFAULT_BURST_TYPING_CONFIG: BurstTypingConfig = {\n  initialGapMs: 200,\n  minGapMs: 30,\n  decayFactor: 0.75,\n};\n\n// =============================================================================\n// Input UI Rendering\n// =============================================================================\n\n/**\n * Render the input UI frame (horizontal lines + arrow prompt)\n * Returns: [topLine, promptLine, bottomLine]\n */\nexport function renderInputFrame(config: InputUIConfig): {\n  topLine: string;\n  promptPrefix: string;\n  bottomLine: string;\n} {\n  const { theme, width } = config;\n  const lineColor = theme.muted;\n\n  return {\n    topLine: horizontalRule(width, lineColor),\n    promptPrefix: colorize(`${BOX.arrow} `, theme.userPrompt),\n    bottomLine: horizontalRule(width, lineColor),\n  };\n}\n\n/**\n * Wrap user text for input area, maintaining column 3 alignment\n * Returns lines with proper indentation for continuation lines\n */\nexport function wrapInputText(\n  text: string,\n  config: InputUIConfig\n): string[] {\n  const { width, textColumn } = config;\n  // Available width for text: total width minus prompt indent minus right margin\n  // The -1 right margin prevents text from reaching terminal edge (avoids wrap issues)\n  const textWidth = width - textColumn - 1;\n\n  // Handle explicit line breaks\n  const paragraphs = text.split(\"\\n\");\n  const allLines: string[] = [];\n\n  for (const para of paragraphs) {\n    const wrapped = wordWrap(para, textWidth);\n    allLines.push(...(wrapped.length > 0 ? wrapped : [\"\"]));\n  }\n\n  return allLines;\n}\n\n// =============================================================================\n// Burst Typing Animation\n// =============================================================================\n\n/**\n * Split text into words for burst typing\n * Preserves spaces as separate tokens for accurate replay\n */\nexport function splitIntoWords(text: string): string[] {\n  const tokens: string[] = [];\n  let current = \"\";\n\n  for (const char of text) {\n    if (char === \" \" || char === \"\\n\") {\n      if (current) {\n        tokens.push(current);\n        current = \"\";\n      }\n      tokens.push(char);\n    } else {\n      current += char;\n    }\n  }\n\n  if (current) {\n    tokens.push(current);\n  }\n\n  return tokens;\n}\n\n/**\n * Generate burst typing segments for user input\n * Words appear as chunks, gaps between words shrink exponentially\n */\nexport function generateBurstTypingSegments(\n  text: string,\n  startTime: number,\n  config: BurstTypingConfig = DEFAULT_BURST_TYPING_CONFIG\n): InputTypedSegment[] {\n  const words = splitIntoWords(text);\n  if (words.length === 0) {\n    return [];\n  }\n\n  const segments: InputTypedSegment[] = [];\n  let currentTime = startTime;\n  let currentGap = config.initialGapMs / 1000; // Convert to seconds\n\n  for (const word of words) {\n    segments.push({ text: word, time: currentTime });\n\n    // Only add gap after non-whitespace words\n    if (word.trim()) {\n      currentTime += currentGap;\n      // Decay the gap, but don't go below minimum\n      currentGap = Math.max(\n        config.minGapMs / 1000,\n        currentGap * config.decayFactor\n      );\n    }\n  }\n\n  return segments;\n}\n\n// =============================================================================\n// Fixed-Position Input Area\n// =============================================================================\n\nexport interface InputAnimationResult {\n  /** Segments for typing animation */\n  segments: InputTypedSegment[];\n  /** User prompt text formatted for scrolling area (→ text with wrapping) */\n  scrollOutput: string;\n  /** Total duration of animation (seconds) */\n  duration: number;\n}\n\n/**\n * Generate the initial input area setup at the bottom of the terminal\n * This sets up the scroll region and renders the 3-line input frame\n *\n * Layout for height=40:\n *   rows 1-36: scroll region (content)\n *   row 37: spinner row (outside scroll region, fixed position)\n *   rows 38-40: input frame (topLine, input, bottomLine)\n */\nexport function generateInputAreaSetup(config: InputUIConfig): string {\n  const rows = getInputAreaRows(config.height);\n  const frame = renderInputFrame(config);\n\n  // Set scroll region to exclude spinner row and input area\n  return (\n    setScrollRegion(1, rows.scrollEnd) +\n    moveTo(rows.topLine) +\n    frame.topLine +\n    moveTo(rows.input) +\n    frame.promptPrefix +\n    moveTo(rows.bottomLine) +\n    frame.bottomLine +\n    moveTo(rows.input, config.textColumn + 1) // Position cursor after \"→ \"\n  );\n}\n\n/**\n * Redraw the input frame (use after content output to restore corrupted frame)\n * This clears and redraws all 3 lines of the input area\n */\nexport function redrawInputFrame(config: InputUIConfig): string {\n  const rows = getInputAreaRows(config.height);\n  const frame = renderInputFrame(config);\n\n  return (\n    // Clear and redraw top line\n    moveTo(rows.topLine) +\n    eraseLine() +\n    frame.topLine +\n    // Clear and redraw input line with prompt\n    moveTo(rows.input) +\n    eraseLine() +\n    frame.promptPrefix +\n    // Clear and redraw bottom line\n    moveTo(rows.bottomLine) +\n    eraseLine() +\n    frame.bottomLine +\n    // Position cursor after \"→ \"\n    moveTo(rows.input, config.textColumn + 1)\n  );\n}\n\n/**\n * Generate complete input animation with fixed-position typing\n *\n * The animation:\n * 1. Types text in the input row with burst animation\n * 2. On \"submit\": clears input row, outputs user text to scrolling area\n * 3. Input area remains with empty prompt ready for next input\n */\nexport function generateInputAnimation(\n  text: string,\n  startTime: number,\n  uiConfig: InputUIConfig,\n  typingConfig: BurstTypingConfig = DEFAULT_BURST_TYPING_CONFIG\n): InputAnimationResult {\n  const { theme, width, textColumn } = uiConfig;\n  const rows = getInputAreaRows(uiConfig.height);\n  const frame = renderInputFrame(uiConfig);\n\n  const segments: InputTypedSegment[] = [];\n  let currentTime = startTime;\n\n  // Position cursor at input row after arrow prompt\n  const cursorCol = textColumn + 1; // After \"→ \"\n  segments.push({\n    text: moveTo(rows.input, cursorCol),\n    time: currentTime,\n  });\n  currentTime += 0.05;\n\n  // Truncate display text if it exceeds available width on input row\n  // Available space: width - textColumn (for \"→ \") - 1 (for ellipsis if needed)\n  const maxDisplayLength = width - textColumn - 1;\n  let displayText = text.replace(/\\n/g, \" \"); // Flatten newlines for single-line display\n  let extraDelay = 0;\n\n  if (displayText.length > maxDisplayLength) {\n    displayText = displayText.slice(0, maxDisplayLength - 1) + \"…\";\n    extraDelay = 0.4; // Simulate user typing longer before submit\n  }\n\n  // Generate burst typing segments for the truncated display text\n  const typingSegments = generateBurstTypingSegments(displayText, currentTime, typingConfig);\n  segments.push(...typingSegments);\n\n  // Update time to after typing\n  if (typingSegments.length > 0) {\n    const lastSegment = typingSegments[typingSegments.length - 1]!;\n    currentTime = lastSegment.time + 0.2 + extraDelay; // Pause before \"submit\"\n  }\n\n  // \"Submit\" - clear input row and prepare for output\n  // 1. Clear the input row back to just the arrow prompt\n  segments.push({\n    text:\n      moveTo(rows.input) +\n      eraseLine() +\n      frame.promptPrefix +\n      moveTo(rows.input, cursorCol), // Cursor back to input position\n    time: currentTime,\n  });\n  currentTime += 0.1;\n\n  // 2. Move to scrolling area and output user prompt\n  // The scrollOutput will be appended separately by the converter\n  segments.push({\n    text: moveTo(rows.scrollEnd) + \"\\r\\n\", // Move to scroll area, newline to scroll\n    time: currentTime,\n  });\n\n  // Generate formatted user prompt for scrolling area (→ text with wrapping)\n  const wrappedLines = wrapInputText(text, uiConfig);\n  const indent = \" \".repeat(textColumn + 1);\n  const scrollLines = wrappedLines.map((line, i) => {\n    const styledLine = colorize(line, theme.userPrompt);\n    return i === 0 ? frame.promptPrefix + styledLine : indent + styledLine;\n  });\n  const scrollOutput = scrollLines.join(\"\\r\\n\") + \"\\r\\n\";\n\n  return {\n    segments,\n    scrollOutput,\n    duration: currentTime - startTime,\n  };\n}\n","/**\n * Type definitions for Claude Code session JSONL messages\n * Based on claude-code-log models and real session analysis\n */\n\n// =============================================================================\n// Content Types (used in both user and assistant messages)\n// =============================================================================\n\nexport interface TextContent {\n  type: \"text\";\n  text: string;\n}\n\nexport interface ThinkingContent {\n  type: \"thinking\";\n  thinking: string;\n}\n\nexport interface ToolUseContent {\n  type: \"tool_use\";\n  id: string;\n  name: string;\n  input: Record<string, unknown>;\n}\n\nexport interface ImageContent {\n  type: \"image\";\n  source: {\n    type: \"base64\";\n    media_type: string;\n    data: string;\n  };\n}\n\nexport type ContentItem =\n  | TextContent\n  | ThinkingContent\n  | ToolUseContent\n  | ImageContent;\n\n// =============================================================================\n// Token Usage\n// =============================================================================\n\nexport interface TokenUsage {\n  input_tokens: number;\n  output_tokens: number;\n  cache_creation_input_tokens?: number;\n  cache_read_input_tokens?: number;\n}\n\n// =============================================================================\n// Tool Result (embedded in user messages)\n// =============================================================================\n\n/** A single todo item from TodoWrite tool */\nexport interface TodoItem {\n  content: string;\n  status: \"pending\" | \"in_progress\" | \"completed\";\n  activeForm?: string;\n}\n\n/**\n * Tool use result object - shape varies by tool type.\n */\nexport interface ToolUseResultObject {\n  type?: \"text\" | \"image\";\n  /** Content for simple tool results */\n  content?: string;\n  /** Read tool result with file content */\n  file?: {\n    filePath?: string;\n    content?: string;\n    numLines?: number;\n    startLine?: number;\n    totalLines?: number;\n  };\n  /** Stdout for Bash tool results */\n  stdout?: string;\n  /** Stderr for Bash tool results */\n  stderr?: string;\n  /** Interruption flag for Bash */\n  interrupted?: boolean;\n  /** Image flag */\n  isImage?: boolean;\n  is_error?: boolean;\n  agentId?: string; // References agent-{agentId}.jsonl\n  /** For Glob results */\n  filenames?: string[];\n  durationMs?: number;\n  numFiles?: number;\n  truncated?: boolean;\n  /** For TodoWrite results */\n  oldTodos?: TodoItem[];\n  newTodos?: TodoItem[];\n  /** For WebFetch results */\n  result?: string;\n  url?: string;\n  bytes?: number;\n  code?: number;\n  /** For WebSearch results */\n  query?: string;\n  results?: Array<{ title?: string; url?: string; snippet?: string } | string>;\n  durationSeconds?: number;\n  /** For Task/Agent results - content array with text items */\n  // Note: content can be string (standard) or array (Task result)\n}\n\n/** Tool result can be an object or a plain error string */\nexport type ToolUseResult = ToolUseResultObject | string;\n\n// =============================================================================\n// Message Types\n// =============================================================================\n\n/** Base fields present in most message types */\ninterface BaseMessage {\n  timestamp: string;\n  sessionId: string;\n  uuid: string;\n  parentUuid: string | null;\n  isSidechain?: boolean;\n}\n\n/** User message - human prompts and tool results */\nexport interface UserMessage extends BaseMessage {\n  type: \"user\";\n  userType: \"human\" | \"external\";\n  cwd: string;\n  version?: string;\n  message: {\n    role: \"user\";\n    content: string | ContentItem[];\n  };\n  toolUseResult?: ToolUseResult;\n  /** Meta messages (caveats, system info) should not use input animation */\n  isMeta?: boolean;\n}\n\n/** Assistant message - Claude's responses */\nexport interface AssistantMessage extends BaseMessage {\n  type: \"assistant\";\n  requestId?: string;\n  message: {\n    id: string;\n    type: \"message\";\n    role: \"assistant\";\n    model: string;\n    content: ContentItem[];\n    stop_reason: \"end_turn\" | \"tool_use\" | null;\n    usage?: TokenUsage;\n  };\n  context_management?: {\n    type: \"compacted\";\n    original_tokens?: TokenUsage;\n    compacted_tokens?: TokenUsage;\n  };\n}\n\n/** System message - warnings, info, errors */\nexport interface SystemMessage {\n  type: \"system\";\n  timestamp: string;\n  content: string | null;\n  level?: \"warning\" | \"info\" | \"error\";\n}\n\n/** Summary message - auto-generated session summaries */\nexport interface SummaryMessage {\n  type: \"summary\";\n  summary: string;\n  leafUuid: string;\n  cwd?: string;\n}\n\n/** Queue operation message - internal message queueing */\nexport interface QueueOperationMessage {\n  type: \"queue-operation\";\n  operation: \"enqueue\" | \"dequeue\" | \"remove\" | \"popAll\";\n  timestamp: string;\n  sessionId?: string;\n  content?: string | ContentItem[];\n}\n\n/** File history snapshot - internal file backup metadata (skip rendering) */\nexport interface FileHistorySnapshotMessage {\n  type: \"file-history-snapshot\";\n  [key: string]: unknown;\n}\n\n/** Union of all message types */\nexport type TranscriptEntry =\n  | UserMessage\n  | AssistantMessage\n  | SystemMessage\n  | SummaryMessage\n  | QueueOperationMessage\n  | FileHistorySnapshotMessage;\n\n/** Get the type-safe message type */\nexport function getMessageType(\n  entry: TranscriptEntry\n): TranscriptEntry[\"type\"] {\n  return entry.type;\n}\n\n/** Type guard for user messages */\nexport function isUserMessage(entry: TranscriptEntry): entry is UserMessage {\n  return entry.type === \"user\";\n}\n\n/** Type guard for assistant messages */\nexport function isAssistantMessage(\n  entry: TranscriptEntry\n): entry is AssistantMessage {\n  return entry.type === \"assistant\";\n}\n\n/** Type guard for system messages */\nexport function isSystemMessage(\n  entry: TranscriptEntry\n): entry is SystemMessage {\n  return entry.type === \"system\";\n}\n\n/** Type guard for summary messages */\nexport function isSummaryMessage(\n  entry: TranscriptEntry\n): entry is SummaryMessage {\n  return entry.type === \"summary\";\n}\n\n/** Type guard for queue operation messages */\nexport function isQueueOperationMessage(\n  entry: TranscriptEntry\n): entry is QueueOperationMessage {\n  return entry.type === \"queue-operation\";\n}\n\n/** Type guard for file history snapshot messages */\nexport function isFileHistorySnapshotMessage(\n  entry: TranscriptEntry\n): entry is FileHistorySnapshotMessage {\n  return entry.type === \"file-history-snapshot\";\n}\n\n/** Check if message should be rendered (skip internal types) */\nexport function isRenderableMessage(\n  entry: TranscriptEntry\n): entry is UserMessage | AssistantMessage | SystemMessage {\n  return (\n    entry.type === \"user\" ||\n    entry.type === \"assistant\" ||\n    (entry.type === \"system\" && entry.content !== null)\n  );\n}\n","{\n  \"verbs\": [\n    \"Accomplishing\",\n    \"Flambéing\",\n    \"Perusing\",\n    \"Wandering\",\n    \"Concocting\",\n    \"Julienning\",\n    \"Smooshing\",\n    \"Baking\",\n    \"Forging\",\n    \"Pontificating\",\n    \"Whisking\",\n    \"Crafting\",\n    \"Manifesting\",\n    \"Stewing\",\n    \"Bootstrapping\",\n    \"Galloping\",\n    \"Puttering\",\n    \"Zesting\",\n    \"Deciphering\",\n    \"Misting\",\n    \"Swooping\",\n    \"Caramelizing\",\n    \"Gusting\",\n    \"Reticulating\",\n    \"Doing\",\n    \"Mustering\",\n    \"Tomfoolering\",\n    \"Channelling\",\n    \"Herding\",\n    \"Schlepping\",\n    \"Elucidating\",\n    \"Nucleating\",\n    \"Unfurling\",\n    \"Coalescing\",\n    \"Imagining\",\n    \"Shimmying\",\n    \"Finagling\",\n    \"Percolating\",\n    \"Waiting\",\n    \"Computing\",\n    \"Ionizing\",\n    \"Slithering\",\n    \"Architecting\",\n    \"Flummoxing\",\n    \"Pondering\",\n    \"Whirring\",\n    \"Cooking\",\n    \"Lollygagging\",\n    \"Sprouting\",\n    \"Booping\",\n    \"Gallivanting\",\n    \"Proofing\",\n    \"Wrangling\",\n    \"Crystallizing\",\n    \"Metamorphosing\",\n    \"Swirling\",\n    \"Canoodling\",\n    \"Germinating\",\n    \"Razzmatazzing\",\n    \"Discombobulating\",\n    \"Musing\",\n    \"Tinkering\",\n    \"Channeling\",\n    \"Hatching\",\n    \"Scheming\",\n    \"Effecting\",\n    \"Noodling\",\n    \"Undulating\",\n    \"Clauding\",\n    \"Ideating\",\n    \"Shenaniganing\",\n    \"Fermenting\",\n    \"Perambulating\",\n    \"Waddling\",\n    \"Composing\",\n    \"Infusing\",\n    \"Sketching\",\n    \"Actualizing\",\n    \"Flowing\",\n    \"Photosynthesizing\",\n    \"Whatchamacalliting\",\n    \"Contemplating\",\n    \"Levitating\",\n    \"Spinning\",\n    \"Boogieing\",\n    \"Frolicking\",\n    \"Processing\",\n    \"Working\",\n    \"Crunching\",\n    \"Meandering\",\n    \"Sussing\",\n    \"Calculating\",\n    \"Generating\",\n    \"Quantumizing\",\n    \"Determining\",\n    \"Mulling\",\n    \"Synthesizing\",\n    \"Cerebrating\",\n    \"Hashing\",\n    \"Scampering\",\n    \"Drizzling\",\n    \"Nesting\",\n    \"Twisting\",\n    \"Churning\",\n    \"Honking\",\n    \"Seasoning\",\n    \"Envisioning\",\n    \"Osmosing\",\n    \"Vibing\",\n    \"Combobulating\",\n    \"Inferring\",\n    \"Skedaddling\",\n    \"Actioning\",\n    \"Flibbertigibbeting\",\n    \"Philosophising\",\n    \"Warping\",\n    \"Considering\",\n    \"Kneading\",\n    \"Spelunking\",\n    \"Beaming\",\n    \"Forming\",\n    \"Precipitating\",\n    \"Wibbling\",\n    \"Creating\",\n    \"Marinating\",\n    \"Sublimating\",\n    \"Brewing\",\n    \"Garnishing\",\n    \"Puzzling\",\n    \"Deliberating\",\n    \"Moseying\",\n    \"Symbioting\",\n    \"Catapulting\",\n    \"Harmonizing\",\n    \"Ruminating\",\n    \"Doodling\",\n    \"Nebulizing\",\n    \"Transmuting\",\n    \"Choreographing\",\n    \"Hibernating\",\n    \"Scurrying\",\n    \"Enchanting\",\n    \"Orbiting\",\n    \"Unravelling\",\n    \"Cogitating\",\n    \"Incubating\",\n    \"Simmering\"\n  ]\n}\n","/**\n * Status spinner with shimmering verb text\n * Emulates Claude CLI's animated status line during processing\n */\n\nimport { fg, RESET, moveTo, eraseLine } from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\nimport verbsData from \"./verbs.json\" with { type: \"json\" };\n\n// =============================================================================\n// Constants\n// =============================================================================\n\n/** Spinner rotation characters (ping-pong: expands then contracts) */\nexport const SPINNER_CHARS = [\"·\", \"✢\", \"✳\", \"✻\", \"✽\", \"✻\", \"✳\", \"✢\"] as const;\n\n/** Default shimmer colors */\nexport const SHIMMER_BASE_COLOR = \"#d77757\";\nexport const SHIMMER_HIGHLIGHT_COLOR = \"#eb9f7f\";\n\n/** Default frame interval in milliseconds */\nexport const DEFAULT_FRAME_INTERVAL_MS = 200;\n\n/** Default shimmer window size (characters) */\nexport const DEFAULT_SHIMMER_WINDOW_SIZE = 3;\n\n/** Pre-loaded verbs for status spinner */\nexport const VERBS: string[] = verbsData.verbs;\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface SpinnerConfig {\n  /** Theme for fallback colors */\n  theme: RenderTheme;\n  /** Frame interval in milliseconds */\n  frameIntervalMs: number;\n  /** Shimmer highlight window size in characters */\n  shimmerWindowSize: number;\n  /** Base color for verb text */\n  baseColor: string;\n  /** Highlight color for shimmer window */\n  highlightColor: string;\n}\n\nexport interface SpinnerSegment {\n  /** ANSI escape codes + spinner + verb */\n  text: string;\n  /** Absolute timestamp in seconds */\n  time: number;\n}\n\nexport const DEFAULT_SPINNER_CONFIG: Omit<SpinnerConfig, \"theme\"> = {\n  frameIntervalMs: DEFAULT_FRAME_INTERVAL_MS,\n  shimmerWindowSize: DEFAULT_SHIMMER_WINDOW_SIZE,\n  baseColor: SHIMMER_BASE_COLOR,\n  highlightColor: SHIMMER_HIGHLIGHT_COLOR,\n};\n\n/**\n * Spinner display mode\n * - OFF: No spinner displayed\n * - INLINE: Spinner renders in content flow, scrolls away naturally\n * - FIXED: Spinner at fixed row outside scroll region, stays visible until cleared\n */\nexport enum SpinnerMode {\n  OFF = \"off\",\n  INLINE = \"inline\",\n  FIXED = \"fixed\",\n}\n\n/**\n * Spinner state for clean lifecycle management\n * Replaces scattered boolean flags with explicit state machine\n */\nexport interface SpinnerState {\n  /** Current display mode */\n  mode: SpinnerMode;\n  /** Current verb being displayed (null when OFF) */\n  verb: string | null;\n  /** Fixed row position (only used in FIXED mode) */\n  row: number | null;\n}\n\n/** Create initial spinner state (off) */\nexport function createSpinnerState(): SpinnerState {\n  return {\n    mode: SpinnerMode.OFF,\n    verb: null,\n    row: null,\n  };\n}\n\n// =============================================================================\n// Verb Selection\n// =============================================================================\n\n/**\n * Select a pseudo-random verb from the list\n * Uses Knuth multiplicative hash for better distribution while staying deterministic\n */\nexport function selectVerb(verbs: string[], seed: number): string {\n  if (verbs.length === 0) {\n    return \"Processing\";\n  }\n  // Knuth multiplicative hash for pseudo-random distribution\n  // Add 1 to avoid seed=0 always giving index 0\n  const hash = Math.abs(((seed + 1) * 2654435761) | 0);\n  const index = hash % verbs.length;\n  return verbs[index];\n}\n\n// =============================================================================\n// Shimmer Effect\n// =============================================================================\n\n/**\n * Calculate shimmer window position for a given frame\n * Window slides from left to right across the text\n */\nexport function getShimmerWindow(\n  frameIndex: number,\n  textLength: number,\n  windowSize: number\n): [start: number, end: number] {\n  // The window position cycles through the text\n  // We extend past the text length so the window fully exits\n  const totalPositions = textLength + windowSize;\n  const position = frameIndex % totalPositions;\n\n  const start = Math.max(0, position - windowSize + 1);\n  const end = Math.min(textLength, position + 1);\n\n  return [start, end];\n}\n\n/**\n * Apply shimmer effect to text at a given frame\n * Returns text with character-level ANSI coloring\n */\nexport function applyShimmer(\n  text: string,\n  frameIndex: number,\n  config: Pick<SpinnerConfig, \"shimmerWindowSize\" | \"baseColor\" | \"highlightColor\">\n): string {\n  const [windowStart, windowEnd] = getShimmerWindow(\n    frameIndex,\n    text.length,\n    config.shimmerWindowSize\n  );\n\n  let result = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    const isHighlighted = i >= windowStart && i < windowEnd;\n    const color = isHighlighted ? config.highlightColor : config.baseColor;\n    result += fg(color) + char;\n  }\n\n  return result + RESET;\n}\n\n// =============================================================================\n// Spinner Animation Generation\n// =============================================================================\n\n/**\n * Generate a single spinner frame\n * Combines spinner character with shimmered verb text\n */\nexport function renderSpinnerFrame(\n  verb: string,\n  frameIndex: number,\n  config: SpinnerConfig\n): string {\n  const spinnerChar = SPINNER_CHARS[frameIndex % SPINNER_CHARS.length];\n  const shimmeredVerb = applyShimmer(verb + \"…\", frameIndex, config);\n\n  // Spinner char in base color, space, then shimmered verb\n  return fg(config.baseColor) + spinnerChar + RESET + \" \" + shimmeredVerb;\n}\n\n/**\n * Generate status spinner animation segments\n * Creates timed segments for the thinking pause period\n *\n * @param verb - The action verb to display (e.g., \"Clauding\", \"Pondering\")\n * @param startTime - Start time in seconds\n * @param duration - Total duration in seconds\n * @param config - Spinner configuration\n * @param row - Optional row for fixed positioning (1-indexed)\n * @returns Array of timed segments for the animation\n */\nexport function generateStatusSpinnerSegments(\n  verb: string,\n  startTime: number,\n  duration: number,\n  config: SpinnerConfig,\n  row?: number\n): SpinnerSegment[] {\n  const segments: SpinnerSegment[] = [];\n  const frameIntervalSec = config.frameIntervalMs / 1000;\n  const totalFrames = Math.max(1, Math.floor(duration / frameIntervalSec));\n\n  for (let i = 0; i < totalFrames; i++) {\n    const time = startTime + i * frameIntervalSec;\n    const frameContent = renderSpinnerFrame(verb, i, config);\n\n    // Build the frame output with optional positioning\n    let text = \"\";\n    if (row !== undefined) {\n      // Fixed position mode: move to row, erase line, render frame\n      text = moveTo(row, 1) + eraseLine() + frameContent;\n    } else {\n      // Inline mode: just erase current line and render\n      // Use carriage return to go to start of line\n      text = \"\\r\" + eraseLine() + frameContent;\n    }\n\n    segments.push({ text, time });\n  }\n\n  return segments;\n}\n\n/**\n * Generate the clear sequence to remove spinner before content\n */\nexport function generateSpinnerClear(row?: number): string {\n  if (row !== undefined) {\n    return moveTo(row, 1) + eraseLine();\n  }\n  return \"\\r\" + eraseLine();\n}\n\n","/**\n * Session to asciicast conversion\n * Main orchestration for generating .cast files from parsed sessions\n */\n\nimport type { TranscriptEntry } from \"../types/messages.js\";\nimport type { AsciicastDocument } from \"../types/asciicast.js\";\nimport { AsciicastBuilder, type BuilderConfig } from \"./builder.js\";\nimport {\n  TimingCalculator,\n  resolveTimingConfig,\n  type TimingOptions,\n} from \"./timing.js\";\nimport {\n  shouldHaveMarker,\n  generateMarkerLabel,\n  type MarkerOptions,\n  DEFAULT_MARKER_OPTIONS,\n} from \"./markers.js\";\nimport {\n  renderMessage,\n  extractTextContent,\n  type RenderConfig,\n  DEFAULT_RENDER_CONFIG,\n} from \"../renderer/messages.js\";\nimport { toAsciicastTheme, type RenderTheme } from \"../renderer/theme.js\";\nimport {\n  generateInputAnimation,\n  generateInputAreaSetup,\n  redrawInputFrame,\n  getInputAreaRows,\n  DEFAULT_BURST_TYPING_CONFIG,\n  type InputUIConfig,\n  type BurstTypingConfig,\n} from \"../renderer/input.js\";\nimport { moveTo } from \"../renderer/ansi.js\";\nimport { isRenderableMessage } from \"../types/messages.js\";\nimport { isTodoWriteToolResult } from \"../renderer/todos.js\";\nimport { isBashInputMessage, parseBashInput, renderBashInput } from \"../renderer/commands.js\";\nimport {\n  generateStatusSpinnerSegments,\n  generateSpinnerClear,\n  selectVerb,\n  VERBS,\n  DEFAULT_SPINNER_CONFIG,\n  SpinnerMode,\n  createSpinnerState,\n  type SpinnerConfig,\n  type SpinnerState,\n} from \"../renderer/spinner.js\";\n\n// =============================================================================\n// Conversion Configuration\n// =============================================================================\n\nexport interface ConvertOptions {\n  /** Builder configuration (terminal size, title, etc.) */\n  builder?: Partial<BuilderConfig>;\n  /** Timing configuration */\n  timing?: Partial<TimingOptions>;\n  /** Marker configuration */\n  markers?: Partial<MarkerOptions>;\n  /** Render configuration */\n  render?: Partial<RenderConfig>;\n  /** Enable input animation for user prompts (Claude Code style UI) */\n  inputAnimation?: boolean;\n  /** Input animation timing config */\n  inputAnimationConfig?: Partial<BurstTypingConfig>;\n  /** Enable status spinner animation during thinking pauses */\n  statusSpinner?: boolean;\n  /** Duration of status spinner animation in seconds (default: 3.0) */\n  spinnerDuration?: number;\n}\n\nexport interface ConvertResult {\n  /** The generated asciicast document */\n  document: AsciicastDocument;\n  /** Statistics about the conversion */\n  stats: ConvertStats;\n}\n\nexport interface ConvertStats {\n  /** Total entries processed */\n  entriesProcessed: number;\n  /** Entries that were rendered */\n  entriesRendered: number;\n  /** Total events generated */\n  eventsGenerated: number;\n  /** Markers generated */\n  markersGenerated: number;\n  /** Total playback duration (seconds) */\n  duration: number;\n}\n\n// =============================================================================\n// Main Conversion Function\n// =============================================================================\n\n/** Convert parsed session entries to asciicast document */\nexport function convertToAsciicast(\n  entries: TranscriptEntry[],\n  options: ConvertOptions = {}\n): ConvertResult {\n  const renderConfig = { ...DEFAULT_RENDER_CONFIG, ...options.render };\n  const markerOptions = { ...DEFAULT_MARKER_OPTIONS, ...options.markers };\n  const timingConfig = resolveTimingConfig(options.timing ?? {});\n  const inputAnimation = options.inputAnimation ?? false;\n  const burstConfig: BurstTypingConfig = {\n    ...DEFAULT_BURST_TYPING_CONFIG,\n    ...options.inputAnimationConfig,\n  };\n\n  // Build asciicast theme from render theme\n  const asciicastTheme = toAsciicastTheme(renderConfig.theme);\n\n  // Create builder with theme\n  const builder = new AsciicastBuilder({\n    ...options.builder,\n    theme: asciicastTheme,\n  });\n\n  // Get terminal dimensions for input animation\n  const termRows = options.builder?.rows ?? 40;\n  const termCols = options.builder?.cols ?? 100;\n\n  // Create timing calculator\n  const timing = new TimingCalculator(timingConfig);\n\n  // Stats tracking\n  let entriesRendered = 0;\n  let markersGenerated = 0;\n\n  // Input UI configuration (used for animation and cursor positioning)\n  const inputConfig: InputUIConfig = {\n    theme: renderConfig.theme,\n    width: termCols,\n    height: termRows,\n    textColumn: 2,\n  };\n  // Set up fixed input area at start (if input animation enabled)\n  if (inputAnimation) {\n    builder.output(generateInputAreaSetup(inputConfig));\n  }\n\n  // Status spinner configuration\n  const statusSpinner = options.statusSpinner ?? false;\n  let currentActiveForm: string | null = null;\n\n  // Seed messageIndex from first entry's timestamp for varied verb selection per session\n  // This ensures different sessions get different verb sequences while remaining deterministic\n  const firstTimestamp = entries[0] && \"timestamp\" in entries[0]\n    ? new Date(entries[0].timestamp as string).getTime()\n    : Date.now();\n  let messageIndex = Math.abs(firstTimestamp | 0) % 1000; // Start at varied offset (0-999)\n\n  // Verb rotation timing - prevents rapid switching during consecutive tool calls\n  // Note: Use 2.0s since default timing preset compresses gaps to max 3s\n  const MIN_VERB_INTERVAL = 2.0; // Minimum seconds between verb changes\n  let lastVerbChangeTime = 0;\n  let lastVerb: string | null = null; // Track last verb separately (spinner.verb gets cleared)\n\n  // Spinner state machine - replaces scattered boolean flags\n  const spinner: SpinnerState = createSpinnerState();\n\n  const spinnerConfig: SpinnerConfig = {\n    ...DEFAULT_SPINNER_CONFIG,\n    theme: renderConfig.theme,\n  };\n\n  // Spinner row: use spinnerRow from InputAreaRows (outside scroll region) when input animation enabled\n  // Layout for height=40: rows 1-36 (scroll), row 37 (spinner), rows 38-40 (input frame)\n  const rows = getInputAreaRows(termRows);\n  const spinnerRow = inputAnimation ? rows.spinnerRow : undefined;\n\n  // Helper to start spinner (shows initial frame, marks as active)\n  // Clears any existing spinner first, then starts a new one\n  const startSpinner = (verb: string) => {\n    // Clear existing spinner if active (handles user prompt transitions)\n    if (spinner.mode !== SpinnerMode.OFF) {\n      builder.output(generateSpinnerClear(spinner.row ?? undefined));\n    }\n    // Generate just the first frame to establish the spinner\n    const segments = generateStatusSpinnerSegments(\n      verb,\n      builder.time,\n      0.2, // Single frame\n      spinnerConfig,\n      spinnerRow\n    );\n    const firstSegment = segments[0];\n    if (firstSegment) {\n      builder.output(firstSegment.text);\n    }\n    // Update spinner state\n    spinner.verb = verb;\n    spinner.row = spinnerRow ?? null;\n    spinner.mode = spinnerRow !== undefined ? SpinnerMode.FIXED : SpinnerMode.INLINE;\n  };\n\n  // Helper to continue spinner animation for a duration (fills time gap with animation)\n  const continueSpinner = (duration: number) => {\n    if (spinner.mode === SpinnerMode.OFF || !spinner.verb) return;\n    if (duration <= 0) return;\n\n    const segments = generateStatusSpinnerSegments(\n      spinner.verb,\n      builder.time,\n      duration,\n      spinnerConfig,\n      spinner.row ?? undefined\n    );\n    for (const segment of segments) {\n      builder.time = segment.time;\n      builder.output(segment.text);\n    }\n  };\n\n  // Helper to clear spinner and mark inactive\n  // Note: redrawSpinner removed - in FIXED mode, spinner stays at fixed row (no redraw needed)\n  // In INLINE mode, spinner scrolls away naturally (no redraw possible)\n  const clearSpinner = () => {\n    if (spinner.mode === SpinnerMode.OFF) return;\n    builder.output(generateSpinnerClear(spinner.row ?? undefined));\n    if (spinner.row !== null && inputAnimation) {\n      // In fixed row mode, no need to redraw input frame - spinner row is separate\n    } else if (spinner.row === null) {\n      builder.output(\"\\r\\n\"); // Add newline in inline mode\n    }\n    spinner.mode = SpinnerMode.OFF;\n    spinner.verb = null;\n    spinner.row = null;\n  };\n\n  // Helper to get verb with throttling - prevents rapid switching\n  // Returns current verb if MIN_VERB_INTERVAL hasn't elapsed, otherwise selects new verb\n  const getThrottledVerb = (): string => {\n    const elapsed = builder.time - lastVerbChangeTime;\n\n    // Reuse last verb if interval hasn't elapsed and we have one\n    // Note: Use lastVerb instead of spinner.verb since clearSpinner() nulls spinner.verb\n    if (lastVerb !== null && elapsed < MIN_VERB_INTERVAL) {\n      messageIndex++; // Still increment for deterministic seeding\n      return lastVerb;\n    }\n\n    // Select new verb and update timing\n    const verb = currentActiveForm ?? selectVerb(VERBS, messageIndex);\n    messageIndex++;\n    lastVerbChangeTime = builder.time;\n    lastVerb = verb;\n    return verb;\n  };\n\n  // Note: We no longer start a spinner at the beginning of the recording.\n  // Spinners only appear AFTER user prompts are rendered, not before.\n  // This keeps the initial frame clean and matches expected UX flow.\n\n  // Process each entry\n  for (const entry of entries) {\n    // Skip non-renderable entries\n    if (!isRenderableMessage(entry)) {\n      continue;\n    }\n\n    // Track activeForm from TodoWrite tool results for spinner verb\n    if (statusSpinner && entry.type === \"user\" && \"toolUseResult\" in entry && entry.toolUseResult) {\n      if (isTodoWriteToolResult(entry.toolUseResult)) {\n        const inProgressTodo = entry.toolUseResult.newTodos.find(\n          (t) => t.status === \"in_progress\"\n        );\n        currentActiveForm = inProgressTodo?.activeForm ?? null;\n      }\n    }\n\n    // Check if this is a bash output message (stdout/stderr only - NOT bash-input)\n    // bash-input should go through normal input animation, bash-output should not\n    const isBashOutput = entry.type === \"user\" &&\n      typeof entry.message?.content === \"string\" &&\n      (entry.message.content.includes(\"<bash-stdout>\") ||\n       entry.message.content.includes(\"<bash-stderr>\"));\n\n    // Check if this is a \"[Request interrupted by user]\" message\n    // Must NOT be a tool result to distinguish from tool output containing this text\n    // Handle both string and array content formats\n    const isInterruptMessage = entry.type === \"user\" &&\n      !(\"toolUseResult\" in entry && entry.toolUseResult) &&\n      (\n        // String content\n        (typeof entry.message?.content === \"string\" &&\n          entry.message.content.includes(\"[Request interrupted by user]\")) ||\n        // Array content\n        (Array.isArray(entry.message?.content) &&\n          entry.message.content.some((item) =>\n            item.type === \"text\" && item.text?.includes(\"[Request interrupted by user]\")\n          ))\n      );\n\n    // Check if this is a system message with level \"info\" (like /status command output)\n    const isSystemInfoMessage = entry.type === \"system\" &&\n      \"level\" in entry && entry.level === \"info\";\n\n    // Check if this is a meta message (system info like /status command output)\n    const isMetaMessage = entry.type === \"user\" && \"isMeta\" in entry && entry.isMeta;\n\n    // Check if this is a user prompt (not tool result, not meta, not bash output, not interrupt)\n    const isUserPrompt =\n      entry.type === \"user\" &&\n      !(\"toolUseResult\" in entry && entry.toolUseResult) &&\n      !isMetaMessage &&\n      !isBashOutput &&\n      !isInterruptMessage;\n    const useInputAnimation = inputAnimation && isUserPrompt;\n\n    // Check if this is an assistant message with text content (final response, not just tool calls)\n    // We should clear the spinner when the assistant produces actual text output\n    const isAssistantWithText = entry.type === \"assistant\" &&\n      entry.message.content.some((item) => item.type === \"text\" && item.text.trim() !== \"\");\n\n    // Check if this is a tool call (assistant message with tool_use)\n    const isToolCall = entry.type === \"assistant\" &&\n      entry.message.content.some((item) => item.type === \"tool_use\");\n\n    // Check if this is a simple tool call (no inline content like TodoWrite)\n    // Simple tool calls get tight spacing with their results\n    const isSimpleToolCall = isToolCall && entry.type === \"assistant\" &&\n      !entry.message.content.some((item) =>\n        item.type === \"tool_use\" && item.name === \"TodoWrite\"\n      );\n\n    // Check if this is a tool result (user message with toolUseResult)\n    const isToolResult = entry.type === \"user\" && \"toolUseResult\" in entry && entry.toolUseResult;\n\n    // Check if this is agentic content (thinking, tool calls, tool results)\n    // Spinner should be active during agentic work\n    const isAgenticContent =\n      // Assistant with thinking or tool_use\n      (entry.type === \"assistant\" &&\n        entry.message.content.some((item) =>\n          item.type === \"thinking\" || item.type === \"tool_use\"\n        )) ||\n      // Tool result (user message with toolUseResult)\n      isToolResult;\n\n    // Determine if spinner should clear for this message type\n    // 1. Meta messages (isMeta user messages)\n    // 2. System info messages (level: \"info\")\n    // 3. Interrupt messages (\"[Request interrupted by user]\")\n    // Note: User prompts are NOT in this list - startSpinner() handles the transition\n    const shouldClearSpinner = isMetaMessage || isSystemInfoMessage || isInterruptMessage;\n\n    // Calculate timing for this entry\n    // Skip for input animation (handles its own timing)\n    if (!useInputAnimation) {\n      const previousTime = builder.time;\n      const entryTime = timing.nextEntry(entry);\n\n      // If spinner is active, fill the time gap with animation frames\n      if (statusSpinner && spinner.mode !== SpinnerMode.OFF) {\n        const timeDelta = entryTime - previousTime;\n        if (timeDelta > 0) {\n          continueSpinner(timeDelta);\n        }\n      }\n\n      builder.time = entryTime;\n    } else if (statusSpinner && spinner.mode !== SpinnerMode.OFF) {\n      // Input animation mode: calculate timing gap and fill with spinner animation\n      const previousTime = builder.time;\n      const entryTime = timing.nextEntry(entry);\n      const timeDelta = entryTime - previousTime;\n      if (timeDelta > 0) {\n        continueSpinner(timeDelta);\n      }\n      builder.time = entryTime;\n    }\n\n    // Clear spinner AFTER timing gap is filled (so animation plays first)\n    if (statusSpinner && spinner.mode !== SpinnerMode.OFF && shouldClearSpinner) {\n      clearSpinner();\n    }\n\n    // Handle spinner visibility for assistant text\n    // In FIXED mode: spinner persists (it's outside scroll region, content can't overwrite it)\n    // In INLINE mode: spinner already scrolled away, just mark OFF\n    if (statusSpinner && spinner.mode === SpinnerMode.INLINE && isAssistantWithText) {\n      // Inline mode: spinner already scrolled away, just mark state as OFF\n      spinner.mode = SpinnerMode.OFF;\n      spinner.verb = null;\n      spinner.row = null;\n    }\n\n    // Generate marker if applicable\n    if (shouldHaveMarker(entry, markerOptions.mode)) {\n      const label = generateMarkerLabel(entry, markerOptions.labelLength);\n      if (label) {\n        builder.marker(label);\n        markersGenerated++;\n      }\n    }\n\n    // Check if this is a command message (should use renderMessage, not input animation)\n    // Only user/assistant messages have .message property\n    const entryText = \"message\" in entry ? extractTextContent(entry.message.content) : \"\";\n    const isCommand = entryText.trim().startsWith(\"<command-name>\") ||\n                      entryText.trim().startsWith(\"<local-command-stdout>\");\n\n    if (useInputAnimation && !isCommand) {\n      // Use Claude Code style fixed-position input animation\n      // For bash-input, extract just the command for typing (not the XML tags)\n      const isBashInput = typeof entry.message?.content === \"string\" &&\n        isBashInputMessage(entry.message.content);\n      const text = isBashInput\n        ? `! ${parseBashInput(entry.message.content as string)!}`\n        : entryText;\n      if (!text.trim()) continue;\n\n      const inputConfig: InputUIConfig = {\n        theme: renderConfig.theme,\n        width: termCols,\n        height: termRows,\n        textColumn: 2,\n      };\n\n      const animation = generateInputAnimation(\n        text,\n        builder.time,\n        inputConfig,\n        burstConfig\n      );\n\n      // Output each segment with timing (typing animation in input area)\n      for (const segment of animation.segments) {\n        builder.time = segment.time;\n        builder.output(segment.text);\n      }\n\n      // Output the user prompt to scrolling area\n      // For bash-input messages, render with ! prefix styling instead of default prompt\n      if (isBashInput) {\n        const bashCmd = parseBashInput(entry.message.content as string)!;\n        const bashOutput = renderBashInput(bashCmd, { theme: renderConfig.theme, width: termCols });\n        builder.output(bashOutput.replace(/\\n/g, \"\\r\\n\") + \"\\r\\n\");\n      } else {\n        builder.output(animation.scrollOutput);\n      }\n\n      // Redraw input frame after scroll output (may have been corrupted)\n      builder.output(redrawInputFrame(inputConfig));\n\n      // Sync timing calculator with animation end time\n      timing.time = builder.time;\n\n      // Start spinner after user prompt (just first frame)\n      // Spinner will continue animating as subsequent entries add time gaps\n      if (statusSpinner) {\n        startSpinner(getThrottledVerb());\n      }\n    } else {\n      // Standard rendering\n      const rendered = renderMessage(entry, renderConfig);\n      if (!rendered) continue;\n\n      // Convert \\n to \\r\\n for proper terminal line endings\n      // Use single newline after simple tool calls and bash input so results attach directly\n      const isBashInput = entry.type === \"user\" &&\n        typeof entry.message?.content === \"string\" &&\n        entry.message.content.includes(\"<bash-input>\");\n      const trailing = (isSimpleToolCall || isBashInput || isBashOutput) ? \"\\r\\n\" : \"\\r\\n\\r\\n\";\n      const output = rendered.replace(/\\n/g, \"\\r\\n\") + trailing;\n\n      // When using input animation, position in scroll region first\n      // Use scrollEnd - 1 to avoid boundary issues where content overwrites instead of scrolling\n      if (inputAnimation) {\n        builder.output(moveTo(rows.scrollEnd - 1, 1) + \"\\r\\n\");\n      }\n\n      // Regular output (no typing effect when using input animation)\n      builder.output(output);\n\n      // Redraw input frame after output (may have been corrupted by scroll/wrap)\n      if (inputAnimation) {\n        builder.output(redrawInputFrame(inputConfig));\n      }\n\n      // Spinner handling for standard rendering path\n      if (statusSpinner) {\n        if (isUserPrompt) {\n          // Start spinner after user prompt (just first frame)\n          startSpinner(getThrottledVerb());\n        } else if (isAgenticContent && spinner.mode === SpinnerMode.OFF) {\n          // Start spinner after agentic content if not already active\n          // This handles clips that start mid-conversation with thinking/tool calls\n          startSpinner(getThrottledVerb());\n        }\n        // Note: No redrawSpinner() needed anymore\n        // In FIXED mode: spinner is outside scroll region, stays visible automatically\n        // In INLINE mode: spinner scrolls away naturally with content\n      }\n    }\n\n    entriesRendered++;\n  }\n\n  // Build final document\n  const document = builder.build();\n\n  return {\n    document,\n    stats: {\n      entriesProcessed: entries.length,\n      entriesRendered,\n      eventsGenerated: document.events.length,\n      markersGenerated,\n      duration: builder.time,\n    },\n  };\n}\n\n// =============================================================================\n// Convenience Functions\n// =============================================================================\n\n/** Convert session with common presets */\nexport function convertWithPreset(\n  entries: TranscriptEntry[],\n  preset: \"speedrun\" | \"default\" | \"realtime\",\n  theme?: RenderTheme\n): ConvertResult {\n  return convertToAsciicast(entries, {\n    timing: { preset },\n    render: theme ? { theme } : undefined,\n  });\n}\n\n/** Quick conversion with defaults (default preset, all markers) */\nexport function quickConvert(entries: TranscriptEntry[]): AsciicastDocument {\n  return convertToAsciicast(entries).document;\n}\n\n// =============================================================================\n// Session Info Extraction\n// =============================================================================\n\nexport interface SessionInfo {\n  /** First message timestamp */\n  startTime: Date | null;\n  /** Last message timestamp */\n  endTime: Date | null;\n  /** Number of user messages (excluding tool results) */\n  userMessages: number;\n  /** Number of assistant messages */\n  assistantMessages: number;\n  /** Number of tool calls */\n  toolCalls: number;\n  /** Whether session contains agent/sidechain messages */\n  hasAgents: boolean;\n}\n\n/** Extract session info for title/description generation */\nexport function getSessionInfo(entries: TranscriptEntry[]): SessionInfo {\n  let startTime: Date | null = null;\n  let endTime: Date | null = null;\n  let userMessages = 0;\n  let assistantMessages = 0;\n  let toolCalls = 0;\n  let hasAgents = false;\n\n  for (const entry of entries) {\n    // Track timestamps\n    if (\"timestamp\" in entry && typeof entry.timestamp === \"string\") {\n      const timestamp = new Date(entry.timestamp);\n      if (!startTime || timestamp < startTime) startTime = timestamp;\n      if (!endTime || timestamp > endTime) endTime = timestamp;\n    }\n\n    // Track sidechain\n    if (\"isSidechain\" in entry && entry.isSidechain) {\n      hasAgents = true;\n    }\n\n    // Count message types\n    if (entry.type === \"user\") {\n      if (!entry.toolUseResult) {\n        userMessages++;\n      }\n    } else if (entry.type === \"assistant\") {\n      assistantMessages++;\n      // Count tool calls\n      for (const item of entry.message.content) {\n        if (item.type === \"tool_use\") {\n          toolCalls++;\n        }\n      }\n    }\n  }\n\n  return {\n    startTime,\n    endTime,\n    userMessages,\n    assistantMessages,\n    toolCalls,\n    hasAgents,\n  };\n}\n\n/** Generate a title from session info */\nexport function generateTitle(info: SessionInfo): string {\n  const parts: string[] = [\"Claude Code Session\"];\n\n  if (info.toolCalls > 0) {\n    parts.push(`(${info.toolCalls} tool calls)`);\n  }\n\n  return parts.join(\" \");\n}\n","/**\n * asciinema upload integration\n */\n\nimport { spawn } from \"node:child_process\";\n\nexport interface UploadResult {\n  success: boolean;\n  url?: string;\n  error?: string;\n}\n\n/** Upload a .cast file to asciinema.org */\nexport async function uploadToAsciinema(filePath: string): Promise<UploadResult> {\n  return new Promise((resolve) => {\n    const proc = spawn(\"asciinema\", [\"upload\", filePath], {\n      stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    });\n\n    let stdout = \"\";\n    let stderr = \"\";\n\n    proc.stdout.on(\"data\", (data: Buffer) => {\n      stdout += data.toString();\n    });\n\n    proc.stderr.on(\"data\", (data: Buffer) => {\n      stderr += data.toString();\n    });\n\n    proc.on(\"error\", (error) => {\n      if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n        resolve({\n          success: false,\n          error: \"asciinema CLI not found. Install: https://docs.asciinema.org/manual/cli/installation/\",\n        });\n      } else {\n        resolve({\n          success: false,\n          error: error.message,\n        });\n      }\n    });\n\n    proc.on(\"close\", (code) => {\n      if (code === 0) {\n        // Extract URL from output\n        const url = extractUrl(stdout) || extractUrl(stderr);\n        if (url) {\n          resolve({ success: true, url });\n        } else {\n          resolve({\n            success: true,\n            url: stdout.trim() || \"Upload successful (URL not found in output)\",\n          });\n        }\n      } else {\n        // Check for auth errors\n        const output = stdout + stderr;\n        if (output.includes(\"auth\") || output.includes(\"token\") || output.includes(\"API\")) {\n          resolve({\n            success: false,\n            error: \"Authentication required. Run 'asciinema auth' first.\",\n          });\n        } else {\n          resolve({\n            success: false,\n            error: stderr.trim() || stdout.trim() || `Exit code: ${code}`,\n          });\n        }\n      }\n    });\n  });\n}\n\n/** Check if asciinema CLI is available */\nexport async function checkAsciinema(): Promise<boolean> {\n  return new Promise((resolve) => {\n    const proc = spawn(\"asciinema\", [\"--version\"], {\n      stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    });\n\n    proc.on(\"error\", () => {\n      resolve(false);\n    });\n\n    proc.on(\"close\", (code) => {\n      resolve(code === 0);\n    });\n  });\n}\n\n/** Extract URL from asciinema output */\nfunction extractUrl(text: string): string | null {\n  // Match asciinema.org URLs\n  const match = text.match(/https?:\\/\\/asciinema\\.org\\/a\\/[a-zA-Z0-9]+/);\n  return match ? match[0] : null;\n}\n","/**\n * Session discovery - find Claude Code sessions for current project\n */\n\nimport { readdir, stat } from \"node:fs/promises\";\nimport { join } from \"node:path\";\nimport { homedir } from \"node:os\";\n\n/** Get Claude projects directory path from a working directory */\nexport function getClaudeProjectPath(cwd: string): string {\n  const mangled = cwd.replace(/\\//g, \"-\");\n  return join(homedir(), \".claude/projects\", mangled);\n}\n\nexport interface SessionInfo {\n  path: string;\n  name: string;\n  modified: Date;\n  size: number;\n}\n\n/** List session files in a Claude project directory */\nexport async function listSessions(projectPath: string): Promise<SessionInfo[]> {\n  const sessions: SessionInfo[] = [];\n\n  try {\n    const files = await readdir(projectPath);\n\n    for (const file of files) {\n      if (!file.endsWith(\".jsonl\")) continue;\n      if (file.startsWith(\"agent-\")) continue;\n\n      const filePath = join(projectPath, file);\n      const stats = await stat(filePath);\n\n      sessions.push({\n        path: filePath,\n        name: file.replace(\".jsonl\", \"\"),\n        modified: stats.mtime,\n        size: stats.size,\n      });\n    }\n  } catch {\n    // Directory doesn't exist\n  }\n\n  return sessions.sort((a, b) => b.modified.getTime() - a.modified.getTime());\n}\n\n/** Get the most recent session file */\nexport async function getLatestSession(cwd: string): Promise<string | null> {\n  const projectPath = getClaudeProjectPath(cwd);\n  const sessions = await listSessions(projectPath);\n  return sessions[0]?.path ?? null;\n}\n\n/** Format file size */\nexport function formatSize(bytes: number): string {\n  if (bytes < 1024) return `${bytes}B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;\n}\n\n// =============================================================================\n// Profile System\n// =============================================================================\n\nconst PROFILE_FILENAME = \"cc-prism.profile\";\n\nexport interface ProfileConfig {\n  output?: string;\n  upload?: boolean;\n  theme?: string;\n  cols?: number;\n  rows?: number;\n  title?: string;\n  preset?: string;\n  max_wait?: number | null;\n  thinking_pause?: number | null;\n  typing_effect?: boolean;\n  status_spinner?: boolean;\n  spinner_duration?: number;\n  markers?: string;\n}\n\n/**\n * Load profile from current directory.\n * Returns null if profile doesn't exist or is invalid.\n */\nexport async function loadProfile(cwd: string = process.cwd()): Promise<ProfileConfig | null> {\n  const profilePath = join(cwd, PROFILE_FILENAME);\n\n  try {\n    const { readFile } = await import(\"node:fs/promises\");\n    const content = await readFile(profilePath, \"utf-8\");\n    const config = JSON.parse(content) as ProfileConfig;\n    return config;\n  } catch {\n    // File doesn't exist or invalid JSON\n    return null;\n  }\n}\n\n/**\n * Save profile to current directory.\n * Throws on write failure.\n */\nexport async function saveProfile(\n  config: ProfileConfig,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const profilePath = join(cwd, PROFILE_FILENAME);\n  const { writeFile } = await import(\"node:fs/promises\");\n  const content = JSON.stringify(config, null, 2);\n  await writeFile(profilePath, content, \"utf-8\");\n}\n\n/**\n * Check if profile exists in current directory.\n */\nexport async function profileExists(cwd: string = process.cwd()): Promise<boolean> {\n  const profilePath = join(cwd, PROFILE_FILENAME);\n\n  try {\n    const { access } = await import(\"node:fs/promises\");\n    await access(profilePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","/**\n * Interactive form for cast generation options\n * Provides a TUI for configuring all cast options before generation\n */\n\nimport React, { useState, useMemo, useEffect } from \"react\";\nimport { render, Box, Text, useApp, useInput, useStdout } from \"ink\";\nimport { loadProfile, saveProfile, type ProfileConfig } from \"./sessions.js\";\n\n// Types\nexport interface CastFormConfig {\n  output: string;\n  upload: boolean;\n  theme: string;\n  cols: number;\n  rows: number;\n  title: string;\n  preset: string;\n  maxWait: number | null;\n  thinkingPause: number | null;\n  typingEffect: boolean;\n  statusSpinner: boolean;\n  spinnerDuration: number;\n  markers: string;\n}\n\ninterface InteractiveFormProps {\n  sessionPath: string;\n  defaultOutput: string;\n  defaultTitle: string;\n  onSubmit: (config: CastFormConfig) => void;\n  onCancel: () => void;\n}\n\n// Constants\nconst THEMES = [\"tokyo-night\", \"dracula\", \"nord\", \"catppuccin-mocha\"] as const;\nconst PRESETS = [\"speedrun\", \"default\", \"realtime\"] as const;\nconst MARKERS = [\"all\", \"user\", \"tools\", \"none\"] as const;\n\n// Field definitions for navigation\ntype SectionName = \"output\" | \"appearance\" | \"timing\" | \"features\";\ntype FieldName =\n  | `section:${SectionName}`\n  | \"output\" | \"upload\" | \"theme\" | \"cols\" | \"rows\" | \"title\"\n  | \"preset\" | \"maxWait\" | \"thinkingPause\" | \"typingEffect\"\n  | \"statusSpinner\" | \"spinnerDuration\" | \"markers\"\n  | \"generate\" | \"saveProfile\" | \"cancel\";\n\n// Section to fields mapping\nconst SECTION_FIELDS: Record<SectionName, FieldName[]> = {\n  output: [\"output\", \"upload\"],\n  appearance: [\"theme\", \"cols\", \"rows\", \"title\"],\n  timing: [\"preset\", \"maxWait\", \"thinkingPause\"],\n  features: [\"typingEffect\", \"statusSpinner\", \"spinnerDuration\", \"markers\"],\n};\n\n// Build dynamic field order based on expanded sections\nfunction getVisibleFields(expanded: Set<SectionName>): FieldName[] {\n  const fields: FieldName[] = [];\n  for (const section of [\"output\", \"appearance\", \"timing\", \"features\"] as SectionName[]) {\n    fields.push(`section:${section}`);\n    if (expanded.has(section)) {\n      fields.push(...SECTION_FIELDS[section]);\n    }\n  }\n  fields.push(\"generate\", \"saveProfile\", \"cancel\");\n  return fields;\n}\n\n// Default values\nfunction getDefaultConfig(defaultOutput: string): CastFormConfig {\n  return {\n    output: defaultOutput,\n    upload: false,\n    theme: \"tokyo-night\",\n    cols: 100,\n    rows: 40,\n    title: \"\",  // Empty = show placeholder, CLI uses defaultTitle if empty\n    preset: \"default\",\n    maxWait: null,\n    thinkingPause: null,\n    typingEffect: true,\n    statusSpinner: false,\n    spinnerDuration: 3.0,\n    markers: \"all\",\n  };\n}\n\n// Validation\ninterface ValidationErrors {\n  cols?: string;\n  rows?: string;\n  spinnerDuration?: string;\n  maxWait?: string;\n  thinkingPause?: string;\n}\n\nfunction validateConfig(config: CastFormConfig): ValidationErrors {\n  const errors: ValidationErrors = {};\n\n  if (config.cols <= 0 || config.cols > 500) {\n    errors.cols = \"Must be 1-500\";\n  }\n  if (config.rows <= 0 || config.rows > 200) {\n    errors.rows = \"Must be 1-200\";\n  }\n  if (config.spinnerDuration <= 0 || config.spinnerDuration > 60) {\n    errors.spinnerDuration = \"Must be 0.1-60\";\n  }\n  if (config.maxWait !== null && config.maxWait < 0) {\n    errors.maxWait = \"Must be >= 0\";\n  }\n  if (config.thinkingPause !== null && config.thinkingPause < 0) {\n    errors.thinkingPause = \"Must be >= 0\";\n  }\n\n  return errors;\n}\n\n// Profile conversion helpers\nfunction formToProfile(config: CastFormConfig): ProfileConfig {\n  return {\n    output: config.output,\n    upload: config.upload,\n    theme: config.theme,\n    cols: config.cols,\n    rows: config.rows,\n    title: config.title,\n    preset: config.preset,\n    max_wait: config.maxWait,\n    thinking_pause: config.thinkingPause,\n    typing_effect: config.typingEffect,\n    status_spinner: config.statusSpinner,\n    spinner_duration: config.spinnerDuration,\n    markers: config.markers,\n  };\n}\n\nfunction profileToForm(profile: ProfileConfig, defaults: CastFormConfig): CastFormConfig {\n  return {\n    output: profile.output ?? defaults.output,\n    upload: profile.upload ?? defaults.upload,\n    theme: profile.theme ?? defaults.theme,\n    cols: profile.cols ?? defaults.cols,\n    rows: profile.rows ?? defaults.rows,\n    title: profile.title ?? defaults.title,\n    preset: profile.preset ?? defaults.preset,\n    maxWait: profile.max_wait !== undefined ? profile.max_wait : defaults.maxWait,\n    thinkingPause: profile.thinking_pause !== undefined ? profile.thinking_pause : defaults.thinkingPause,\n    typingEffect: profile.typing_effect ?? defaults.typingEffect,\n    statusSpinner: profile.status_spinner ?? defaults.statusSpinner,\n    spinnerDuration: profile.spinner_duration ?? defaults.spinnerDuration,\n    markers: profile.markers ?? defaults.markers,\n  };\n}\n\n// Main form component\nfunction InteractiveForm({ sessionPath, defaultOutput, defaultTitle, onSubmit, onCancel }: InteractiveFormProps) {\n  const { exit } = useApp();\n  const { stdout } = useStdout();\n\n  // Form state\n  const [config, setConfig] = useState<CastFormConfig>(() => getDefaultConfig(defaultOutput));\n  const [focusedField, setFocusedField] = useState<FieldName>(\"section:output\");\n  const [editMode, setEditMode] = useState(false);\n  const [editBuffer, setEditBuffer] = useState(\"\");\n  const [statusMessage, setStatusMessage] = useState<string | null>(null);\n  const [profileLoaded, setProfileLoaded] = useState(false);\n  const [expandedSections, setExpandedSections] = useState<Set<SectionName>>(() => new Set([\"output\", \"appearance\"]));\n\n  // Load profile on mount\n  useEffect(() => {\n    loadProfile().then((profile) => {\n      if (profile) {\n        const defaults = getDefaultConfig(defaultOutput);\n        setConfig(profileToForm(profile, defaults));\n        setProfileLoaded(true);\n        setStatusMessage(\"Loaded: cc-prism.profile\");\n        setTimeout(() => setStatusMessage(null), 2000);\n      }\n    });\n  }, [defaultOutput]);\n\n  // Validation\n  const errors = useMemo(() => validateConfig(config), [config]);\n  const hasErrors = Object.keys(errors).length > 0;\n\n  // Navigation helpers\n  const visibleFields = useMemo(() => getVisibleFields(expandedSections), [expandedSections]);\n  const focusIndex = visibleFields.indexOf(focusedField);\n\n  const moveFocus = (delta: number) => {\n    const newIndex = Math.max(0, Math.min(visibleFields.length - 1, focusIndex + delta));\n    setFocusedField(visibleFields[newIndex]!);\n  };\n\n  const isSection = (field: FieldName) => field.startsWith(\"section:\");\n  const getSectionName = (field: FieldName): SectionName | null =>\n    isSection(field) ? (field.replace(\"section:\", \"\") as SectionName) : null;\n\n  // Field type helpers\n  const isTextField = (field: FieldName) =>\n    [\"output\", \"title\"].includes(field);\n  const isNumberField = (field: FieldName) =>\n    [\"cols\", \"rows\", \"maxWait\", \"thinkingPause\", \"spinnerDuration\"].includes(field);\n  const isSelectField = (field: FieldName) =>\n    [\"theme\", \"preset\", \"markers\"].includes(field);\n  const isCheckbox = (field: FieldName) =>\n    [\"upload\", \"typingEffect\", \"statusSpinner\"].includes(field);\n  const isButton = (field: FieldName) =>\n    [\"generate\", \"saveProfile\", \"cancel\"].includes(field);\n\n  // Get select options for a field\n  const getSelectOptions = (field: FieldName): readonly string[] => {\n    if (field === \"theme\") return THEMES;\n    if (field === \"preset\") return PRESETS;\n    if (field === \"markers\") return MARKERS;\n    return [];\n  };\n\n  // Input handling\n  useInput((input, key) => {\n    // Cancel on Ctrl+C\n    if (key.ctrl && input === \"c\") {\n      onCancel();\n      exit();\n      return;\n    }\n\n    // Edit mode handling for text/number fields\n    if (editMode) {\n      if (key.escape) {\n        setEditMode(false);\n        setEditBuffer(\"\");\n        return;\n      }\n\n      if (key.return) {\n        // Apply edit buffer to config\n        if (isTextField(focusedField)) {\n          setConfig(c => ({ ...c, [focusedField]: editBuffer }));\n        } else if (isNumberField(focusedField)) {\n          const num = parseFloat(editBuffer);\n          if (editBuffer === \"\" && [\"maxWait\", \"thinkingPause\"].includes(focusedField)) {\n            setConfig(c => ({ ...c, [focusedField]: null }));\n          } else if (!isNaN(num)) {\n            setConfig(c => ({ ...c, [focusedField]: num }));\n          }\n        }\n        setEditMode(false);\n        setEditBuffer(\"\");\n        return;\n      }\n\n      if (key.backspace || key.delete) {\n        setEditBuffer(b => b.slice(0, -1));\n        return;\n      }\n\n      // Regular character input\n      if (input && !key.ctrl && !key.meta && input.length === 1) {\n        setEditBuffer(b => b + input);\n        return;\n      }\n      return;\n    }\n\n    // Navigation mode\n    if (key.downArrow || input === \"j\") {\n      moveFocus(1);\n      return;\n    }\n    if (key.upArrow || input === \"k\") {\n      moveFocus(-1);\n      return;\n    }\n    if (key.tab && !key.shift) {\n      moveFocus(1);\n      return;\n    }\n    if (key.tab && key.shift) {\n      moveFocus(-1);\n      return;\n    }\n\n    // Jump to start/end\n    if (input === \"g\") {\n      setFocusedField(visibleFields[0]!);\n      return;\n    }\n    if (input === \"G\") {\n      setFocusedField(visibleFields[visibleFields.length - 1]!);\n      return;\n    }\n\n    // Field-specific actions\n    if (key.return || input === \" \") {\n      // Section headers: toggle expand/collapse\n      const sectionName = getSectionName(focusedField);\n      if (sectionName) {\n        setExpandedSections(s => {\n          const next = new Set(s);\n          if (next.has(sectionName)) next.delete(sectionName);\n          else next.add(sectionName);\n          return next;\n        });\n        return;\n      }\n\n      // Checkboxes: toggle\n      if (isCheckbox(focusedField)) {\n        setConfig(c => ({ ...c, [focusedField]: !c[focusedField as keyof CastFormConfig] }));\n        return;\n      }\n\n      // Select fields: cycle options\n      if (isSelectField(focusedField)) {\n        const options = getSelectOptions(focusedField);\n        const current = config[focusedField as keyof CastFormConfig] as string;\n        const idx = options.indexOf(current);\n        const next = options[(idx + 1) % options.length];\n        setConfig(c => ({ ...c, [focusedField]: next }));\n        return;\n      }\n\n      // Text/number fields: enter edit mode\n      if (isTextField(focusedField) || isNumberField(focusedField)) {\n        const currentValue = config[focusedField as keyof CastFormConfig];\n        setEditBuffer(currentValue === null ? \"\" : String(currentValue));\n        setEditMode(true);\n        return;\n      }\n\n      // Buttons\n      if (focusedField === \"generate\") {\n        if (hasErrors) {\n          setStatusMessage(\"Fix validation errors first\");\n          setTimeout(() => setStatusMessage(null), 2000);\n          return;\n        }\n        onSubmit(config);\n        exit();\n        return;\n      }\n\n      if (focusedField === \"saveProfile\") {\n        saveProfile(formToProfile(config))\n          .then(() => {\n            setStatusMessage(\"Profile saved: cc-prism.profile\");\n            setTimeout(() => setStatusMessage(null), 2000);\n          })\n          .catch((err) => {\n            setStatusMessage(`Save failed: ${err.message}`);\n            setTimeout(() => setStatusMessage(null), 3000);\n          });\n        return;\n      }\n\n      if (focusedField === \"cancel\") {\n        onCancel();\n        exit();\n        return;\n      }\n    }\n\n    // Select fields: h/l to cycle\n    if (isSelectField(focusedField) && (input === \"h\" || input === \"l\")) {\n      const options = getSelectOptions(focusedField);\n      const current = config[focusedField as keyof CastFormConfig] as string;\n      const idx = options.indexOf(current);\n      const delta = input === \"l\" ? 1 : -1;\n      const next = options[(idx + delta + options.length) % options.length];\n      setConfig(c => ({ ...c, [focusedField]: next }));\n      return;\n    }\n  });\n\n  // Render helpers\n  const renderTextField = (field: FieldName, label: string, width = 40, placeholder?: string) => {\n    const value = config[field as keyof CastFormConfig] as string;\n    const isFocused = focusedField === field;\n    const isEditing = isFocused && editMode;\n    const displayValue = isEditing ? editBuffer : value;\n    const showPlaceholder = !displayValue && placeholder && !isEditing;\n    const content = (showPlaceholder ? placeholder : displayValue).padEnd(width - 2).slice(0, width - 2);\n\n    return (\n      <Box>\n        <Text color={isFocused ? \"cyan\" : undefined}>{isFocused ? \"▸ \" : \"  \"}</Text>\n        <Text>{label}: </Text>\n        <Text backgroundColor={isEditing ? \"blue\" : isFocused ? \"gray\" : undefined}>[</Text>\n        <Text\n          backgroundColor={isEditing ? \"blue\" : isFocused ? \"gray\" : undefined}\n          color={isEditing ? \"white\" : showPlaceholder ? \"gray\" : undefined}\n        >\n          {content}\n        </Text>\n        <Text backgroundColor={isEditing ? \"blue\" : isFocused ? \"gray\" : undefined}>]</Text>\n        {isEditing && <Text color=\"gray\">█</Text>}\n      </Box>\n    );\n  };\n\n  const renderNumberField = (field: FieldName, label: string, defaultVal?: number, width = 8, labelWidth = 12) => {\n    const value = config[field as keyof CastFormConfig];\n    const isFocused = focusedField === field;\n    const isEditing = isFocused && editMode;\n    const displayValue = isEditing ? editBuffer : (value === null ? \"\" : String(value));\n    const error = errors[field as keyof ValidationErrors];\n    const hint = defaultVal !== undefined ? `(default: ${defaultVal})` : \"\";\n\n    return (\n      <Box>\n        <Text color={isFocused ? \"cyan\" : undefined}>{isFocused ? \"▸ \" : \"  \"}</Text>\n        <Text>{label.padEnd(labelWidth)}: </Text>\n        <Text\n          backgroundColor={isEditing ? \"blue\" : isFocused ? \"gray\" : undefined}\n          color={isEditing ? \"white\" : undefined}\n        >\n          [{displayValue.padEnd(width - 2).slice(0, width - 2)}]\n        </Text>\n        {isEditing && <Text color=\"gray\">█</Text>}\n        {hint && <Text dimColor> {hint}</Text>}\n        {error && <Text color=\"red\"> {error}</Text>}\n      </Box>\n    );\n  };\n\n  const renderSelectField = (field: FieldName, label: string, labelWidth = 0) => {\n    const value = config[field as keyof CastFormConfig] as string;\n    const options = getSelectOptions(field);\n    const isFocused = focusedField === field;\n    const displayLabel = labelWidth > 0 ? label.padEnd(labelWidth) : label;\n\n    return (\n      <Box>\n        <Text color={isFocused ? \"cyan\" : undefined}>{isFocused ? \"▸ \" : \"  \"}</Text>\n        <Text>{displayLabel}: </Text>\n        <Text backgroundColor={isFocused ? \"gray\" : undefined}>\n          [{value}]\n        </Text>\n        {isFocused && <Text dimColor> (h/l or Space to cycle)</Text>}\n      </Box>\n    );\n  };\n\n  const renderCheckbox = (field: FieldName, label: string) => {\n    const value = config[field as keyof CastFormConfig] as boolean;\n    const isFocused = focusedField === field;\n\n    return (\n      <Box>\n        <Text color={isFocused ? \"cyan\" : undefined}>{isFocused ? \"▸ \" : \"  \"}</Text>\n        <Text>({value ? \"●\" : \" \"}) {label}</Text>\n      </Box>\n    );\n  };\n\n  const renderSectionHeader = (section: SectionName, label: string) => {\n    const isFocused = focusedField === `section:${section}`;\n    const isExpanded = expandedSections.has(section);\n\n    return (\n      <Box>\n        <Text color={isFocused ? \"cyan\" : undefined}>{isFocused ? \"▸ \" : \"  \"}</Text>\n        <Text bold={isExpanded} color={isFocused ? \"yellow\" : isExpanded ? \"yellow\" : \"gray\"}>\n          {label}\n        </Text>\n        {isFocused && <Text color=\"gray\">  {isExpanded ? \"collapse\" : \"expand\"}</Text>}\n      </Box>\n    );\n  };\n\n  const renderButton = (field: FieldName, label: string, color?: string) => {\n    const isFocused = focusedField === field;\n\n    return (\n      <Box marginRight={2}>\n        <Text\n          backgroundColor={isFocused ? (color || \"cyan\") : undefined}\n          color={isFocused ? \"black\" : (color || \"cyan\")}\n          bold={isFocused}\n        >\n          [{label}]\n        </Text>\n      </Box>\n    );\n  };\n\n  return (\n    <Box flexDirection=\"column\" paddingX={1}>\n      {/* Header */}\n      <Box marginBottom={1}>\n        <Text bold color=\"cyan\">Cast Options</Text>\n        <Text dimColor> - {sessionPath.split(\"/\").pop()}</Text>\n      </Box>\n\n      {/* Output Section */}\n      <Box flexDirection=\"column\">\n        {renderSectionHeader(\"output\", \"Output\")}\n        {expandedSections.has(\"output\") && (\n          <Box flexDirection=\"column\" marginLeft={2}>\n            {renderTextField(\"output\", \"File\", 45)}\n            {renderCheckbox(\"upload\", \"Upload to asciinema.org\")}\n          </Box>\n        )}\n      </Box>\n\n      {/* Appearance Section */}\n      <Box flexDirection=\"column\">\n        {renderSectionHeader(\"appearance\", \"Appearance\")}\n        {expandedSections.has(\"appearance\") && (\n          <Box flexDirection=\"column\" marginLeft={2}>\n            {renderSelectField(\"theme\", \"Theme\")}\n            {renderNumberField(\"cols\", \"Cols\", 100, 6, 5)}\n            {renderNumberField(\"rows\", \"Rows\", 40, 6, 5)}\n            {renderTextField(\"title\", \"Title\", 45, defaultTitle)}\n          </Box>\n        )}\n      </Box>\n\n      {/* Timing Section */}\n      <Box flexDirection=\"column\">\n        {renderSectionHeader(\"timing\", \"Timing\")}\n        {expandedSections.has(\"timing\") && (\n          <Box flexDirection=\"column\" marginLeft={2}>\n            {renderSelectField(\"preset\", \"Preset\")}\n            {renderNumberField(\"maxWait\", \"Max wait\", 3, 8, 12)}\n            {renderNumberField(\"thinkingPause\", \"Think pause\", 0.8, 8, 12)}\n          </Box>\n        )}\n      </Box>\n\n      {/* Features Section */}\n      <Box flexDirection=\"column\">\n        {renderSectionHeader(\"features\", \"Features\")}\n        {expandedSections.has(\"features\") && (\n          <Box flexDirection=\"column\" marginLeft={2}>\n            {renderCheckbox(\"typingEffect\", \"Typing effect\")}\n            {renderCheckbox(\"statusSpinner\", \"Status spinner\")}\n            {renderNumberField(\"spinnerDuration\", \"Duration\", 3.0, 6, 8)}\n            {renderSelectField(\"markers\", \"Markers\", 8)}\n          </Box>\n        )}\n      </Box>\n\n      {/* Action Buttons */}\n      <Box marginTop={1} borderStyle=\"single\" borderColor=\"gray\" paddingX={1}>\n        <Box>\n          {renderButton(\"generate\", \"Generate\", hasErrors ? \"gray\" : \"green\")}\n          {renderButton(\"saveProfile\", \"Save Profile\", \"blue\")}\n          {renderButton(\"cancel\", \"Cancel\", \"red\")}\n        </Box>\n      </Box>\n\n      {/* Status */}\n      {statusMessage && (\n        <Box marginTop={1}>\n          <Text color=\"yellow\">{statusMessage}</Text>\n        </Box>\n      )}\n    </Box>\n  );\n}\n\n// Export runner function\nexport async function runInteractiveForm(\n  sessionPath: string,\n  defaultOutput: string,\n  defaultTitle: string\n): Promise<CastFormConfig | null> {\n  return new Promise((resolve) => {\n    const { unmount, waitUntilExit } = render(\n      <InteractiveForm\n        sessionPath={sessionPath}\n        defaultOutput={defaultOutput}\n        defaultTitle={defaultTitle}\n        onSubmit={(config) => resolve(config)}\n        onCancel={() => resolve(null)}\n      />\n    );\n\n    waitUntilExit().then(() => {\n      unmount();\n    });\n  });\n}\n","/**\n * Interactive message picker TUI using Ink\n */\n\nimport React, { useState, useMemo } from \"react\";\nimport { render, Box, Text, useInput, useApp, useStdout } from \"ink\";\nimport Fuse from \"fuse.js\";\nimport clipboard from \"clipboardy\";\nimport { writeFile } from \"node:fs/promises\";\nimport { resolve } from \"node:path\";\nimport type { TranscriptEntry } from \"../types/messages.js\";\nimport { isRenderableMessage } from \"../types/messages.js\";\nimport { getUuid, getTimestamp } from \"../parser/loader.js\";\nimport { convertToAsciicast } from \"../generator/convert.js\";\nimport { serializeCast } from \"../generator/builder.js\";\nimport { getTheme } from \"../renderer/theme.js\";\n\n// Types\ninterface PickerProps {\n  entries: TranscriptEntry[];\n  sessionPath: string;\n  onExit: (selections: Selection[]) => void;\n  onInteractiveExport?: (result: InteractiveExportResult) => void;\n}\n\ninterface Selection {\n  startUuid: string;\n  endUuid: string;\n  startIdx: number;\n  endIdx: number;\n}\n\n/** Result returned when picker exits with \"Advanced options\" selected */\nexport interface InteractiveExportResult {\n  jsonlPath: string;\n  sessionPath: string;\n}\n\ntype HistoryFilter = \"all\" | \"selected\";\ntype ExportFormat = \"cast\" | \"jsonl\" | \"command\" | \"uuids\";\ntype ExportMode = \"single\" | \"multiple\"; // For multiple ranges: single concatenated vs multiple files\ntype DialogScreen = \"format\" | \"filename\" | \"multimode\" | null;\n\ninterface SearchableEntry {\n  idx: number;\n  uuid: string | null;\n  text: string;\n  type: string;\n}\n\n// Constants - VISIBLE_LINES now calculated dynamically in component\nconst HEADER_FOOTER_LINES = 11; // header + margins + pane headers + borders + indicators + status + help\nconst EXPORT_HEADER_FOOTER_LINES = 9; // header + margin + export header + borders + scroll indicator + status bar\n\n// Helper to extract text content for search and preview\nfunction extractPreviewText(entry: TranscriptEntry): string {\n  if (entry.type === \"user\") {\n    if (entry.toolUseResult) {\n      const isError =\n        typeof entry.toolUseResult === \"string\" || entry.toolUseResult.is_error;\n      return isError ? \"error\" : \"success\";\n    }\n    const content = entry.message.content;\n    if (typeof content === \"string\") {\n      return content;\n    }\n    const textItems = content.filter((c) => c.type === \"text\");\n    return textItems.map((t) => (t.type === \"text\" ? t.text : \"\")).join(\"\\n\");\n  }\n\n  if (entry.type === \"assistant\") {\n    const tools = entry.message.content.filter((c) => c.type === \"tool_use\");\n    if (tools.length > 0) {\n      const toolNames = tools.map((t) => (t.type === \"tool_use\" ? t.name : \"\")).join(\", \");\n      return `[${toolNames}]`;\n    }\n    const text = entry.message.content.find((c) => c.type === \"text\");\n    if (text && text.type === \"text\") {\n      return text.text;\n    }\n  }\n\n  if (entry.type === \"system\" && entry.content) {\n    return entry.content;\n  }\n\n  return \"\";\n}\n\n// Extract full content for preview pane (not truncated)\nfunction extractFullContent(entry: TranscriptEntry): string {\n  if (entry.type === \"user\") {\n    if (entry.toolUseResult) {\n      const result = entry.toolUseResult;\n      if (typeof result === \"string\") {\n        return `Tool Result (error):\\n${result}`;\n      }\n      const status = result.is_error ? \"error\" : \"success\";\n      const content = typeof result.content === \"string\"\n        ? result.content\n        : JSON.stringify(result.content, null, 2);\n      return `Tool Result (${status}):\\n${content}`;\n    }\n    const content = entry.message.content;\n    if (typeof content === \"string\") {\n      return content;\n    }\n    const textItems = content.filter((c) => c.type === \"text\");\n    return textItems.map((t) => (t.type === \"text\" ? t.text : \"\")).join(\"\\n\");\n  }\n\n  if (entry.type === \"assistant\") {\n    const parts: string[] = [];\n    for (const item of entry.message.content) {\n      if (item.type === \"text\") {\n        parts.push(item.text);\n      } else if (item.type === \"tool_use\") {\n        parts.push(`[Tool: ${item.name}]`);\n        if (item.input && typeof item.input === \"object\") {\n          const inputStr = JSON.stringify(item.input, null, 2);\n          if (inputStr.length < 500) {\n            parts.push(inputStr);\n          }\n        }\n      } else if (item.type === \"thinking\") {\n        parts.push(`[Thinking]\\n${item.thinking}`);\n      }\n    }\n    return parts.join(\"\\n\");\n  }\n\n  if (entry.type === \"system\" && entry.content) {\n    return entry.content;\n  }\n\n  return \"\";\n}\n\n// Helper to group selected indices into contiguous ranges\nfunction getSelectionRanges(\n  selected: Set<number>,\n  renderableEntries: TranscriptEntry[]\n): Selection[] {\n  if (selected.size === 0) return [];\n\n  const sortedSelected = Array.from(selected).sort((a, b) => a - b);\n  const ranges: Selection[] = [];\n  let rangeStartIdx = sortedSelected[0]!;\n  let rangeEndIdx = rangeStartIdx;\n\n  for (let i = 1; i <= sortedSelected.length; i++) {\n    const current = sortedSelected[i];\n    if (current === rangeEndIdx + 1) {\n      rangeEndIdx = current;\n    } else {\n      const startEntry = renderableEntries[rangeStartIdx];\n      const endEntry = renderableEntries[rangeEndIdx];\n      if (startEntry && endEntry) {\n        ranges.push({\n          startUuid: getUuid(startEntry) ?? \"\",\n          endUuid: getUuid(endEntry) ?? \"\",\n          startIdx: rangeStartIdx,\n          endIdx: rangeEndIdx,\n        });\n      }\n      if (current !== undefined) {\n        rangeStartIdx = current;\n        rangeEndIdx = current;\n      }\n    }\n  }\n\n  return ranges;\n}\n\n// Generate a single cast command string\nfunction generateCommandString(range: Selection, sessionPath: string): string {\n  return `cc-prism cast \"${sessionPath}\" --start-uuid ${range.startUuid} --end-uuid ${range.endUuid}`;\n}\n\n// Generate UUID pair string\nfunction generateUuidPair(range: Selection): string {\n  return `${range.startUuid} ${range.endUuid}`;\n}\n\n// Generate JSONL content from selected entries\nfunction generateJsonlContent(selectedEntries: TranscriptEntry[]): string {\n  return selectedEntries.map((e) => JSON.stringify(e)).join(\"\\n\");\n}\n\n// Helper to get sorted selected entries from selection set\nfunction getSelectedEntries(\n  selected: Set<number>,\n  renderableEntries: TranscriptEntry[]\n): TranscriptEntry[] {\n  const sortedSelected = Array.from(selected).sort((a, b) => a - b);\n  return sortedSelected\n    .map(idx => renderableEntries[idx])\n    .filter((e): e is TranscriptEntry => e !== undefined);\n}\n\n// Generate suggested filename from selection ranges\nfunction generateSuggestedFilename(ranges: Selection[]): string {\n  if (ranges.length === 0) return \"export\";\n  const first = ranges[0]!;\n  const last = ranges[ranges.length - 1]!;\n  const startUuid = first.startUuid.slice(0, 8);\n  const endUuid = last.endUuid.slice(0, 8);\n  const now = new Date();\n  const timestamp = now.toISOString().replace(/[-:T]/g, \"\").slice(0, 14); // YYYYMMDDHHmmss\n  return `${startUuid}-${endUuid}-${timestamp}`;\n}\n\n// Wrapped line with continuation tracking\ninterface WrappedLine {\n  text: string;\n  isContinuation: boolean;\n}\n\n// Simple word wrap for preview with continuation tracking\nfunction wrapText(text: string, width: number): WrappedLine[] {\n  const lines: WrappedLine[] = [];\n  for (const paragraph of text.split(\"\\n\")) {\n    let isFirst = true;\n    if (paragraph.length <= width) {\n      lines.push({ text: paragraph, isContinuation: false });\n    } else {\n      const words = paragraph.split(/\\s+/);\n      let currentLine = \"\";\n      for (const word of words) {\n        if (currentLine.length + word.length + 1 <= width) {\n          currentLine += (currentLine ? \" \" : \"\") + word;\n        } else {\n          if (currentLine) {\n            lines.push({ text: currentLine, isContinuation: !isFirst });\n            isFirst = false;\n          }\n          // Handle long words\n          if (word.length > width) {\n            for (let i = 0; i < word.length; i += width) {\n              lines.push({ text: word.slice(i, i + width), isContinuation: !isFirst });\n              isFirst = false;\n            }\n            currentLine = \"\";\n          } else {\n            currentLine = word;\n          }\n        }\n      }\n      if (currentLine) {\n        lines.push({ text: currentLine, isContinuation: !isFirst });\n      }\n    }\n  }\n  return lines;\n}\n\n// Format entry for display\n// displayIdx: position in filtered list (for cursor highlighting)\n// originalIdx: position in full list (for selection tracking)\n// visualRangeAddsNew: true if visual range contains unselected items (green), false if all overlap (red)\nfunction formatEntry(\n  entry: TranscriptEntry,\n  displayIdx: number,\n  cursor: number,\n  selected: Set<number>,\n  matchIndices: number[],\n  currentMatchIdx: number,\n  rangeStart: number | null,\n  originalIdx: number,\n  visualRangeAddsNew: boolean\n): { prefix: string; uuid: string; time: string; type: string; preview: string; isCursor: boolean; isSelected: boolean; isVisualPreview: boolean; isMatch: boolean; isCurrentMatch: boolean; visualColor: string | undefined; isToolResult: boolean } {\n  const uuid = getUuid(entry);\n  const timestamp = getTimestamp(entry);\n  const timeStr = timestamp ? timestamp.toISOString().substring(11, 19) : \"        \";\n  const uuidShort = uuid ? uuid.substring(0, 8) : \"        \";\n\n  let typeStr = entry.type;\n  const isToolResult = entry.type === \"user\" && entry.toolUseResult;\n  if (isToolResult) {\n    typeStr = \"tool-res\";\n  }\n\n  const preview = extractPreviewText(entry).substring(0, 50).replace(/\\n/g, \" \");\n  const isCursor = displayIdx === cursor;\n  const isSelected = selected.has(originalIdx); // Use originalIdx for selection\n  const matchIdx = matchIndices.indexOf(originalIdx); // Use originalIdx for match tracking\n  const isMatch = matchIdx !== -1;\n  const isCurrentMatch = isMatch && matchIdx === currentMatchIdx;\n\n  // Visual mode preview (not yet confirmed) - uses displayIdx for range\n  let isVisualPreview = false;\n  if (rangeStart !== null) {\n    const [start, end] = rangeStart <= cursor\n      ? [rangeStart, cursor]\n      : [cursor, rangeStart];\n    isVisualPreview = displayIdx >= start && displayIdx <= end;\n  }\n\n  // Visual range color: green if adding new items, red if all already selected\n  const visualColor = isVisualPreview ? (visualRangeAddsNew ? \"green\" : \"red\") : undefined;\n\n  let prefix = \"  \";\n  if ((isSelected || isVisualPreview) && isCursor) prefix = \"▸●\";\n  else if (isSelected || isVisualPreview) prefix = \" ●\";\n  else if (isCursor) prefix = \"▸ \";\n\n  return { prefix, uuid: uuidShort, time: timeStr, type: typeStr, preview, isCursor, isSelected, isVisualPreview, isMatch, isCurrentMatch, visualColor, isToolResult: !!isToolResult };\n}\n\n// Main Picker Component\nfunction Picker({ entries, sessionPath, onExit, onInteractiveExport }: PickerProps) {\n  const { exit } = useApp();\n  const { stdout } = useStdout();\n\n  // Calculate visible lines based on terminal height\n  const terminalRows = stdout?.rows ?? 24;\n  const VISIBLE_LINES = Math.max(5, terminalRows - HEADER_FOOTER_LINES);\n  const EXPORT_VISIBLE_LINES = Math.max(5, terminalRows - EXPORT_HEADER_FOOTER_LINES);\n\n  // Filter to renderable messages\n  const renderableEntries = useMemo(\n    () => entries.filter(isRenderableMessage),\n    [entries]\n  );\n\n  // State\n  const [cursor, setCursor] = useState(0);\n  const [selected, setSelected] = useState<Set<number>>(new Set());\n  const [rangeStart, setRangeStart] = useState<number | null>(null); // Idle by default, space starts visual\n  const [cherrypickMode, setCherrypickMode] = useState(false);\n  const [searchMode, setSearchMode] = useState(false);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [searchedNoMatches, setSearchedNoMatches] = useState(false);\n  const [matchIndices, setMatchIndices] = useState<number[]>([]);\n  const [currentMatchIdx, setCurrentMatchIdx] = useState(0);\n  const [scrollOffset, setScrollOffset] = useState(0);\n  const [statusMessage, setStatusMessage] = useState<string | null>(null);\n  const [selectionHistory, setSelectionHistory] = useState<Set<number>[]>([]);\n  const [redoHistory, setRedoHistory] = useState<Set<number>[]>([]);\n  const [focusedPane, setFocusedPane] = useState<\"history\" | \"preview\">(\"history\");\n  const [previewScrollOffset, setPreviewScrollOffset] = useState(0);\n  const [historyFilter, setHistoryFilter] = useState<HistoryFilter>(\"all\");\n  const [filterSnapshot, setFilterSnapshot] = useState<Set<number>>(new Set());\n  const [exportPreviewMode, setExportPreviewMode] = useState(false);\n  const [exportContent, setExportContent] = useState(\"\");\n  const [exportContentLines, setExportContentLines] = useState<WrappedLine[]>([]);\n  const [exportScrollOffset, setExportScrollOffset] = useState(0);\n  const [exportCursor, setExportCursor] = useState(0); // Cursor position in content (absolute line index)\n\n  // Export dialog state\n  const [dialogScreen, setDialogScreen] = useState<DialogScreen>(null);\n  const [exportMode, setExportMode] = useState<ExportMode>(\"single\"); // For multiple ranges\n  const [dialogCursor, setDialogCursor] = useState(0);\n  const [filenameInput, setFilenameInput] = useState(\"\");\n  const [multiExportCast, setMultiExportCast] = useState(true);\n  const [multiExportJsonl, setMultiExportJsonl] = useState(false);\n\n  // Build search index\n  const fuse = useMemo(() => {\n    const searchable: SearchableEntry[] = renderableEntries.map((entry, idx) => ({\n      idx,\n      uuid: getUuid(entry),\n      text: extractFullContent(entry),\n      type: entry.type,\n    }));\n    return new Fuse(searchable, {\n      keys: [\"text\"],\n      threshold: 0.3,\n      includeMatches: true,\n    });\n  }, [renderableEntries]);\n\n  // Handle search\n  const performSearch = (query: string) => {\n    if (!query) {\n      setMatchIndices([]);\n      setCurrentMatchIdx(0);\n      return;\n    }\n    const results = fuse.search(query);\n    let indices = results.map((r) => r.item.idx);\n    // When in Selected filter mode, only include matches within filterSnapshot\n    if (historyFilter === \"selected\") {\n      indices = indices.filter((idx) => filterSnapshot.has(idx));\n    }\n    setMatchIndices(indices);\n    setCurrentMatchIdx(0);\n    if (indices.length > 0 && indices[0] !== undefined) {\n      setCursor(indices[0]);\n      updateScrollForCursor(indices[0]);\n    }\n  };\n\n  // Keep cursor in view\n  const updateScrollForCursor = (newCursor: number) => {\n    if (newCursor < scrollOffset) {\n      setScrollOffset(newCursor);\n    } else if (newCursor >= scrollOffset + VISIBLE_LINES) {\n      setScrollOffset(newCursor - VISIBLE_LINES + 1);\n    }\n  };\n\n  // Generate human-readable export content for preview and clipboard\n  const generateExportContent = (): string => {\n    if (selected.size === 0) return \"No messages selected\";\n\n    const sortedSelected = Array.from(selected).sort((a, b) => a - b);\n    const parts: string[] = [];\n\n    for (const idx of sortedSelected) {\n      const entry = renderableEntries[idx];\n      if (!entry) continue;\n\n      // Add header separator\n      const uuid = getUuid(entry);\n      const timestamp = getTimestamp(entry);\n      const timeStr = timestamp ? timestamp.toISOString().substring(11, 19) : \"unknown\";\n      const uuidShort = uuid ? uuid.substring(0, 8) : \"unknown\";\n\n      let typeStr = entry.type;\n      if (entry.type === \"user\" && entry.toolUseResult) {\n        typeStr = \"tool-result\";\n      }\n\n      parts.push(`[${typeStr} ${timeStr} ${uuidShort}]`);\n\n      // Add content\n      const content = extractFullContent(entry);\n      parts.push(content);\n      parts.push(\" \"); // blank line before next message (space so Ink renders it)\n    }\n\n    return parts.join(\"\\n\").trimEnd();\n  };\n\n  // Helper function for executing export actions\n  const executeExport = async (format: ExportFormat, filename?: string): Promise<void> => {\n    const ranges = getSelectionRanges(selected, renderableEntries);\n    if (ranges.length === 0) return;\n\n    try {\n      switch (format) {\n        case \"command\": {\n          const commands = ranges.map(r => generateCommandString(r, sessionPath)).join(\"\\n\");\n          try {\n            await clipboard.write(commands);\n            setStatusMessage(`${ranges.length} command${ranges.length > 1 ? \"s\" : \"\"} copied`);\n          } catch {\n            setStatusMessage(\"Clipboard unavailable\");\n          }\n          break;\n        }\n        case \"uuids\": {\n          const uuids = ranges.map(r => generateUuidPair(r)).join(\"\\n\");\n          try {\n            await clipboard.write(uuids);\n            setStatusMessage(`${ranges.length} UUID pair${ranges.length > 1 ? \"s\" : \"\"} copied`);\n          } catch {\n            setStatusMessage(\"Clipboard unavailable\");\n          }\n          break;\n        }\n        case \"jsonl\": {\n          if (filename) {\n            const selectedEntries = getSelectedEntries(selected, renderableEntries);\n            const content = generateJsonlContent(selectedEntries);\n            const fullPath = resolve(process.cwd(), filename.endsWith(\".jsonl\") ? filename : `${filename}.jsonl`);\n            await writeFile(fullPath, content, \"utf-8\");\n            setStatusMessage(`Written: ${fullPath}`);\n          }\n          break;\n        }\n        case \"cast\": {\n          if (filename) {\n            const selectedEntries = getSelectedEntries(selected, renderableEntries);\n            const theme = getTheme(\"tokyo-night\");\n            const result = convertToAsciicast(selectedEntries, {\n              builder: { cols: 100, rows: 40 },\n              timing: { preset: \"default\" },\n              markers: { mode: \"all\" },\n              render: { theme, width: 100 },\n            });\n            const content = serializeCast(result.document);\n            const fullPath = resolve(process.cwd(), filename.endsWith(\".cast\") ? filename : `${filename}.cast`);\n            await writeFile(fullPath, content, \"utf-8\");\n            setStatusMessage(`Written: ${fullPath}`);\n          }\n          break;\n        }\n      }\n    } catch (err) {\n      setStatusMessage(`Error: ${err instanceof Error ? err.message : \"Unknown error\"}`);\n    }\n\n    setTimeout(() => setStatusMessage(null), 3000);\n    setDialogScreen(null);\n    setFilenameInput(\"\");\n    setDialogCursor(0);\n  };\n\n  // Helper function for exporting both .cast and .jsonl formats\n  const executeBothExports = async (filename: string): Promise<void> => {\n    const selectedEntries = getSelectedEntries(selected, renderableEntries);\n\n    // Strip any extension user might have added\n    const baseName = filename.replace(/\\.(cast|jsonl)$/, \"\");\n\n    try {\n      // Export .cast\n      const theme = getTheme(\"tokyo-night\");\n      const result = convertToAsciicast(selectedEntries, {\n        builder: { cols: 100, rows: 40 },\n        timing: { preset: \"default\" },\n        markers: { mode: \"all\" },\n        render: { theme, width: 100 },\n      });\n      const castContent = serializeCast(result.document);\n      const castPath = resolve(process.cwd(), `${baseName}.cast`);\n      await writeFile(castPath, castContent, \"utf-8\");\n\n      // Export .jsonl\n      const jsonlContent = generateJsonlContent(selectedEntries);\n      const jsonlPath = resolve(process.cwd(), `${baseName}.jsonl`);\n      await writeFile(jsonlPath, jsonlContent, \"utf-8\");\n\n      setStatusMessage(`Written: ${baseName}.cast and .jsonl`);\n    } catch (err) {\n      setStatusMessage(`Error: ${err instanceof Error ? err.message : \"Unknown error\"}`);\n    }\n\n    setTimeout(() => setStatusMessage(null), 3000);\n    setDialogScreen(null);\n    setFilenameInput(\"\");\n    setDialogCursor(0);\n  };\n\n  // Helper function for exporting JSONL and launching interactive cast mode\n  const executeAdvancedExport = async (): Promise<void> => {\n    const selectedEntries = getSelectedEntries(selected, renderableEntries);\n    const ranges = getSelectionRanges(selected, renderableEntries);\n    const suggestedName = generateSuggestedFilename(ranges);\n\n    try {\n      // Export .jsonl only\n      const jsonlContent = generateJsonlContent(selectedEntries);\n      const jsonlPath = resolve(process.cwd(), `${suggestedName}.jsonl`);\n      await writeFile(jsonlPath, jsonlContent, \"utf-8\");\n\n      setStatusMessage(`Exported: ${suggestedName}.jsonl`);\n\n      // Short delay to show the message before exiting\n      setTimeout(() => {\n        if (onInteractiveExport) {\n          onInteractiveExport({ jsonlPath, sessionPath });\n        }\n        onExit([]);\n        exit();\n      }, 500);\n    } catch (err) {\n      setStatusMessage(`Error: ${err instanceof Error ? err.message : \"Unknown error\"}`);\n      setTimeout(() => setStatusMessage(null), 3000);\n    }\n  };\n\n  // Input handling\n  useInput((input, key) => {\n    // Dialog input handling (highest priority)\n    if (dialogScreen !== null) {\n      // Escape: close dialog and return to export preview\n      if (key.escape) {\n        setDialogScreen(null);\n        setFilenameInput(\"\");\n        setDialogCursor(0);\n        return;\n      }\n\n      // Filename input screen\n      if (dialogScreen === \"filename\") {\n        if (key.return) {\n          // Confirm filename - use input or auto-fill with suggested name\n          const ranges = getSelectionRanges(selected, renderableEntries);\n          const filename = filenameInput.trim() || generateSuggestedFilename(ranges);\n\n          // Use format flags (same pattern for single and multi-range)\n          if (multiExportCast && multiExportJsonl) {\n            executeBothExports(filename);\n          } else if (multiExportCast) {\n            executeExport(\"cast\", filename);\n          } else {\n            executeExport(\"jsonl\", filename);\n          }\n          return;\n        }\n        if (key.backspace || key.delete) {\n          setFilenameInput(s => s.slice(0, -1));\n          return;\n        }\n        // Regular character input\n        if (input && !key.ctrl && !key.meta && input.length === 1) {\n          setFilenameInput(s => s + input);\n          return;\n        }\n        return;\n      }\n\n      // Format selection screen (single range)\n      if (dialogScreen === \"format\") {\n        const formatOptions = 3; // .cast, .jsonl, Both\n        const showAdvanced = multiExportCast; // Show \"Advanced options\" when .cast is selected\n        const actionCount = showAdvanced ? 3 : 2; // Confirm, [Advanced options], Cancel\n\n        if (key.upArrow || input === \"k\") {\n          setDialogCursor(c => Math.max(0, c - 1));\n          return;\n        }\n        if (key.downArrow || input === \"j\") {\n          setDialogCursor(c => Math.min(formatOptions + actionCount - 1, c + 1));\n          return;\n        }\n\n        // Select format option (first 3 options)\n        if (dialogCursor < formatOptions) {\n          if (key.return || input === \" \") {\n            if (dialogCursor === 0) {\n              // .cast only\n              setMultiExportCast(true);\n              setMultiExportJsonl(false);\n            } else if (dialogCursor === 1) {\n              // .jsonl only\n              setMultiExportCast(false);\n              setMultiExportJsonl(true);\n            } else {\n              // Both\n              setMultiExportCast(true);\n              setMultiExportJsonl(true);\n            }\n            return;\n          }\n        }\n\n        // Action buttons\n        if (dialogCursor === formatOptions) {\n          // Confirm button\n          if (key.return) {\n            setDialogScreen(\"filename\");\n            setDialogCursor(0);\n            return;\n          }\n        }\n\n        if (showAdvanced && dialogCursor === formatOptions + 1) {\n          // Advanced options button\n          if (key.return) {\n            executeAdvancedExport();\n            return;\n          }\n        }\n\n        const cancelIdx = showAdvanced ? formatOptions + 2 : formatOptions + 1;\n        if (dialogCursor === cancelIdx) {\n          // Cancel button\n          if (key.return) {\n            setDialogScreen(null);\n            setDialogCursor(0);\n            return;\n          }\n        }\n\n        // 'y' key: copy command to clipboard\n        if (input === \"y\") {\n          if (statusMessage) return; // Debounce: skip if feedback already showing\n          const ranges = getSelectionRanges(selected, renderableEntries);\n          if (ranges.length > 0) {\n            const commands = ranges.map(r => generateCommandString(r, sessionPath)).join(\"\\n\");\n            setStatusMessage(\"Command copied\");\n            setTimeout(() => setStatusMessage(null), 2000);\n            clipboard.write(commands).catch(() => {\n              setStatusMessage(\"Clipboard unavailable\");\n              setTimeout(() => setStatusMessage(null), 2000);\n            });\n          }\n          return;\n        }\n\n        return;\n      }\n\n      // Multiple ranges mode selection screen\n      if (dialogScreen === \"multimode\") {\n        const ranges = getSelectionRanges(selected, renderableEntries);\n        const modeOptions = 2; // Single concatenated, Multiple ranges\n        const formatOptions = 3; // .jsonl, .cast, both\n        const showAdvanced = multiExportCast; // Show \"Advanced options\" when .cast is selected\n        // Action count: Confirm + [Advanced options] + [Copy commands] + Cancel\n        let actionCount = 2; // Confirm, Cancel\n        if (showAdvanced) actionCount++;\n        if (exportMode === \"multiple\") actionCount++;\n\n        if (key.upArrow || input === \"k\") {\n          setDialogCursor(c => Math.max(0, c - 1));\n          return;\n        }\n        if (key.downArrow || input === \"j\") {\n          setDialogCursor(c => Math.min(modeOptions + formatOptions + actionCount - 1, c + 1));\n          return;\n        }\n\n        // Mode selection (first 2 options)\n        if (dialogCursor < modeOptions) {\n          if (key.return || input === \" \") {\n            setExportMode(dialogCursor === 0 ? \"single\" : \"multiple\");\n            return;\n          }\n        }\n\n        // Format selection (next 3 options)\n        if (dialogCursor >= modeOptions && dialogCursor < modeOptions + formatOptions) {\n          if (key.return || input === \" \") {\n            const formatIdx = dialogCursor - modeOptions;\n            if (formatIdx === 0) {\n              // .jsonl only\n              setMultiExportJsonl(true);\n              setMultiExportCast(false);\n            } else if (formatIdx === 1) {\n              // .cast only\n              setMultiExportJsonl(false);\n              setMultiExportCast(true);\n            } else {\n              // both\n              setMultiExportJsonl(true);\n              setMultiExportCast(true);\n            }\n            return;\n          }\n        }\n\n        // Action buttons\n        const actionStart = modeOptions + formatOptions;\n        let currentAction = actionStart;\n\n        if (dialogCursor === currentAction) {\n          // Confirm button\n          if (key.return) {\n            // For now, proceed to filename input\n            setDialogScreen(\"filename\");\n            setDialogCursor(0);\n            return;\n          }\n        }\n        currentAction++;\n\n        if (showAdvanced && dialogCursor === currentAction) {\n          // Advanced options button\n          if (key.return) {\n            executeAdvancedExport();\n            return;\n          }\n        }\n        if (showAdvanced) currentAction++;\n\n        if (exportMode === \"multiple\" && dialogCursor === currentAction) {\n          // Copy commands button (only in multiple mode)\n          if (key.return) {\n            const commands = ranges.map(r => generateCommandString(r, sessionPath)).join(\"\\n\");\n            setStatusMessage(`${ranges.length} commands copied`);\n            clipboard.write(commands).catch(() => {\n              setStatusMessage(\"Clipboard unavailable\");\n              setTimeout(() => setStatusMessage(null), 2000);\n            });\n            setTimeout(() => setStatusMessage(null), 2000);\n            setDialogScreen(null);\n            setDialogCursor(0);\n            return;\n          }\n        }\n        if (exportMode === \"multiple\") currentAction++;\n\n        if (dialogCursor === currentAction) {\n          // Cancel button\n          if (key.return) {\n            setDialogScreen(null);\n            setDialogCursor(0);\n            return;\n          }\n        }\n        return;\n      }\n\n      return;\n    }\n\n    // Search results mode: block mode-changing keys, only allow n/N/Esc\n    if (!searchMode && searchQuery) {\n      // n: next match\n      if (input === \"n\" && matchIndices.length > 0) {\n        // Find next match after current cursor position\n        const nextMatch = matchIndices.find(idx => idx > cursor);\n        const nextIdx = nextMatch !== undefined\n          ? matchIndices.indexOf(nextMatch)\n          : 0; // Wrap to first match\n        setCurrentMatchIdx(nextIdx);\n        const newCursor = matchIndices[nextIdx];\n        if (newCursor !== undefined) {\n          setCursor(newCursor);\n          updateScrollForCursor(newCursor);\n          setPreviewScrollOffset(0);\n        }\n        return;\n      }\n\n      // N: previous match\n      if (input === \"N\" && matchIndices.length > 0) {\n        // Find previous match before current cursor position\n        const prevMatches = matchIndices.filter(idx => idx < cursor);\n        const prevMatch = prevMatches.length > 0 ? prevMatches[prevMatches.length - 1] : undefined;\n        const prevIdx = prevMatch !== undefined\n          ? matchIndices.indexOf(prevMatch)\n          : matchIndices.length - 1; // Wrap to last match\n        setCurrentMatchIdx(prevIdx);\n        const newCursor = matchIndices[prevIdx];\n        if (newCursor !== undefined) {\n          setCursor(newCursor);\n          updateScrollForCursor(newCursor);\n          setPreviewScrollOffset(0);\n        }\n        return;\n      }\n\n      // j/k: manual navigation in search results\n      if (key.downArrow || input === \"j\") {\n        const maxCursor = filteredEntries.length - 1;\n        const newCursor = Math.min(maxCursor, cursor + 1);\n        setCursor(newCursor);\n        updateScrollForCursor(newCursor);\n        setPreviewScrollOffset(0);\n        return;\n      }\n      if (key.upArrow || input === \"k\") {\n        const newCursor = Math.max(0, cursor - 1);\n        setCursor(newCursor);\n        updateScrollForCursor(newCursor);\n        setPreviewScrollOffset(0);\n        return;\n      }\n\n      // Esc or /: back to search input mode\n      if (key.escape || input === \"/\") {\n        setSearchMode(true);\n        return;\n      }\n\n      // Block all other keys in search results mode\n      return;\n    }\n\n    // Shift+Tab: reverse cycle Preview → Selected → All\n    if (key.tab && key.shift) {\n      if (focusedPane === \"preview\") {\n        // Preview → Selected\n        setFocusedPane(\"history\");\n        setHistoryFilter(\"selected\");\n        setFilterSnapshot(new Set(selected));\n        setScrollOffset(0);\n        setCursor(0);\n      } else if (historyFilter === \"selected\") {\n        // Selected → All\n        setHistoryFilter(\"all\");\n        setFilterSnapshot(new Set());\n        setScrollOffset(0);\n      } else {\n        // All → Preview\n        setFocusedPane(\"preview\");\n      }\n      return;\n    }\n\n    // Tab: cycle through All → Selected → Preview tabs\n    if (key.tab) {\n      if (focusedPane === \"preview\") {\n        // Preview → All\n        setFocusedPane(\"history\");\n        setHistoryFilter(\"all\");\n        setFilterSnapshot(new Set());\n        setScrollOffset(0);\n      } else if (historyFilter === \"all\") {\n        // All → Selected\n        setHistoryFilter(\"selected\");\n        setFilterSnapshot(new Set(selected));\n        setScrollOffset(0);\n        setCursor(0);\n      } else {\n        // Selected → Preview\n        setFocusedPane(\"preview\");\n      }\n      return;\n    }\n\n    // Number keys: pane focus (1=left, 2=right)\n    if (input === \"1\") {\n      setFocusedPane(\"history\");\n      return;\n    }\n    if (input === \"2\") {\n      setFocusedPane(\"preview\");\n      return;\n    }\n\n    // Export preview mode input handling\n    if (exportPreviewMode) {\n      // Escape: exit export preview\n      if (key.escape) {\n        setExportPreviewMode(false);\n        return;\n      }\n\n      // j/k: move cursor with scroll-into-view\n      if (key.downArrow || input === \"j\") {\n        const maxCursor = exportContentLines.length - 1;\n        const newCursor = Math.min(maxCursor, exportCursor + 1);\n        setExportCursor(newCursor);\n        // Scroll if cursor goes below visible area\n        if (newCursor >= exportScrollOffset + EXPORT_VISIBLE_LINES) {\n          setExportScrollOffset(newCursor - EXPORT_VISIBLE_LINES + 1);\n        }\n        return;\n      }\n\n      if (key.upArrow || input === \"k\") {\n        const newCursor = Math.max(0, exportCursor - 1);\n        setExportCursor(newCursor);\n        // Scroll if cursor goes above visible area\n        if (newCursor < exportScrollOffset) {\n          setExportScrollOffset(newCursor);\n        }\n        return;\n      }\n\n      // Page navigation - scroll and cursor move together, maintaining relative position\n      const pageJump = Math.max(1, EXPORT_VISIBLE_LINES - 3);\n      if (key.pageDown || (key.ctrl && input === \"d\")) {\n        const maxCursor = exportContentLines.length - 1;\n        const maxOffset = Math.max(0, exportContentLines.length - EXPORT_VISIBLE_LINES);\n        const newScrollOffset = Math.min(maxOffset, exportScrollOffset + pageJump);\n        const scrollDelta = newScrollOffset - exportScrollOffset;\n        const newCursor = Math.min(maxCursor, exportCursor + scrollDelta);\n        setExportScrollOffset(newScrollOffset);\n        setExportCursor(newCursor);\n        return;\n      }\n\n      if (key.pageUp || (key.ctrl && input === \"u\")) {\n        const newScrollOffset = Math.max(0, exportScrollOffset - pageJump);\n        const scrollDelta = exportScrollOffset - newScrollOffset;\n        const newCursor = Math.max(0, exportCursor - scrollDelta);\n        setExportScrollOffset(newScrollOffset);\n        setExportCursor(newCursor);\n        return;\n      }\n\n      // g: jump to first line\n      if (input === \"g\") {\n        setExportCursor(0);\n        setExportScrollOffset(0);\n        return;\n      }\n\n      // G: jump to last line\n      if (input === \"G\") {\n        const maxCursor = exportContentLines.length - 1;\n        const maxOffset = Math.max(0, exportContentLines.length - EXPORT_VISIBLE_LINES);\n        setExportCursor(maxCursor);\n        setExportScrollOffset(maxOffset);\n        return;\n      }\n\n      // y: copy to clipboard\n      if (input === \"y\") {\n        if (statusMessage) return; // Debounce: skip if feedback already showing\n        const lineCount = exportContentLines.length;\n        setStatusMessage(`${lineCount} lines copied`);\n        setTimeout(() => setStatusMessage(null), 2000);\n        clipboard.write(exportContent).catch(() => {\n          setStatusMessage(\"Clipboard unavailable\");\n          setTimeout(() => setStatusMessage(null), 2000);\n        });\n        return;\n      }\n\n      // Enter: open export dialog\n      if (key.return) {\n        const ranges = getSelectionRanges(selected, renderableEntries);\n        if (ranges.length === 1) {\n          setDialogScreen(\"format\");\n        } else {\n          setDialogScreen(\"multimode\");\n        }\n        setDialogCursor(0);\n        setFilenameInput(\"\");\n        return;\n      }\n\n      // Ignore all other input in export preview mode\n      return;\n    }\n\n    if (searchMode) {\n      if (key.return) {\n        // Check if search will find matches BEFORE updating state\n        const results = fuse.search(searchQuery);\n        let indices = results.map((r) => r.item.idx);\n        if (historyFilter === \"selected\") {\n          indices = indices.filter((idx) => filterSnapshot.has(idx));\n        }\n\n        performSearch(searchQuery);\n\n        // Stay in search mode if no matches (let user edit query)\n        if (indices.length === 0) {\n          setSearchedNoMatches(true);\n          return;\n        }\n        setSearchedNoMatches(false);\n        setSearchMode(false);\n      } else if (key.escape) {\n        // Esc state machine: has query → clear query; empty → exit search\n        if (searchQuery) {\n          setSearchQuery(\"\");\n          setMatchIndices([]);\n        } else {\n          setSearchMode(false);\n        }\n      } else if (key.backspace || key.delete) {\n        setSearchQuery((q) => q.slice(0, -1));\n        setSearchedNoMatches(false);\n      } else if (input && !key.ctrl && !key.meta) {\n        setSearchQuery((q) => q + input);\n        setSearchedNoMatches(false);\n      }\n      return;\n    }\n\n    // Navigation - route based on focused pane\n    // Get current filtered list length for bounds\n    const getFilteredLength = () => {\n      if (historyFilter === \"all\") return renderableEntries.length;\n      return Array.from(filterSnapshot).length;\n    };\n\n    if (key.upArrow || input === \"k\") {\n      if (focusedPane === \"history\") {\n        const newCursor = Math.max(0, cursor - 1);\n        setCursor(newCursor);\n        updateScrollForCursor(newCursor);\n        setPreviewScrollOffset(0); // Reset preview scroll on cursor move\n      } else {\n        // Preview pane: scroll up\n        setPreviewScrollOffset(Math.max(0, previewScrollOffset - 1));\n      }\n    }\n\n    if (key.downArrow || input === \"j\") {\n      if (focusedPane === \"history\") {\n        const maxCursor = getFilteredLength() - 1;\n        const newCursor = Math.min(maxCursor, cursor + 1);\n        setCursor(newCursor);\n        updateScrollForCursor(newCursor);\n        setPreviewScrollOffset(0); // Reset preview scroll on cursor move\n      } else {\n        // Preview pane: scroll down (bounds checked in render)\n        setPreviewScrollOffset(previewScrollOffset + 1);\n      }\n    }\n\n    // Page navigation - route based on focused pane\n    if (key.pageUp || (key.ctrl && input === \"u\")) {\n      if (focusedPane === \"history\") {\n        const newCursor = Math.max(0, cursor - VISIBLE_LINES);\n        setCursor(newCursor);\n        updateScrollForCursor(newCursor);\n        setPreviewScrollOffset(0);\n      } else {\n        setPreviewScrollOffset(Math.max(0, previewScrollOffset - VISIBLE_LINES));\n      }\n    }\n\n    if (key.pageDown || (key.ctrl && input === \"d\")) {\n      if (focusedPane === \"history\") {\n        const maxCursor = getFilteredLength() - 1;\n        const newCursor = Math.min(maxCursor, cursor + VISIBLE_LINES);\n        setCursor(newCursor);\n        updateScrollForCursor(newCursor);\n        setPreviewScrollOffset(0);\n      } else {\n        setPreviewScrollOffset(previewScrollOffset + VISIBLE_LINES);\n      }\n    }\n\n    // Space: start visual, confirm range, or toggle (cherrypick)\n    if (input === \" \") {\n      // Helper to get originalIdx for cursor position in filtered view\n      const getOriginalIdx = (displayIdx: number): number => {\n        if (historyFilter === \"all\") return displayIdx;\n        const snapshotArr = Array.from(filterSnapshot).sort((a, b) => a - b);\n        return snapshotArr[displayIdx] ?? displayIdx;\n      };\n\n      if (cherrypickMode) {\n        // Toggle individual using originalIdx\n        const origIdx = getOriginalIdx(cursor);\n        setSelectionHistory((h) => [...h, new Set(selected)]);\n        setSelected((s) => {\n          const newSet = new Set(s);\n          if (newSet.has(origIdx)) newSet.delete(origIdx);\n          else newSet.add(origIdx);\n          return newSet;\n        });\n      } else if (rangeStart === null) {\n        // Start visual mode\n        setRangeStart(cursor);\n      } else {\n        // Confirm visual range - convert display indices to original indices\n        const [start, end] = rangeStart <= cursor ? [rangeStart, cursor] : [cursor, rangeStart];\n\n        // Check if range adds new items or is all overlap\n        let addsNew = false;\n        for (let i = start; i <= end; i++) {\n          const origIdx = getOriginalIdx(i);\n          if (!selected.has(origIdx)) {\n            addsNew = true;\n            break;\n          }\n        }\n\n        setSelectionHistory((h) => [...h, new Set(selected)]);\n        setSelected((s) => {\n          const newSet = new Set(s);\n          for (let i = start; i <= end; i++) {\n            const origIdx = getOriginalIdx(i);\n            if (addsNew) {\n              newSet.add(origIdx); // Green: add to selection\n            } else {\n              newSet.delete(origIdx); // Red: remove from selection\n            }\n          }\n          return newSet;\n        });\n        setRangeStart(null); // Back to idle\n      }\n    }\n\n    // c: toggle cherrypick mode\n    if (input === \"c\") {\n      setCherrypickMode(!cherrypickMode);\n      setRangeStart(null); // Disable visual while cherrypicking\n    }\n\n    // Escape: exit search results → exit cherrypick → exit visual (doesn't quit picker)\n    if (key.escape) {\n      // If in search results navigation mode, go back to search input\n      if (!searchMode && searchQuery) {\n        setSearchMode(true);\n        return;\n      }\n      if (cherrypickMode) {\n        setCherrypickMode(false);\n        setRangeStart(null);\n        return;\n      }\n      if (rangeStart !== null) {\n        setRangeStart(null);\n        return;\n      }\n    }\n\n    // Ctrl-C to exit\n    if (key.ctrl && input === \"c\") {\n      onExit([]);\n      exit();\n      return;\n    }\n\n    // Undo last selection change\n    if (input === \"u\") {\n      if (selectionHistory.length > 0) {\n        const prev = selectionHistory[selectionHistory.length - 1];\n        if (prev) {\n          setRedoHistory((h) => [...h, new Set(selected)]);\n          setSelected(prev);\n          setSelectionHistory((h) => h.slice(0, -1));\n          setStatusMessage(\"Undone\");\n          setTimeout(() => setStatusMessage(null), 1000);\n        }\n      }\n    }\n\n    // Redo (Ctrl+R)\n    if (key.ctrl && input === \"r\") {\n      if (redoHistory.length > 0) {\n        const next = redoHistory[redoHistory.length - 1];\n        if (next) {\n          setSelectionHistory((h) => [...h, new Set(selected)]);\n          setSelected(next);\n          setRedoHistory((h) => h.slice(0, -1));\n          setStatusMessage(\"Redone\");\n          setTimeout(() => setStatusMessage(null), 1000);\n        }\n      }\n    }\n\n    // Search\n    if (input === \"/\") {\n      setFocusedPane(\"history\");\n      setSearchMode(true);\n      setSearchQuery(\"\");\n    }\n\n    // Next/prev match\n    if (input === \"n\" && matchIndices.length > 0) {\n      const nextIdx = (currentMatchIdx + 1) % matchIndices.length;\n      setCurrentMatchIdx(nextIdx);\n      const newCursor = matchIndices[nextIdx];\n      if (newCursor !== undefined) {\n        setCursor(newCursor);\n        updateScrollForCursor(newCursor);\n      }\n    }\n\n    if (input === \"N\" && matchIndices.length > 0) {\n      const prevIdx = (currentMatchIdx - 1 + matchIndices.length) % matchIndices.length;\n      setCurrentMatchIdx(prevIdx);\n      const newCursor = matchIndices[prevIdx];\n      if (newCursor !== undefined) {\n        setCursor(newCursor);\n        updateScrollForCursor(newCursor);\n      }\n    }\n\n    // Select all\n    if (input === \"a\") {\n      const all = new Set<number>();\n      for (let i = 0; i < renderableEntries.length; i++) all.add(i);\n      setSelected(all);\n    }\n\n    // Enter: open export preview (when not in visual select mode)\n    if (key.return && rangeStart === null) {\n      if (selected.size === 0) {\n        setStatusMessage(\"No messages selected\");\n        setTimeout(() => setStatusMessage(null), 1500);\n        return;\n      }\n\n      // Generate export preview content\n      const content = generateExportContent();\n      setExportContent(content);\n\n      // Wrap content to terminal width\n      const columns = stdout?.columns ?? 80;\n      const estLineCount = content.split(\"\\n\").length * 2;\n      const estNumWidth = Math.max(2, String(estLineCount).length);\n      const wrapWidth = columns - 6 - estNumWidth - 2;\n      const wrapped = wrapText(content, wrapWidth);\n      setExportContentLines(wrapped);\n\n      // Find highlighted message position\n      const highlightedEntry = filteredEntries[cursor]?.entry;\n      const highlightedUuid = highlightedEntry ? getUuid(highlightedEntry)?.substring(0, 8) : null;\n\n      let targetLine = 0;\n      if (highlightedUuid) {\n        const headerPattern = new RegExp(`^\\\\[\\\\S+\\\\s+\\\\S+\\\\s+${highlightedUuid}\\\\]$`);\n        targetLine = wrapped.findIndex(line => headerPattern.test(line.text));\n        if (targetLine === -1) targetLine = 0;\n      }\n\n      const centeredOffset = Math.max(0, targetLine - Math.floor(EXPORT_VISIBLE_LINES / 2));\n      const maxOffset = Math.max(0, wrapped.length - EXPORT_VISIBLE_LINES);\n      setExportScrollOffset(Math.min(centeredOffset, maxOffset));\n      setExportCursor(targetLine);\n      setExportPreviewMode(true);\n    }\n\n    // Quit (q exits)\n    if (input === \"q\") {\n      onExit([]);\n      exit();\n    }\n  });\n\n  // Filtered entries based on history filter mode\n  const filteredEntries = useMemo(() => {\n    if (historyFilter === \"all\") {\n      return renderableEntries.map((entry, idx) => ({ entry, originalIdx: idx }));\n    }\n    // Use snapshot to keep unselected items visible until filter is cycled\n    return renderableEntries\n      .map((entry, idx) => ({ entry, originalIdx: idx }))\n      .filter(({ originalIdx }) => filterSnapshot.has(originalIdx));\n  }, [renderableEntries, historyFilter, filterSnapshot]);\n\n  // Clamp scroll offset to valid range for history pane\n  const maxScrollOffset = Math.max(0, filteredEntries.length - VISIBLE_LINES);\n  const clampedScrollOffset = Math.min(scrollOffset, maxScrollOffset);\n\n  // Visible slice for history pane\n  const visibleEntries = filteredEntries.slice(clampedScrollOffset, clampedScrollOffset + VISIBLE_LINES);\n\n  // Compute whether visual range adds new items (for coloring)\n  const visualRangeAddsNew = useMemo(() => {\n    if (rangeStart === null) return false;\n    const [start, end] = rangeStart <= cursor ? [rangeStart, cursor] : [cursor, rangeStart];\n    // Check if any item in the visual range (by display index) is not already selected\n    for (let displayIdx = start; displayIdx <= end; displayIdx++) {\n      const item = filteredEntries[displayIdx];\n      if (item && !selected.has(item.originalIdx)) {\n        return true; // Found an unselected item, will add new\n      }\n    }\n    return false; // All items in range already selected\n  }, [rangeStart, cursor, filteredEntries, selected]);\n\n  // Preview content - use the entry at cursor position in filtered list\n  const PREVIEW_VISIBLE_LINES = VISIBLE_LINES;\n  const PREVIEW_WIDTH = 60;\n  const currentFilteredItem = filteredEntries[cursor];\n  const currentEntry = currentFilteredItem?.entry;\n  const previewContent = currentEntry ? extractFullContent(currentEntry) : \"\";\n  const previewLines = wrapText(previewContent, PREVIEW_WIDTH - 4);\n\n  // Clamp preview scroll offset to valid range\n  const maxPreviewOffset = Math.max(0, previewLines.length - PREVIEW_VISIBLE_LINES);\n  const clampedPreviewOffset = Math.min(previewScrollOffset, maxPreviewOffset);\n\n  const visiblePreviewLines = previewLines.slice(\n    clampedPreviewOffset,\n    clampedPreviewOffset + PREVIEW_VISIBLE_LINES\n  );\n\n  // Type colors\n  const getTypeColor = (type: string): string => {\n    switch (type) {\n      case \"user\": return \"blue\";\n      case \"assistant\": return \"magenta\";\n      case \"system\": return \"yellow\";\n      case \"tool-res\": return \"green\";\n      case \"tool-result\": return \"green\";\n      default: return \"white\";\n    }\n  };\n\n  // Render export content line with colored header detection and line numbers\n  const terminalCols = stdout?.columns ?? 80;\n  const logicalLineCount = exportContentLines.filter(l => !l.isContinuation).length;\n  const numWidth = String(logicalLineCount).length;\n  const lineWidth = terminalCols - 6 - numWidth - 2; // subtract borders, padding, line number, and separator\n  const renderExportLine = (wrappedLine: WrappedLine, key: number, lineNum: number, isCurrentLine = false) => {\n    const { text: line, isContinuation } = wrappedLine;\n    const bgColor = isCurrentLine ? \"#333333\" : undefined;\n    const padLine = (text: string) => text.padEnd(lineWidth, \" \");\n    // Show line number for first lines, padding for continuations\n    const lineNumCol = isContinuation\n      ? \" \".repeat(numWidth + 2)\n      : String(lineNum).padStart(numWidth) + \"  \";\n    // Detect header pattern: [type timestamp uuid]\n    const headerMatch = line.match(/^\\[(\\S+)\\s+(\\S+)\\s+(\\S+)\\]$/);\n    if (headerMatch) {\n      const [, type, time, uuid] = headerMatch;\n      const headerText = `[${type} ${time} ${uuid}]`;\n      const padding = \" \".repeat(Math.max(0, lineWidth - headerText.length));\n      return (\n        <Text key={key} backgroundColor={bgColor}>\n          <Text dimColor={!isCurrentLine}>{lineNumCol}</Text>\n          <Text>[</Text>\n          <Text color={getTypeColor(type || \"\")}>{type}</Text>\n          <Text> </Text>\n          <Text dimColor>{time} {uuid}</Text>\n          <Text>]{padding}</Text>\n        </Text>\n      );\n    }\n    return (\n      <Text key={key} backgroundColor={bgColor}>\n        <Text dimColor={!isCurrentLine}>{lineNumCol}</Text>\n        <Text>{padLine(line || \" \")}</Text>\n      </Text>\n    );\n  };\n\n  return (\n    <Box flexDirection=\"column\">\n      {/* Header */}\n      <Box marginBottom={1} width=\"100%\">\n        <Text bold color=\"cyan\">cc-prism pick</Text>\n        <Text> │ </Text>\n        <Text dimColor>{sessionPath.split(\"/\").pop()}</Text>\n      </Box>\n\n      {dialogScreen !== null ? (\n        <>\n          {/* Dialog header */}\n          <Box>\n            {(() => {\n              const ranges = getSelectionRanges(selected, renderableEntries);\n              const range = ranges[0];\n              const startUuid = range?.startUuid.substring(0, 8) ?? \"????????\";\n              const endUuid = range?.endUuid.substring(0, 8) ?? \"????????\";\n              const msgCount = selected.size;\n              return (\n                <>\n                  <Text color=\"cyan\">Exporting range: </Text>\n                  <Text>{startUuid}-{endUuid}</Text>\n                  <Text dimColor> - {msgCount} message{msgCount !== 1 ? \"s\" : \"\"}</Text>\n                </>\n              );\n            })()}\n          </Box>\n\n          {/* Dialog content */}\n          <Box\n            flexDirection=\"column\"\n            borderStyle=\"single\"\n            borderColor=\"magenta\"\n            paddingX={2}\n            paddingY={1}\n          >\n            {dialogScreen === \"format\" && (() => {\n              const showAdvanced = multiExportCast;\n              const cancelIdx = showAdvanced ? 5 : 4;\n              return (\n                <Box flexDirection=\"column\">\n                  <Text bold color=\"cyan\">Select format:</Text>\n                  <Text> </Text>\n                  <Text color={dialogCursor === 0 ? \"yellow\" : undefined}>\n                    {dialogCursor === 0 ? \"▸\" : \" \"}\n                    <Text color={multiExportCast && !multiExportJsonl ? \"cyan\" : undefined}>\n                      ({multiExportCast && !multiExportJsonl ? \"●\" : \" \"}) .cast\n                    </Text>\n                  </Text>\n                  <Text color={dialogCursor === 1 ? \"yellow\" : undefined}>\n                    {dialogCursor === 1 ? \"▸\" : \" \"}\n                    <Text color={multiExportJsonl && !multiExportCast ? \"cyan\" : undefined}>\n                      ({multiExportJsonl && !multiExportCast ? \"●\" : \" \"}) .jsonl\n                    </Text>\n                  </Text>\n                  <Text color={dialogCursor === 2 ? \"yellow\" : undefined}>\n                    {dialogCursor === 2 ? \"▸\" : \" \"}\n                    <Text color={multiExportCast && multiExportJsonl ? \"cyan\" : undefined}>\n                      ({multiExportCast && multiExportJsonl ? \"●\" : \" \"}) Both\n                    </Text>\n                  </Text>\n                  <Text> </Text>\n                  <Text color={dialogCursor === 3 ? \"green\" : undefined} bold={dialogCursor === 3}>\n                    {dialogCursor === 3 ? \"▸\" : \" \"} Confirm\n                  </Text>\n                  {showAdvanced && (\n                    <Text color={dialogCursor === 4 ? \"cyan\" : undefined}>\n                      {dialogCursor === 4 ? \"▸\" : \" \"} Advanced options\n                    </Text>\n                  )}\n                  <Text color={dialogCursor === cancelIdx ? \"red\" : undefined}>\n                    {dialogCursor === cancelIdx ? \"▸\" : \" \"} Cancel\n                  </Text>\n                </Box>\n              );\n            })()}\n\n            {dialogScreen === \"multimode\" && (() => {\n              const ranges = getSelectionRanges(selected, renderableEntries);\n              const showAdvanced = multiExportCast;\n              // Calculate button indices dynamically\n              const confirmIdx = 5;\n              const advancedIdx = showAdvanced ? 6 : -1;\n              const copyIdx = exportMode === \"multiple\" ? (showAdvanced ? 7 : 6) : -1;\n              const cancelIdx = showAdvanced\n                ? (exportMode === \"multiple\" ? 8 : 7)\n                : (exportMode === \"multiple\" ? 7 : 6);\n              return (\n                <Box flexDirection=\"column\">\n                  <Text bold color=\"cyan\">Export {ranges.length} Ranges</Text>\n                  <Text> </Text>\n                  <Text color={dialogCursor === 0 ? \"yellow\" : undefined}>\n                    {dialogCursor === 0 ? \"▸\" : \" \"}\n                    <Text color={exportMode === \"single\" ? \"cyan\" : undefined}>\n                      ({exportMode === \"single\" ? \"●\" : \" \"}) Single (Concatenated)\n                    </Text>\n                  </Text>\n                  <Text color={dialogCursor === 1 ? \"yellow\" : undefined}>\n                    {dialogCursor === 1 ? \"▸\" : \" \"}\n                    <Text color={exportMode === \"multiple\" ? \"cyan\" : undefined}>\n                      ({exportMode === \"multiple\" ? \"●\" : \" \"}) Multiple ranges\n                    </Text>\n                  </Text>\n                  <Text> </Text>\n                  <Text dimColor>\n                    {exportMode === \"multiple\" ? `Exporting ${ranges.length} ranges, c` : \"C\"}hoose format:\n                  </Text>\n                  <Text color={dialogCursor === 2 ? \"yellow\" : undefined}>\n                    {dialogCursor === 2 ? \"▸\" : \" \"}\n                    <Text color={multiExportJsonl && !multiExportCast ? \"cyan\" : undefined}>\n                      ({multiExportJsonl && !multiExportCast ? \"●\" : \" \"}) .jsonl\n                    </Text>\n                  </Text>\n                  <Text color={dialogCursor === 3 ? \"yellow\" : undefined}>\n                    {dialogCursor === 3 ? \"▸\" : \" \"}\n                    <Text color={multiExportCast && !multiExportJsonl ? \"cyan\" : undefined}>\n                      ({multiExportCast && !multiExportJsonl ? \"●\" : \" \"}) .cast\n                    </Text>\n                  </Text>\n                  <Text color={dialogCursor === 4 ? \"yellow\" : undefined}>\n                    {dialogCursor === 4 ? \"▸\" : \" \"}\n                    <Text color={multiExportCast && multiExportJsonl ? \"cyan\" : undefined}>\n                      ({multiExportCast && multiExportJsonl ? \"●\" : \" \"}) both\n                    </Text>\n                  </Text>\n                  <Text> </Text>\n                  <Text color={dialogCursor === confirmIdx ? \"green\" : undefined} bold={dialogCursor === confirmIdx}>\n                    {dialogCursor === confirmIdx ? \"▸\" : \" \"} Confirm\n                  </Text>\n                  {showAdvanced && (\n                    <Text color={dialogCursor === advancedIdx ? \"cyan\" : undefined}>\n                      {dialogCursor === advancedIdx ? \"▸\" : \" \"} Advanced options\n                    </Text>\n                  )}\n                  {exportMode === \"multiple\" && (\n                    <Text color={dialogCursor === copyIdx ? \"cyan\" : undefined}>\n                      {dialogCursor === copyIdx ? \"▸\" : \" \"} Copy commands\n                    </Text>\n                  )}\n                  <Text color={dialogCursor === cancelIdx ? \"red\" : undefined}>\n                    {dialogCursor === cancelIdx ? \"▸\" : \" \"} Cancel\n                  </Text>\n                </Box>\n              );\n            })()}\n\n            {dialogScreen === \"filename\" && (() => {\n              const ranges = getSelectionRanges(selected, renderableEntries);\n              const suggestedName = generateSuggestedFilename(ranges);\n              return (\n                <Box flexDirection=\"column\">\n                  <Text bold color=\"cyan\">Enter filename</Text>\n                  <Text dimColor>(extension will be added automatically)</Text>\n                  <Text> </Text>\n                  <Box>\n                    <Text color=\"yellow\">Filename: </Text>\n                    {filenameInput ? (\n                      <>\n                        <Text>{filenameInput}</Text>\n                        <Text color=\"gray\">█</Text>\n                      </>\n                    ) : (\n                      <>\n                        <Text dimColor>{suggestedName}</Text>\n                        <Text color=\"gray\">█</Text>\n                      </>\n                    )}\n                  </Box>\n                  <Text> </Text>\n                  <Text dimColor>Press Enter to confirm, Esc to cancel</Text>\n                </Box>\n              );\n            })()}\n          </Box>\n\n          {/* Status bar for dialog */}\n          <Box marginTop={1} justifyContent=\"space-between\">\n            <Box>\n              <Text backgroundColor=\"#F97583\" color=\"black\" bold> EXPORT </Text>\n              <Text>  </Text>\n              <Text color=\"#F97583\">y</Text><Text dimColor>:copy command  </Text>\n              <Text color=\"#F97583\">Esc</Text><Text dimColor>:back</Text>\n            </Box>\n            {statusMessage && <Text color=\"cyan\">{statusMessage}</Text>}\n          </Box>\n        </>\n      ) : exportPreviewMode ? (\n        <>\n          {/* Export preview header */}\n          <Box>\n            <Text color=\"cyan\">Export preview</Text>\n            <Text dimColor> - {selected.size} message{selected.size !== 1 ? \"s\" : \"\"}</Text>\n          </Box>\n\n          {/* Full-width export content pane */}\n          <Box\n            flexDirection=\"column\"\n            borderStyle=\"single\"\n            borderColor=\"cyan\"\n            paddingX={1}\n          >\n            <Box flexDirection=\"column\">\n              {(() => {\n                // Count non-continuation lines before scroll offset to get starting line number\n                let logicalLineNum = exportContentLines.slice(0, exportScrollOffset).filter(l => !l.isContinuation).length;\n                return exportContentLines\n                  .slice(exportScrollOffset, exportScrollOffset + EXPORT_VISIBLE_LINES)\n                  .map((line, i) => {\n                    if (!line.isContinuation) logicalLineNum++;\n                    return renderExportLine(line, i, logicalLineNum, exportScrollOffset + i === exportCursor);\n                  });\n              })()}\n            </Box>\n\n            {/* Scroll indicator */}\n            <Box justifyContent=\"space-between\">\n              <Text dimColor>\n                {exportContentLines.length === 0\n                  ? \"\"\n                  : `${exportScrollOffset + 1}-${Math.min(exportScrollOffset + EXPORT_VISIBLE_LINES, exportContentLines.length)} of ${exportContentLines.length}`}\n              </Text>\n              <Text dimColor>j/k:scroll  ^d/^u:pgup/pgdown</Text>\n            </Box>\n          </Box>\n\n          {/* Status bar for export preview */}\n          <Box marginTop={1} justifyContent=\"space-between\">\n            <Box>\n              <Text backgroundColor=\"#D4A843\" color=\"black\" bold> EXPORT </Text>\n              <Text>  </Text>\n              <Text color=\"#D4A843\">Enter</Text><Text dimColor>:proceed  </Text>\n              <Text color=\"#D4A843\">Esc</Text><Text dimColor>:back  </Text>\n              <Text color=\"#D4A843\">y</Text><Text dimColor>:copy</Text>\n            </Box>\n            {statusMessage && <Text color=\"cyan\">{statusMessage}</Text>}\n          </Box>\n        </>\n      ) : (\n        <>\n          {/* Pane titles - aligned with pane borders below */}\n          <Box flexDirection=\"row\">\n            <Box width=\"40%\" paddingLeft={1}>\n              <Text color={focusedPane === \"history\" ? \"cyan\" : undefined} bold={focusedPane === \"history\"}>[1]</Text>\n              <Text> </Text>\n              <Text color={historyFilter === \"all\" ? \"cyan\" : undefined}>All</Text>\n              <Text> - </Text>\n              <Text color={historyFilter === \"selected\" ? \"cyan\" : undefined}>Selected ({selected.size})</Text>\n            </Box>\n            <Box flexGrow={1} paddingLeft={1}>\n              <Text color={focusedPane === \"preview\" ? \"cyan\" : undefined} bold={focusedPane === \"preview\"}>[2]</Text>\n              <Text color={focusedPane === \"preview\" ? \"cyan\" : undefined}> Preview</Text>\n            </Box>\n          </Box>\n\n          {/* Dual-pane area */}\n          <Box flexDirection=\"row\">\n            {/* History Pane (Left) */}\n            <Box\n              flexDirection=\"column\"\n              justifyContent=\"space-between\"\n              borderStyle=\"single\"\n              borderColor={focusedPane === \"history\" ? \"cyan\" : \"gray\"}\n              paddingX={1}\n              width=\"40%\"\n              minHeight={VISIBLE_LINES + 3}\n            >\n              <Box flexDirection=\"column\">\n              {visibleEntries.map(({ entry, originalIdx }, i) => {\n                const displayIdx = clampedScrollOffset + i; // Position in filtered list (for cursor)\n                const uuid = getUuid(entry) ?? `idx-${originalIdx}`;\n                const fmt = formatEntry(entry, displayIdx, cursor, selected, matchIndices, currentMatchIdx, rangeStart, originalIdx, visualRangeAddsNew);\n                // Color priority: visual preview (green/red) > selected (cyan) > normal\n                const prefixColor = fmt.isVisualPreview ? fmt.visualColor : (fmt.isSelected ? \"cyan\" : undefined);\n                return (\n                  <Text key={`${uuid}-${originalIdx}`} wrap=\"truncate\">\n                    <Text color={prefixColor} bold={fmt.isCursor}>\n                      {fmt.prefix}\n                    </Text>\n                    <Text dimColor>{fmt.uuid} </Text>\n                    <Text color={getTypeColor(fmt.type)}>{fmt.type.padEnd(9)} </Text>\n                    {fmt.isToolResult && <Text dimColor>∟ </Text>}\n                    <Text\n                      color={fmt.isCurrentMatch ? \"yellow\" : fmt.isMatch ? \"cyan\" : undefined}\n                      inverse={fmt.isCursor}\n                    >\n                      {fmt.preview}\n                    </Text>\n                  </Text>\n                );\n              })}\n              </Box>\n              <Box justifyContent=\"space-between\">\n                <Text>{selected.size > 0 ? <Text>{selected.size} selected</Text> : <Text dimColor>No selection</Text>}</Text>\n                <Text dimColor>\n                  {filteredEntries.length === 0\n                    ? \"\"\n                    : `${clampedScrollOffset + 1}-${Math.min(clampedScrollOffset + VISIBLE_LINES, filteredEntries.length)} of ${filteredEntries.length}`}\n                </Text>\n              </Box>\n            </Box>\n\n            {/* Preview Pane (Right) */}\n            <Box\n              flexDirection=\"column\"\n              justifyContent=\"space-between\"\n              borderStyle=\"single\"\n              borderColor={focusedPane === \"preview\" ? \"cyan\" : \"gray\"}\n              paddingX={1}\n              flexGrow={1}\n              minHeight={VISIBLE_LINES + 3}\n            >\n              <Box flexDirection=\"column\">\n                {visiblePreviewLines.map((wrappedLine, i) => (\n                  <Text key={i} wrap=\"truncate\">{wrappedLine.text}</Text>\n                ))}\n              </Box>\n              <Box justifyContent=\"flex-end\">\n                <Text dimColor>\n                  {previewLines.length === 0\n                    ? \"\"\n                    : `${clampedPreviewOffset + 1}-${Math.min(clampedPreviewOffset + PREVIEW_VISIBLE_LINES, previewLines.length)} of ${previewLines.length}`}\n                </Text>\n              </Box>\n            </Box>\n          </Box>\n\n          {/* Status bar */}\n          <Box marginTop={1} justifyContent=\"space-between\">\n            <Box>\n              {/* Vim-style mode indicator */}\n              {searchMode || searchQuery ? (\n                <Text backgroundColor=\"#D5B451\" color=\"black\" bold> SEARCH </Text>\n              ) : cherrypickMode ? (\n                <Text backgroundColor=\"#55A3E0\" color=\"black\" bold> CHERRYPICK </Text>\n              ) : rangeStart !== null ? (\n                <Text backgroundColor=\"#A6A8FA\" color=\"black\" bold> VISUAL </Text>\n              ) : (\n                <Text backgroundColor=\"#8BB372\" color=\"black\" bold> NORMAL </Text>\n              )}\n              <Text>  </Text>\n              {/* Status info */}\n              {statusMessage ? (\n                <Text color=\"green\">{statusMessage}</Text>\n              ) : searchMode ? (\n                <Text>\n                  <Text color=\"green\">/</Text>\n                  {searchQuery ? (\n                    <>\n                      <Text bold>{searchQuery}</Text>\n                      <Text color=\"gray\">█</Text>\n                      {searchedNoMatches ? (\n                        <Text dimColor> No matches</Text>\n                      ) : (\n                        <Text dimColor> [Enter]</Text>\n                      )}\n                    </>\n                  ) : (\n                    <>\n                      <Text color=\"gray\">█</Text>\n                      <Text dimColor> type keyword</Text>\n                    </>\n                  )}\n                </Text>\n              ) : searchQuery && matchIndices.length > 0 ? (\n                <Text>\n                  <Text color=\"green\">/</Text>\n                  <Text color=\"green\" bold>{searchQuery}</Text>\n                  <Text color=\"green\"> [{currentMatchIdx + 1}/{matchIndices.length}]</Text>\n                  <Text dimColor> n/N:cycle</Text>\n                </Text>\n              ) : searchQuery && matchIndices.length === 0 ? (\n                <Text>\n                  <Text color=\"green\">/</Text>\n                  <Text bold>{searchQuery}</Text>\n                  <Text color=\"gray\">█</Text>\n                  <Text dimColor> No matches</Text>\n                </Text>\n              ) : (\n                <>\n                  <Text color=\"#8BB372\">Space</Text><Text dimColor>:select  </Text>\n                  <Text color=\"#8BB372\">Enter</Text><Text dimColor>:Export</Text>\n                </>\n              )}\n            </Box>\n          </Box>\n\n          {/* Help */}\n          <Box marginTop={1}>\n            <Text dimColor>\n              {searchMode || searchQuery\n                ? \"Esc:back\"\n                : \"Tab:tabs  c:cherrypick  u:undo  /:search  q:quit\"}\n            </Text>\n          </Box>\n        </>\n      )}\n    </Box>\n  );\n}\n\n// Main export\nexport interface PickerResult {\n  selections: Selection[];\n  interactiveExport?: InteractiveExportResult;\n}\n\nexport async function runPicker(\n  entries: TranscriptEntry[],\n  sessionPath: string\n): Promise<PickerResult> {\n  return new Promise((resolve) => {\n    let interactiveResult: InteractiveExportResult | undefined;\n\n    const { waitUntilExit } = render(\n      <Picker\n        entries={entries}\n        sessionPath={sessionPath}\n        onExit={(selections) => {\n          resolve({ selections, interactiveExport: interactiveResult });\n        }}\n        onInteractiveExport={(result) => {\n          interactiveResult = result;\n        }}\n      />\n    );\n    waitUntilExit().then(() => {\n      // Ensure cleanup completes\n    });\n  });\n}\n\nexport type { Selection };\n","#!/usr/bin/env node\n/**\n * cc-prism CLI\n * Convert Claude Code session JSONL files to asciicast v3\n */\n\nimport { Command } from \"commander\";\nimport { writeFile } from \"node:fs/promises\";\nimport { resolve } from \"node:path\";\nimport chalk from \"chalk\";\n\nimport { loadTranscript } from \"./parser/loader.js\";\nimport { extractClip, getClipSummary } from \"./parser/clip.js\";\nimport { getTimestamp, getUuid } from \"./parser/loader.js\";\nimport { convertToAsciicast, getSessionInfo, generateTitle } from \"./generator/convert.js\";\nimport { serializeCast } from \"./generator/builder.js\";\nimport { getTheme } from \"./renderer/theme.js\";\nimport type { MarkerMode } from \"./types/asciicast.js\";\nimport { isRenderableMessage } from \"./types/messages.js\";\nimport { uploadToAsciinema } from \"./cli/upload.js\";\nimport { getClaudeProjectPath, listSessions, getLatestSession, formatSize } from \"./cli/sessions.js\";\n\nconst program = new Command();\n\nprogram\n  .name(\"cc-prism\")\n  .description(\"Convert Claude Code session JSONL files to asciicast v3\")\n  .version(\"0.1.0\");\n\n// =============================================================================\n// cast command\n// =============================================================================\n\nprogram\n  .command(\"cast\")\n  .description(\"Generate asciicast from a session file\")\n  .argument(\"[session]\", \"Path to session JSONL file (or use --latest)\")\n  .option(\"--latest\", \"Use most recent session from current project\")\n  .option(\"--start-uuid <uuid>\", \"Start from message UUID\")\n  .option(\"--end-uuid <uuid>\", \"End at message UUID\")\n  .option(\"--last <n>\", \"Last N messages\", parseIntOption)\n  .option(\"--start-time <timestamp>\", \"Start from timestamp (ISO 8601)\")\n  .option(\"--end-time <timestamp>\", \"End at timestamp (ISO 8601)\")\n  .option(\"-o, --output <file>\", \"Output file path (default: stdout)\")\n  .option(\"--theme <name>\", \"Theme name (tokyo-night, dracula, nord, catppuccin-mocha)\", \"tokyo-night\")\n  .option(\"--preset <preset>\", \"Timing preset (speedrun, default, realtime)\", \"default\")\n  .option(\"--max-wait <seconds>\", \"Maximum pause between events\", parseFloatOption)\n  .option(\"--thinking-pause <seconds>\", \"Pause before assistant response\", parseFloatOption)\n  .option(\"--typing-effect\", \"Enable typing effect for user input\")\n  .option(\"--no-status-spinner\", \"Disable status spinner animation\")\n  .option(\"--spinner-duration <seconds>\", \"Duration of spinner animation (default: 3.0)\", parseFloatOption)\n  .option(\"--cols <n>\", \"Terminal width\", parseIntOption, 100)\n  .option(\"--rows <n>\", \"Terminal height\", parseIntOption, 40)\n  .option(\"--markers <mode>\", \"Marker mode (all, user, tools, none)\", \"all\")\n  .option(\"--title <title>\", \"Recording title\")\n  .option(\"--upload\", \"Upload to asciinema.org after generation\")\n  .option(\"--no-agents\", \"Exclude agent/sub-assistant messages\")\n  .option(\"-q, --quiet\", \"Suppress stats output\")\n  .option(\"-I, --interactive\", \"Open interactive options form\")\n  .action(async (sessionPath: string | undefined, options) => {\n    try {\n      // Resolve session path\n      let fullPath: string;\n      if (options.latest) {\n        const latest = await getLatestSession(process.cwd());\n        if (!latest) {\n          console.error(chalk.red(\"Error: No sessions found for current project\"));\n          console.error(chalk.gray(`  Looked in: ${getClaudeProjectPath(process.cwd())}`));\n          process.exit(1);\n        }\n        fullPath = latest;\n        if (!options.quiet) {\n          console.error(chalk.gray(`Using: ${fullPath}`));\n        }\n      } else if (sessionPath) {\n        fullPath = resolve(sessionPath);\n      } else {\n        console.error(chalk.red(\"Error: Provide a session path or use --latest\"));\n        process.exit(1);\n      }\n\n      // Handle .cast files: upload-only mode\n      if (fullPath.endsWith(\".cast\")) {\n        if (options.upload) {\n          // Just upload the existing cast file\n          console.error(chalk.cyan(\"  Uploading existing cast file...\"));\n          const url = await uploadToAsciinema(fullPath);\n          if (url) {\n            console.error(chalk.green(`✓ Uploaded: ${url}`));\n          }\n          process.exit(0);\n        } else {\n          console.error(chalk.red(\"Error: Input is already a .cast file\"));\n          console.error(chalk.gray(\"  Use --upload to share it on asciinema.org\"));\n          console.error(chalk.gray(\"  Or provide a .jsonl session file to convert\"));\n          process.exit(1);\n        }\n      }\n\n      const entries = await loadTranscript(fullPath, {\n        loadAgents: options.agents !== false,\n      });\n\n      if (entries.length === 0) {\n        console.error(chalk.red(\"Error: No messages found in session file\"));\n        process.exit(1);\n      }\n\n      // Apply clip extraction\n      const clip = extractClip(entries, {\n        startUuid: options.startUuid,\n        endUuid: options.endUuid,\n        startTime: options.startTime,\n        endTime: options.endTime,\n        last: options.last,\n      });\n\n      if (clip.length === 0) {\n        console.error(chalk.red(\"Error: No messages match the specified criteria\"));\n        process.exit(1);\n      }\n\n      // Interactive mode: launch form TUI\n      if (options.interactive) {\n        const { runInteractiveForm } = await import(\"./cli/interactive.js\");\n        const sessionBasename = fullPath.split(\"/\").pop()?.replace(\".jsonl\", \"\") || \"session\";\n        const timestamp = new Date().toISOString().replace(/[-:T]/g, \"\").slice(0, 14);\n        const defaultOutput = `${sessionBasename.slice(0, 8)}-${timestamp}.cast`;\n        const sessionInfo = getSessionInfo(clip);\n        const defaultTitle = generateTitle(sessionInfo);\n\n        const formConfig = await runInteractiveForm(fullPath, defaultOutput, defaultTitle);\n\n        if (!formConfig) {\n          // User cancelled\n          process.exit(0);\n        }\n\n        // Map form config to options\n        options.output = formConfig.output;\n        options.upload = formConfig.upload;\n        options.theme = formConfig.theme;\n        options.cols = formConfig.cols;\n        options.rows = formConfig.rows;\n        options.title = formConfig.title || undefined;\n        options.preset = formConfig.preset;\n        options.maxWait = formConfig.maxWait ?? undefined;\n        options.thinkingPause = formConfig.thinkingPause ?? undefined;\n        options.typingEffect = formConfig.typingEffect;\n        options.statusSpinner = formConfig.statusSpinner;\n        options.spinnerDuration = formConfig.spinnerDuration;\n        options.markers = formConfig.markers;\n      }\n\n      // Get theme\n      const theme = getTheme(options.theme);\n\n      // Generate title\n      const sessionInfo = getSessionInfo(clip);\n      const title = options.title ?? generateTitle(sessionInfo);\n\n      // Convert to asciicast\n      const result = convertToAsciicast(clip, {\n        builder: {\n          cols: options.cols,\n          rows: options.rows,\n          title,\n        },\n        timing: {\n          preset: options.preset as \"speedrun\" | \"default\" | \"realtime\",\n          maxWait: options.maxWait,\n          thinkingPause: options.thinkingPause,\n          typingEffect: options.typingEffect,\n        },\n        markers: {\n          mode: options.markers as MarkerMode,\n        },\n        render: {\n          theme,\n          width: options.cols,\n        },\n        inputAnimation: true, // Always enable Claude Code style input UI\n        statusSpinner: options.statusSpinner,\n        spinnerDuration: options.spinnerDuration,\n      });\n\n      // Serialize\n      const castContent = serializeCast(result.document);\n\n      // Output\n      if (options.output) {\n        const outputPath = resolve(options.output);\n        await writeFile(outputPath, castContent, \"utf-8\");\n\n        if (!options.quiet) {\n          console.error(chalk.green(`✓ Generated ${outputPath}`));\n          printStats(result.stats, options);\n        }\n\n        // Upload if requested\n        if (options.upload) {\n          await handleUpload(outputPath, options.quiet);\n        }\n      } else if (options.upload) {\n        // Write to temp file for upload\n        const tempPath = `/tmp/cc-prism-${Date.now()}.cast`;\n        await writeFile(tempPath, castContent, \"utf-8\");\n        await handleUpload(tempPath, options.quiet);\n      } else {\n        // Write to stdout\n        process.stdout.write(castContent);\n      }\n    } catch (error) {\n      console.error(chalk.red(`Error: ${error instanceof Error ? error.message : String(error)}`));\n      process.exit(1);\n    }\n  });\n\n// =============================================================================\n// list command\n// =============================================================================\n\nprogram\n  .command(\"list\")\n  .description(\"List messages with UUIDs and timestamps\")\n  .argument(\"<session>\", \"Path to session JSONL file\")\n  .option(\"--no-agents\", \"Exclude agent/sub-assistant messages\")\n  .option(\"--all\", \"Show all messages including non-renderable\")\n  .action(async (sessionPath: string, options) => {\n    try {\n      const fullPath = resolve(sessionPath);\n      const entries = await loadTranscript(fullPath, {\n        loadAgents: options.agents !== false,\n      });\n\n      if (entries.length === 0) {\n        console.log(chalk.yellow(\"No messages found in session file\"));\n        return;\n      }\n\n      // Print header\n      console.log(\n        chalk.bold(\n          padRight(\"UUID\", 12) +\n            padRight(\"TIME\", 10) +\n            padRight(\"TYPE\", 12) +\n            \"CONTENT\"\n        )\n      );\n      console.log(\"─\".repeat(80));\n\n      // Print messages\n      for (const entry of entries) {\n        if (!options.all && !isRenderableMessage(entry)) {\n          continue;\n        }\n\n        const uuid = getUuid(entry);\n        const timestamp = getTimestamp(entry);\n        const timeStr = timestamp\n          ? timestamp.toISOString().substring(11, 19)\n          : \"        \";\n\n        const uuidShort = uuid ? uuid.substring(0, 10) + \"..\" : \"            \";\n\n        let typeStr: string = entry.type;\n        let contentPreview = \"\";\n\n        if (entry.type === \"user\") {\n          if (entry.toolUseResult) {\n            typeStr = \"tool-result\";\n            const isError = typeof entry.toolUseResult === \"string\" || entry.toolUseResult.is_error;\n            contentPreview = isError ? \"(error)\" : \"(success)\";\n          } else {\n            const content =\n              typeof entry.message.content === \"string\"\n                ? entry.message.content\n                : \"\";\n            contentPreview = content.substring(0, 40).replace(/\\n/g, \" \");\n          }\n        } else if (entry.type === \"assistant\") {\n          const tools = entry.message.content.filter((c) => c.type === \"tool_use\");\n          if (tools.length > 0) {\n            const toolNames = tools.map((t) => t.name).join(\", \");\n            contentPreview = `[${toolNames}]`;\n          } else {\n            const text = entry.message.content.find((c) => c.type === \"text\");\n            if (text && text.type === \"text\") {\n              contentPreview = text.text.substring(0, 40).replace(/\\n/g, \" \");\n            }\n          }\n        } else if (entry.type === \"system\" && entry.content) {\n          contentPreview = entry.content.substring(0, 40);\n        }\n\n        const color = getTypeColor(entry.type);\n        console.log(\n          chalk.gray(uuidShort) +\n            chalk.gray(padRight(timeStr, 10)) +\n            color(padRight(typeStr, 12)) +\n            contentPreview\n        );\n      }\n\n      // Summary\n      const summary = getClipSummary(entries);\n      console.log(\"─\".repeat(80));\n      console.log(\n        chalk.gray(\n          `Total: ${summary.total} messages | ` +\n            `User: ${summary.user} | ` +\n            `Assistant: ${summary.assistant} | ` +\n            `Tools: ${summary.tools}`\n        )\n      );\n    } catch (error) {\n      console.error(chalk.red(`Error: ${error instanceof Error ? error.message : String(error)}`));\n      process.exit(1);\n    }\n  });\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\nfunction parseIntOption(value: string): number {\n  const parsed = parseInt(value, 10);\n  if (isNaN(parsed)) {\n    throw new Error(`Invalid number: ${value}`);\n  }\n  return parsed;\n}\n\nfunction parseFloatOption(value: string): number {\n  const parsed = parseFloat(value);\n  if (isNaN(parsed)) {\n    throw new Error(`Invalid number: ${value}`);\n  }\n  return parsed;\n}\n\nfunction padRight(str: string, len: number): string {\n  return str.padEnd(len);\n}\n\nfunction getTypeColor(type: string): (text: string) => string {\n  switch (type) {\n    case \"user\":\n      return chalk.blue;\n    case \"assistant\":\n      return chalk.magenta;\n    case \"system\":\n      return chalk.yellow;\n    case \"tool-result\":\n      return chalk.green;\n    default:\n      return chalk.white;\n  }\n}\n\ninterface ConvertStats {\n  entriesProcessed: number;\n  entriesRendered: number;\n  eventsGenerated: number;\n  markersGenerated: number;\n  duration: number;\n}\n\nfunction printStats(stats: ConvertStats, options: { preset?: string }): void {\n  console.error(\n    chalk.gray(\n      `  Messages: ${stats.entriesRendered}/${stats.entriesProcessed} | ` +\n        `Events: ${stats.eventsGenerated} | ` +\n        `Markers: ${stats.markersGenerated} | ` +\n        `Duration: ${stats.duration.toFixed(1)}s | ` +\n        `Preset: ${options.preset ?? \"default\"}`\n    )\n  );\n}\n\nasync function handleUpload(filePath: string, quiet: boolean): Promise<void> {\n  if (!quiet) {\n    console.error(chalk.gray(\"  Uploading to asciinema.org...\"));\n  }\n\n  const result = await uploadToAsciinema(filePath);\n\n  if (result.success && result.url) {\n    console.log(chalk.green(`✓ Uploaded: ${result.url}`));\n  } else {\n    console.error(chalk.red(`✗ Upload failed: ${result.error}`));\n    if (result.error?.includes(\"auth\")) {\n      console.error(chalk.yellow(\"  Run 'asciinema auth' to authenticate first\"));\n    }\n    process.exit(1);\n  }\n}\n\n// =============================================================================\n// sessions command\n// =============================================================================\n\nprogram\n  .command(\"sessions\")\n  .description(\"List available sessions for current project\")\n  .action(async () => {\n    try {\n      const cwd = process.cwd();\n      const projectPath = getClaudeProjectPath(cwd);\n      const sessions = await listSessions(projectPath);\n\n      if (sessions.length === 0) {\n        console.log(chalk.yellow(\"No sessions found\"));\n        console.log(chalk.gray(`  Project path: ${projectPath}`));\n        return;\n      }\n\n      console.log(chalk.bold(`Sessions for ${cwd}`));\n      console.log(chalk.gray(projectPath));\n      console.log();\n\n      for (const session of sessions) {\n        const age = formatAge(session.modified);\n        console.log(\n          chalk.cyan(session.name.substring(0, 8)) +\n            chalk.gray(\"  \" + padRight(age, 12) + formatSize(session.size))\n        );\n      }\n\n      console.log();\n      console.log(chalk.gray(`Use: cc-prism cast --latest`));\n    } catch (error) {\n      console.error(chalk.red(`Error: ${error instanceof Error ? error.message : String(error)}`));\n      process.exit(1);\n    }\n  });\n\nfunction formatAge(date: Date): string {\n  const seconds = Math.floor((Date.now() - date.getTime()) / 1000);\n  if (seconds < 60) return \"just now\";\n  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;\n  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;\n  return `${Math.floor(seconds / 86400)}d ago`;\n}\n\n// =============================================================================\n// pick command\n// =============================================================================\n\nprogram\n  .command(\"pick\")\n  .description(\"Interactive message picker for selecting ranges\")\n  .argument(\"[session]\", \"Path to session JSONL file (or use --latest)\")\n  .option(\"--latest\", \"Use most recent session from current project\")\n  .option(\"--no-agents\", \"Exclude agent/sub-assistant messages\")\n  .action(async (sessionPath: string | undefined, options) => {\n    try {\n      // Resolve session path\n      let fullPath: string;\n      if (options.latest) {\n        const latestPath = await getLatestSession(process.cwd());\n        if (!latestPath) {\n          console.error(chalk.red(\"No sessions found for current project\"));\n          console.error(chalk.gray(`Searched in: ${getClaudeProjectPath(process.cwd())}`));\n          process.exit(1);\n        }\n        fullPath = latestPath;\n      } else if (sessionPath) {\n        fullPath = resolve(sessionPath);\n      } else {\n        console.error(chalk.red(\"Error: session path required or use --latest\"));\n        process.exit(1);\n      }\n\n      // Load transcript\n      const entries = await loadTranscript(fullPath, {\n        loadAgents: options.agents !== false,\n      });\n\n      if (entries.length === 0) {\n        console.log(chalk.yellow(\"No messages found in session file\"));\n        return;\n      }\n\n      // Run interactive picker (lazy load to avoid Ink/React overhead for other commands)\n      const { runPicker } = await import(\"./cli/picker.js\");\n      const result = await runPicker(entries, fullPath);\n\n      // If \"Advanced options\" was selected, launch interactive cast form\n      if (result.interactiveExport) {\n        const { jsonlPath } = result.interactiveExport;\n        console.log(chalk.cyan(`\\nLaunching interactive cast options for: ${jsonlPath}`));\n\n        // Load the exported JSONL for title generation\n        const exportedEntries = await loadTranscript(jsonlPath, { loadAgents: false });\n        const sessionInfo = getSessionInfo(exportedEntries);\n        const defaultTitle = generateTitle(sessionInfo);\n        const defaultOutput = jsonlPath.replace(/\\.jsonl$/, \".cast\");\n\n        // Run interactive form\n        const { runInteractiveForm } = await import(\"./cli/interactive.js\");\n        const formConfig = await runInteractiveForm(jsonlPath, defaultOutput, defaultTitle);\n\n        if (formConfig) {\n          // Convert with form options\n          const theme = getTheme(formConfig.theme);\n          const castResult = convertToAsciicast(exportedEntries, {\n            builder: {\n              cols: formConfig.cols,\n              rows: formConfig.rows,\n              title: formConfig.title || defaultTitle,\n            },\n            timing: {\n              preset: formConfig.preset as \"speedrun\" | \"default\" | \"realtime\",\n              maxWait: formConfig.maxWait ?? undefined,\n              thinkingPause: formConfig.thinkingPause ?? undefined,\n            },\n            markers: { mode: formConfig.markers as \"all\" | \"user\" | \"tools\" | \"none\" },\n            render: { theme, width: formConfig.cols },\n            inputAnimation: formConfig.typingEffect,\n            statusSpinner: formConfig.statusSpinner,\n            spinnerDuration: formConfig.spinnerDuration,\n          });\n\n          const castContent = serializeCast(castResult.document);\n          const outputPath = formConfig.output || defaultOutput;\n          await writeFile(outputPath, castContent);\n          console.log(chalk.green(`\\nGenerated: ${outputPath}`));\n\n          // Handle upload if requested\n          if (formConfig.upload) {\n            const { uploadToAsciinema } = await import(\"./cli/upload.js\");\n            const uploadResult = await uploadToAsciinema(outputPath);\n            if (uploadResult.success) {\n              console.log(chalk.green(`Uploaded: ${uploadResult.url}`));\n            } else {\n              console.error(chalk.red(`Upload failed: ${uploadResult.error}`));\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error(chalk.red(`Error: ${error instanceof Error ? error.message : String(error)}`));\n      process.exit(1);\n    }\n  });\n\nprogram.parse();\n","/**\n * Clip extraction - filter messages by UUID range, timestamp range, or last N\n */\n\nimport type { TranscriptEntry } from \"../types/messages.js\";\nimport { getTimestamp, getUuid, sortByTimestamp } from \"./loader.js\";\n\nexport interface ClipOptions {\n  /** Start extraction from this message UUID (inclusive) */\n  startUuid?: string;\n  /** End extraction at this message UUID (inclusive) */\n  endUuid?: string;\n  /** Start extraction from this timestamp (ISO 8601) */\n  startTime?: string;\n  /** End extraction at this timestamp (ISO 8601) */\n  endTime?: string;\n  /** Extract last N messages */\n  last?: number;\n}\n\n/**\n * Extract a clip from transcript entries based on filtering options\n *\n * Priority:\n * 1. If `last` is specified, return the last N renderable messages\n * 2. If UUID range is specified, extract messages between start and end UUID\n * 3. If time range is specified, extract messages within time range\n * 4. If no options, return all entries\n */\nexport function extractClip(\n  entries: TranscriptEntry[],\n  options: ClipOptions = {}\n): TranscriptEntry[] {\n  const { startUuid, endUuid, startTime, endTime, last } = options;\n\n  // Sort by timestamp for consistent ordering\n  let sorted = sortByTimestamp(entries);\n\n  // Handle --last N option (highest priority)\n  if (last !== undefined) {\n    if (last <= 0) {\n      return [];\n    }\n    // Filter to renderable messages only for counting\n    const renderable = sorted.filter(isRenderableForClip);\n    const startIndex = Math.max(0, renderable.length - last);\n    return renderable.slice(startIndex);\n  }\n\n  // Handle UUID range filtering\n  if (startUuid || endUuid) {\n    sorted = filterByUuidRange(sorted, startUuid, endUuid);\n  }\n\n  // Handle time range filtering\n  if (startTime || endTime) {\n    sorted = filterByTimeRange(sorted, startTime, endTime);\n  }\n\n  return sorted;\n}\n\n/** Filter entries by UUID range (inclusive) */\nfunction filterByUuidRange(\n  entries: TranscriptEntry[],\n  startUuid?: string,\n  endUuid?: string\n): TranscriptEntry[] {\n  let startIndex = 0;\n  let endIndex = entries.length;\n\n  if (startUuid) {\n    const idx = entries.findIndex((e) => getUuid(e) === startUuid);\n    if (idx !== -1) {\n      startIndex = idx;\n    }\n  }\n\n  if (endUuid) {\n    const idx = entries.findIndex((e) => getUuid(e) === endUuid);\n    if (idx !== -1) {\n      endIndex = idx + 1; // inclusive\n    }\n  }\n\n  return entries.slice(startIndex, endIndex);\n}\n\n/** Filter entries by time range (inclusive) */\nfunction filterByTimeRange(\n  entries: TranscriptEntry[],\n  startTime?: string,\n  endTime?: string\n): TranscriptEntry[] {\n  const startDate = startTime ? new Date(startTime) : null;\n  const endDate = endTime ? new Date(endTime) : null;\n\n  return entries.filter((entry) => {\n    const timestamp = getTimestamp(entry);\n    if (!timestamp) return true; // Include entries without timestamps\n\n    if (startDate && timestamp < startDate) return false;\n    if (endDate && timestamp > endDate) return false;\n\n    return true;\n  });\n}\n\n/** Check if an entry should be counted for clip extraction */\nfunction isRenderableForClip(entry: TranscriptEntry): boolean {\n  switch (entry.type) {\n    case \"user\":\n    case \"assistant\":\n      return true;\n    case \"system\":\n      return entry.content !== null;\n    case \"queue-operation\":\n      // Include 'remove' operations as they represent user steering\n      return entry.operation === \"remove\";\n    case \"summary\":\n    case \"file-history-snapshot\":\n      return false;\n    default:\n      return false;\n  }\n}\n\n/** Get summary of clip for display */\nexport function getClipSummary(entries: TranscriptEntry[]): {\n  total: number;\n  user: number;\n  assistant: number;\n  tools: number;\n  startTime: Date | null;\n  endTime: Date | null;\n} {\n  let user = 0;\n  let assistant = 0;\n  let tools = 0;\n  let startTime: Date | null = null;\n  let endTime: Date | null = null;\n\n  for (const entry of entries) {\n    const timestamp = getTimestamp(entry);\n\n    if (timestamp) {\n      if (!startTime || timestamp < startTime) startTime = timestamp;\n      if (!endTime || timestamp > endTime) endTime = timestamp;\n    }\n\n    if (entry.type === \"user\") {\n      if (entry.toolUseResult) {\n        tools++;\n      } else {\n        user++;\n      }\n    } else if (entry.type === \"assistant\") {\n      assistant++;\n    }\n  }\n\n  return {\n    total: entries.length,\n    user,\n    assistant,\n    tools,\n    startTime,\n    endTime,\n  };\n}\n"],"mappings":"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","names":["agentEntries","indent","text","i","j","styledContent","prefix","chunk","bullet","bulletColor","indent","init_messages","inputConfig","init_messages","resolve","join","readFile","writeFile","THEMES","resolve","useState","useMemo","render","Box","Text","useInput","useApp","useStdout","jsx","jsxs","content","getTypeColor","resolve","init_messages","writeFile","resolve","init_messages","resolve","runInteractiveForm","sessionInfo","writeFile","runPicker","uploadToAsciinema"]}