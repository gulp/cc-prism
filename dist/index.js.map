{"version":3,"sources":["../src/types/messages.ts","../src/types/asciicast.ts","../src/parser/loader.ts","../src/parser/clip.ts","../src/renderer/ansi.ts","../src/renderer/theme.ts","../src/renderer/content.ts","../src/renderer/todos.ts","../src/renderer/markdown.ts","../src/renderer/diff.ts","../src/renderer/tool-results.ts","../src/renderer/tool-formatting.ts","../src/renderer/commands.ts","../src/renderer/messages.ts","../src/renderer/input.ts","../src/generator/builder.ts","../src/generator/timing.ts","../src/generator/markers.ts","../src/renderer/verbs.json","../src/renderer/spinner.ts","../src/generator/convert.ts"],"sourcesContent":["/**\n * Type definitions for Claude Code session JSONL messages\n * Based on claude-code-log models and real session analysis\n */\n\n// =============================================================================\n// Content Types (used in both user and assistant messages)\n// =============================================================================\n\nexport interface TextContent {\n  type: \"text\";\n  text: string;\n}\n\nexport interface ThinkingContent {\n  type: \"thinking\";\n  thinking: string;\n}\n\nexport interface ToolUseContent {\n  type: \"tool_use\";\n  id: string;\n  name: string;\n  input: Record<string, unknown>;\n}\n\nexport interface ImageContent {\n  type: \"image\";\n  source: {\n    type: \"base64\";\n    media_type: string;\n    data: string;\n  };\n}\n\nexport type ContentItem =\n  | TextContent\n  | ThinkingContent\n  | ToolUseContent\n  | ImageContent;\n\n// =============================================================================\n// Token Usage\n// =============================================================================\n\nexport interface TokenUsage {\n  input_tokens: number;\n  output_tokens: number;\n  cache_creation_input_tokens?: number;\n  cache_read_input_tokens?: number;\n}\n\n// =============================================================================\n// Tool Result (embedded in user messages)\n// =============================================================================\n\n/** A single todo item from TodoWrite tool */\nexport interface TodoItem {\n  content: string;\n  status: \"pending\" | \"in_progress\" | \"completed\";\n  activeForm?: string;\n}\n\n/**\n * Tool use result object - shape varies by tool type.\n */\nexport interface ToolUseResultObject {\n  type?: \"text\" | \"image\";\n  /** Content for simple tool results */\n  content?: string;\n  /** Read tool result with file content */\n  file?: {\n    filePath?: string;\n    content?: string;\n    numLines?: number;\n    startLine?: number;\n    totalLines?: number;\n  };\n  /** Stdout for Bash tool results */\n  stdout?: string;\n  /** Stderr for Bash tool results */\n  stderr?: string;\n  /** Interruption flag for Bash */\n  interrupted?: boolean;\n  /** Image flag */\n  isImage?: boolean;\n  is_error?: boolean;\n  agentId?: string; // References agent-{agentId}.jsonl\n  /** For Glob results */\n  filenames?: string[];\n  durationMs?: number;\n  numFiles?: number;\n  truncated?: boolean;\n  /** For TodoWrite results */\n  oldTodos?: TodoItem[];\n  newTodos?: TodoItem[];\n  /** For WebFetch results */\n  result?: string;\n  url?: string;\n  bytes?: number;\n  code?: number;\n  /** For WebSearch results */\n  query?: string;\n  results?: Array<{ title?: string; url?: string; snippet?: string } | string>;\n  durationSeconds?: number;\n  /** For Task/Agent results - content array with text items */\n  // Note: content can be string (standard) or array (Task result)\n}\n\n/** Tool result can be an object or a plain error string */\nexport type ToolUseResult = ToolUseResultObject | string;\n\n// =============================================================================\n// Message Types\n// =============================================================================\n\n/** Base fields present in most message types */\ninterface BaseMessage {\n  timestamp: string;\n  sessionId: string;\n  uuid: string;\n  parentUuid: string | null;\n  isSidechain?: boolean;\n}\n\n/** User message - human prompts and tool results */\nexport interface UserMessage extends BaseMessage {\n  type: \"user\";\n  userType: \"human\" | \"external\";\n  cwd: string;\n  version?: string;\n  message: {\n    role: \"user\";\n    content: string | ContentItem[];\n  };\n  toolUseResult?: ToolUseResult;\n  /** Meta messages (caveats, system info) should not use input animation */\n  isMeta?: boolean;\n}\n\n/** Assistant message - Claude's responses */\nexport interface AssistantMessage extends BaseMessage {\n  type: \"assistant\";\n  requestId?: string;\n  message: {\n    id: string;\n    type: \"message\";\n    role: \"assistant\";\n    model: string;\n    content: ContentItem[];\n    stop_reason: \"end_turn\" | \"tool_use\" | null;\n    usage?: TokenUsage;\n  };\n  context_management?: {\n    type: \"compacted\";\n    original_tokens?: TokenUsage;\n    compacted_tokens?: TokenUsage;\n  };\n}\n\n/** System message - warnings, info, errors */\nexport interface SystemMessage {\n  type: \"system\";\n  timestamp: string;\n  content: string | null;\n  level?: \"warning\" | \"info\" | \"error\";\n}\n\n/** Summary message - auto-generated session summaries */\nexport interface SummaryMessage {\n  type: \"summary\";\n  summary: string;\n  leafUuid: string;\n  cwd?: string;\n}\n\n/** Queue operation message - internal message queueing */\nexport interface QueueOperationMessage {\n  type: \"queue-operation\";\n  operation: \"enqueue\" | \"dequeue\" | \"remove\" | \"popAll\";\n  timestamp: string;\n  sessionId?: string;\n  content?: string | ContentItem[];\n}\n\n/** File history snapshot - internal file backup metadata (skip rendering) */\nexport interface FileHistorySnapshotMessage {\n  type: \"file-history-snapshot\";\n  [key: string]: unknown;\n}\n\n/** Union of all message types */\nexport type TranscriptEntry =\n  | UserMessage\n  | AssistantMessage\n  | SystemMessage\n  | SummaryMessage\n  | QueueOperationMessage\n  | FileHistorySnapshotMessage;\n\n/** Get the type-safe message type */\nexport function getMessageType(\n  entry: TranscriptEntry\n): TranscriptEntry[\"type\"] {\n  return entry.type;\n}\n\n/** Type guard for user messages */\nexport function isUserMessage(entry: TranscriptEntry): entry is UserMessage {\n  return entry.type === \"user\";\n}\n\n/** Type guard for assistant messages */\nexport function isAssistantMessage(\n  entry: TranscriptEntry\n): entry is AssistantMessage {\n  return entry.type === \"assistant\";\n}\n\n/** Type guard for system messages */\nexport function isSystemMessage(\n  entry: TranscriptEntry\n): entry is SystemMessage {\n  return entry.type === \"system\";\n}\n\n/** Type guard for summary messages */\nexport function isSummaryMessage(\n  entry: TranscriptEntry\n): entry is SummaryMessage {\n  return entry.type === \"summary\";\n}\n\n/** Type guard for queue operation messages */\nexport function isQueueOperationMessage(\n  entry: TranscriptEntry\n): entry is QueueOperationMessage {\n  return entry.type === \"queue-operation\";\n}\n\n/** Type guard for file history snapshot messages */\nexport function isFileHistorySnapshotMessage(\n  entry: TranscriptEntry\n): entry is FileHistorySnapshotMessage {\n  return entry.type === \"file-history-snapshot\";\n}\n\n/** Check if message should be rendered (skip internal types) */\nexport function isRenderableMessage(\n  entry: TranscriptEntry\n): entry is UserMessage | AssistantMessage | SystemMessage {\n  return (\n    entry.type === \"user\" ||\n    entry.type === \"assistant\" ||\n    (entry.type === \"system\" && entry.content !== null)\n  );\n}\n","/**\n * asciicast v3 format types\n * Spec: https://docs.asciinema.org/manual/asciicast/v3/\n */\n\n// =============================================================================\n// Theme Configuration\n// =============================================================================\n\nexport interface AsciicastTheme {\n  fg: string;\n  bg: string;\n  palette: string; // Colon-separated 16 colors (ANSI 0-15)\n}\n\n/** Built-in theme presets */\nexport const THEMES: Record<string, AsciicastTheme> = {\n  \"tokyo-night\": {\n    fg: \"#a9b1d6\",\n    bg: \"#1a1b26\",\n    palette:\n      \"#15161e:#f7768e:#9ece6a:#e0af68:#7aa2f7:#bb9af7:#7dcfff:#a9b1d6:#414868:#f7768e:#9ece6a:#e0af68:#7aa2f7:#bb9af7:#7dcfff:#c0caf5\",\n  },\n  \"tokyo-storm\": {\n    fg: \"#a9b1d6\",\n    bg: \"#24283b\",\n    palette:\n      \"#1d202f:#f7768e:#9ece6a:#e0af68:#7aa2f7:#bb9af7:#7dcfff:#a9b1d6:#414868:#f7768e:#9ece6a:#e0af68:#7aa2f7:#bb9af7:#7dcfff:#c0caf5\",\n  },\n  dracula: {\n    fg: \"#f8f8f2\",\n    bg: \"#282a36\",\n    palette:\n      \"#21222c:#ff5555:#50fa7b:#f1fa8c:#bd93f9:#ff79c6:#8be9fd:#f8f8f2:#6272a4:#ff6e6e:#69ff94:#ffffa5:#d6acff:#ff92df:#a4ffff:#ffffff\",\n  },\n  nord: {\n    fg: \"#d8dee9\",\n    bg: \"#2e3440\",\n    palette:\n      \"#3b4252:#bf616a:#a3be8c:#ebcb8b:#81a1c1:#b48ead:#88c0d0:#e5e9f0:#4c566a:#bf616a:#a3be8c:#ebcb8b:#81a1c1:#b48ead:#8fbcbb:#eceff4\",\n  },\n  \"catppuccin-mocha\": {\n    fg: \"#cdd6f4\",\n    bg: \"#1e1e2e\",\n    palette:\n      \"#45475a:#f38ba8:#a6e3a1:#f9e2af:#89b4fa:#f5c2e7:#94e2d5:#bac2de:#585b70:#f38ba8:#a6e3a1:#f9e2af:#89b4fa:#f5c2e7:#94e2d5:#a6adc8\",\n  },\n};\n\n// =============================================================================\n// Semantic Colors (for rendering)\n// =============================================================================\n\nexport interface SemanticColors {\n  userPrompt: string;\n  assistantText: string;\n  toolName: string;\n  toolBulletSuccess: string;\n  toolBulletError: string;\n  thinking: string;\n  boxDrawing: string;\n  filePath: string;\n}\n\nexport const TOKYO_NIGHT_SEMANTIC: SemanticColors = {\n  userPrompt: \"#7aa2f7\", // Blue\n  assistantText: \"#a9b1d6\", // Foreground\n  toolName: \"#e0af68\", // Yellow\n  toolBulletSuccess: \"#9ece6a\", // Green\n  toolBulletError: \"#f7768e\", // Red\n  thinking: \"#565f89\", // Comment\n  boxDrawing: \"#414868\", // Bright black\n  filePath: \"#7dcfff\", // Cyan\n};\n\n// =============================================================================\n// asciicast v3 Header\n// =============================================================================\n\nexport interface AsciicastHeader {\n  version: 3;\n  term: {\n    cols: number;\n    rows: number;\n    type?: string;\n    theme?: AsciicastTheme;\n  };\n  timestamp?: number;\n  title?: string;\n  env?: Record<string, string>;\n}\n\n// =============================================================================\n// asciicast v3 Events\n// =============================================================================\n\n/** Output event - ANSI-encoded text */\nexport type OutputEvent = [number, \"o\", string];\n\n/** Marker event - navigation point */\nexport type MarkerEvent = [number, \"m\", string];\n\n/** Resize event - terminal dimension change */\nexport type ResizeEvent = [number, \"r\", string]; // \"cols x rows\"\n\nexport type AsciicastEvent = OutputEvent | MarkerEvent | ResizeEvent;\n\n// =============================================================================\n// Complete asciicast Document\n// =============================================================================\n\nexport interface AsciicastDocument {\n  header: AsciicastHeader;\n  events: AsciicastEvent[];\n}\n\n// =============================================================================\n// Timing Presets\n// =============================================================================\n\nexport interface TimingConfig {\n  /** Maximum pause between events (seconds) */\n  maxWait: number;\n  /** Pause before assistant response (seconds) */\n  thinkingPause: number;\n  /** Enable character-by-character typing effect */\n  typingEffect: boolean;\n  /** Characters per second when typing effect is enabled */\n  typingSpeed: number;\n}\n\nexport const TIMING_PRESETS: Record<string, TimingConfig> = {\n  speedrun: {\n    maxWait: 2,\n    thinkingPause: 0.3,\n    typingEffect: false,\n    typingSpeed: 80,\n  },\n  default: {\n    maxWait: 3,\n    thinkingPause: 0.8,\n    typingEffect: true,\n    typingSpeed: 60,\n  },\n  realtime: {\n    maxWait: Infinity,\n    thinkingPause: 0,\n    typingEffect: false,\n    typingSpeed: 0,\n  },\n};\n\n// =============================================================================\n// Marker Configuration\n// =============================================================================\n\nexport type MarkerMode = \"all\" | \"user\" | \"tools\" | \"none\";\n\nexport interface MarkerConfig {\n  mode: MarkerMode;\n  labelLength: number;\n  pauseOnMarkers: boolean;\n}\n\nexport const DEFAULT_MARKER_CONFIG: MarkerConfig = {\n  mode: \"all\",\n  labelLength: 30,\n  pauseOnMarkers: false,\n};\n","/**\n * JSONL file loader with agent file handling\n */\n\nimport { readFile } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport type { TranscriptEntry } from \"../types/messages.js\";\n\n/** Parse a single JSONL line into a typed message */\nexport function parseLine(line: string): TranscriptEntry | null {\n  const trimmed = line.trim();\n  if (!trimmed) return null;\n\n  try {\n    const parsed = JSON.parse(trimmed) as TranscriptEntry;\n    return parsed;\n  } catch {\n    // Silently skip malformed lines\n    return null;\n  }\n}\n\n/** Load and parse a JSONL transcript file */\nexport async function loadTranscript(\n  filePath: string,\n  options: {\n    loadAgents?: boolean;\n    agentCache?: Map<string, TranscriptEntry[]>;\n  } = {}\n): Promise<TranscriptEntry[]> {\n  const { loadAgents = true, agentCache = new Map() } = options;\n\n  const content = await readFile(filePath, \"utf-8\");\n  const lines = content.split(\"\\n\");\n  const entries: TranscriptEntry[] = [];\n\n  for (const line of lines) {\n    const entry = parseLine(line);\n    if (entry) {\n      entries.push(entry);\n\n      // Check for agent references in tool results\n      if (\n        loadAgents &&\n        entry.type === \"user\" &&\n        entry.toolUseResult &&\n        typeof entry.toolUseResult !== \"string\" &&\n        entry.toolUseResult.agentId\n      ) {\n        const agentId = entry.toolUseResult.agentId;\n\n        // Check cache first\n        if (!agentCache.has(agentId)) {\n          const agentPath = join(dirname(filePath), `agent-${agentId}.jsonl`);\n          try {\n            const agentEntries = await loadTranscript(agentPath, {\n              loadAgents: true,\n              agentCache,\n            });\n            agentCache.set(agentId, agentEntries);\n          } catch {\n            // Agent file may not exist or be inaccessible\n            agentCache.set(agentId, []);\n          }\n        }\n\n        // Mark agent entries as sidechain and insert after parent\n        const agentEntries = agentCache.get(agentId) ?? [];\n        for (const agentEntry of agentEntries) {\n          if (\"isSidechain\" in agentEntry) {\n            (agentEntry as { isSidechain: boolean }).isSidechain = true;\n          }\n          entries.push(agentEntry);\n        }\n      }\n    }\n  }\n\n  // Interleave parallel tool calls with their results for logical ordering\n  return interleaveToolCallsAndResults(entries);\n}\n\n/** Sort entries chronologically by timestamp */\nexport function sortByTimestamp(entries: TranscriptEntry[]): TranscriptEntry[] {\n  return [...entries].sort((a, b) => {\n    const aTime = getTimestamp(a)?.getTime() ?? 0;\n    const bTime = getTimestamp(b)?.getTime() ?? 0;\n    return aTime - bTime;\n  });\n}\n\n/** Get timestamp from entry (if available) */\nexport function getTimestamp(entry: TranscriptEntry): Date | null {\n  if (\n    \"timestamp\" in entry &&\n    typeof entry.timestamp === \"string\" &&\n    entry.timestamp\n  ) {\n    return new Date(entry.timestamp);\n  }\n  return null;\n}\n\n/** Get UUID from entry (if available) */\nexport function getUuid(entry: TranscriptEntry): string | null {\n  if (\"uuid\" in entry && typeof entry.uuid === \"string\" && entry.uuid) {\n    return entry.uuid;\n  }\n  return null;\n}\n\n/** Check if an assistant message contains a tool call */\nfunction isToolCallMessage(entry: TranscriptEntry): boolean {\n  if (entry.type !== \"assistant\") return false;\n  const content = entry.message?.content;\n  if (!Array.isArray(content)) return false;\n  return content.some((item) => item.type === \"tool_use\");\n}\n\n/** Check if a user message is a tool result */\nfunction isToolResultMessage(entry: TranscriptEntry): boolean {\n  if (entry.type !== \"user\") return false;\n  return entry.toolUseResult !== undefined;\n}\n\n/**\n * Interleave parallel tool calls with their results.\n *\n * When Claude makes parallel tool calls, the JSONL stores them as:\n *   [call1, call2, call3, result1, result2, result3]\n *\n * This function reorders to logical conversation flow:\n *   [call1, result1, call2, result2, call3, result3]\n *\n * Detection: consecutive assistant messages with tool_use content,\n * followed by consecutive user messages with toolUseResult.\n * The results match calls by position (first result → first call, etc).\n */\nexport function interleaveToolCallsAndResults(\n  entries: TranscriptEntry[]\n): TranscriptEntry[] {\n  const result: TranscriptEntry[] = [];\n  let i = 0;\n\n  while (i < entries.length) {\n    // Collect consecutive tool calls\n    const toolCalls: TranscriptEntry[] = [];\n    while (i < entries.length && isToolCallMessage(entries[i]!)) {\n      toolCalls.push(entries[i]!);\n      i++;\n    }\n\n    // Collect consecutive tool results\n    const toolResults: TranscriptEntry[] = [];\n    while (i < entries.length && isToolResultMessage(entries[i]!)) {\n      toolResults.push(entries[i]!);\n      i++;\n    }\n\n    // Interleave if we have matching calls and results\n    if (toolCalls.length > 0 && toolResults.length > 0) {\n      const maxPairs = Math.min(toolCalls.length, toolResults.length);\n      for (let j = 0; j < maxPairs; j++) {\n        result.push(toolCalls[j]!);\n        result.push(toolResults[j]!);\n      }\n      // Add any remaining unmatched entries\n      for (let j = maxPairs; j < toolCalls.length; j++) {\n        result.push(toolCalls[j]!);\n      }\n      for (let j = maxPairs; j < toolResults.length; j++) {\n        result.push(toolResults[j]!);\n      }\n    } else {\n      // No interleaving needed, add as-is\n      for (const call of toolCalls) {\n        result.push(call);\n      }\n      for (const res of toolResults) {\n        result.push(res);\n      }\n    }\n\n    // If we didn't collect any tool calls or results, add the current entry\n    if (toolCalls.length === 0 && toolResults.length === 0 && i < entries.length) {\n      result.push(entries[i]!);\n      i++;\n    }\n  }\n\n  return result;\n}\n","/**\n * Clip extraction - filter messages by UUID range, timestamp range, or last N\n */\n\nimport type { TranscriptEntry } from \"../types/messages.js\";\nimport { getTimestamp, getUuid, sortByTimestamp } from \"./loader.js\";\n\nexport interface ClipOptions {\n  /** Start extraction from this message UUID (inclusive) */\n  startUuid?: string;\n  /** End extraction at this message UUID (inclusive) */\n  endUuid?: string;\n  /** Start extraction from this timestamp (ISO 8601) */\n  startTime?: string;\n  /** End extraction at this timestamp (ISO 8601) */\n  endTime?: string;\n  /** Extract last N messages */\n  last?: number;\n}\n\n/**\n * Extract a clip from transcript entries based on filtering options\n *\n * Priority:\n * 1. If `last` is specified, return the last N renderable messages\n * 2. If UUID range is specified, extract messages between start and end UUID\n * 3. If time range is specified, extract messages within time range\n * 4. If no options, return all entries\n */\nexport function extractClip(\n  entries: TranscriptEntry[],\n  options: ClipOptions = {}\n): TranscriptEntry[] {\n  const { startUuid, endUuid, startTime, endTime, last } = options;\n\n  // Sort by timestamp for consistent ordering\n  let sorted = sortByTimestamp(entries);\n\n  // Handle --last N option (highest priority)\n  if (last !== undefined) {\n    if (last <= 0) {\n      return [];\n    }\n    // Filter to renderable messages only for counting\n    const renderable = sorted.filter(isRenderableForClip);\n    const startIndex = Math.max(0, renderable.length - last);\n    return renderable.slice(startIndex);\n  }\n\n  // Handle UUID range filtering\n  if (startUuid || endUuid) {\n    sorted = filterByUuidRange(sorted, startUuid, endUuid);\n  }\n\n  // Handle time range filtering\n  if (startTime || endTime) {\n    sorted = filterByTimeRange(sorted, startTime, endTime);\n  }\n\n  return sorted;\n}\n\n/** Filter entries by UUID range (inclusive) */\nfunction filterByUuidRange(\n  entries: TranscriptEntry[],\n  startUuid?: string,\n  endUuid?: string\n): TranscriptEntry[] {\n  let startIndex = 0;\n  let endIndex = entries.length;\n\n  if (startUuid) {\n    const idx = entries.findIndex((e) => getUuid(e) === startUuid);\n    if (idx !== -1) {\n      startIndex = idx;\n    }\n  }\n\n  if (endUuid) {\n    const idx = entries.findIndex((e) => getUuid(e) === endUuid);\n    if (idx !== -1) {\n      endIndex = idx + 1; // inclusive\n    }\n  }\n\n  return entries.slice(startIndex, endIndex);\n}\n\n/** Filter entries by time range (inclusive) */\nfunction filterByTimeRange(\n  entries: TranscriptEntry[],\n  startTime?: string,\n  endTime?: string\n): TranscriptEntry[] {\n  const startDate = startTime ? new Date(startTime) : null;\n  const endDate = endTime ? new Date(endTime) : null;\n\n  return entries.filter((entry) => {\n    const timestamp = getTimestamp(entry);\n    if (!timestamp) return true; // Include entries without timestamps\n\n    if (startDate && timestamp < startDate) return false;\n    if (endDate && timestamp > endDate) return false;\n\n    return true;\n  });\n}\n\n/** Check if an entry should be counted for clip extraction */\nfunction isRenderableForClip(entry: TranscriptEntry): boolean {\n  switch (entry.type) {\n    case \"user\":\n    case \"assistant\":\n      return true;\n    case \"system\":\n      return entry.content !== null;\n    case \"queue-operation\":\n      // Include 'remove' operations as they represent user steering\n      return entry.operation === \"remove\";\n    case \"summary\":\n    case \"file-history-snapshot\":\n      return false;\n    default:\n      return false;\n  }\n}\n\n/** Get summary of clip for display */\nexport function getClipSummary(entries: TranscriptEntry[]): {\n  total: number;\n  user: number;\n  assistant: number;\n  tools: number;\n  startTime: Date | null;\n  endTime: Date | null;\n} {\n  let user = 0;\n  let assistant = 0;\n  let tools = 0;\n  let startTime: Date | null = null;\n  let endTime: Date | null = null;\n\n  for (const entry of entries) {\n    const timestamp = getTimestamp(entry);\n\n    if (timestamp) {\n      if (!startTime || timestamp < startTime) startTime = timestamp;\n      if (!endTime || timestamp > endTime) endTime = timestamp;\n    }\n\n    if (entry.type === \"user\") {\n      if (entry.toolUseResult) {\n        tools++;\n      } else {\n        user++;\n      }\n    } else if (entry.type === \"assistant\") {\n      assistant++;\n    }\n  }\n\n  return {\n    total: entries.length,\n    user,\n    assistant,\n    tools,\n    startTime,\n    endTime,\n  };\n}\n","/**\n * ANSI escape code utilities for terminal rendering\n * Provides 24-bit color support, text styling, and word wrapping with hard-breaking\n */\n\n// =============================================================================\n// ANSI Escape Sequences\n// =============================================================================\n\nconst ESC = \"\\x1b\";\nconst CSI = `${ESC}[`;\n\n/** Reset all styling */\nexport const RESET = `${CSI}0m`;\n\n// =============================================================================\n// Text Styles\n// =============================================================================\n\nexport const BOLD = `${CSI}1m`;\nexport const DIM = `${CSI}2m`;\nexport const ITALIC = `${CSI}3m`;\nexport const UNDERLINE = `${CSI}4m`;\n\nexport const STRIKETHROUGH = `${CSI}9m`;\n\nexport const RESET_BOLD = `${CSI}22m`;\nexport const RESET_DIM = `${CSI}22m`;\nexport const RESET_ITALIC = `${CSI}23m`;\nexport const RESET_UNDERLINE = `${CSI}24m`;\nexport const RESET_STRIKETHROUGH = `${CSI}29m`;\n\n// =============================================================================\n// 24-bit Color Functions\n// =============================================================================\n\n/** Parse hex color to RGB tuple */\nexport function hexToRgb(hex: string): [number, number, number] {\n  const clean = hex.replace(\"#\", \"\");\n  const r = parseInt(clean.substring(0, 2), 16);\n  const g = parseInt(clean.substring(2, 4), 16);\n  const b = parseInt(clean.substring(4, 6), 16);\n  return [r, g, b];\n}\n\n/** Set foreground color using 24-bit RGB */\nexport function fg(hex: string): string {\n  const [r, g, b] = hexToRgb(hex);\n  return `${CSI}38;2;${r};${g};${b}m`;\n}\n\n/** Set background color using 24-bit RGB */\nexport function bg(hex: string): string {\n  const [r, g, b] = hexToRgb(hex);\n  return `${CSI}48;2;${r};${g};${b}m`;\n}\n\n/** Apply foreground color to text and reset */\nexport function colorize(text: string, hex: string): string {\n  return `${fg(hex)}${text}${RESET}`;\n}\n\n/** Apply foreground color and style to text */\nexport function style(\n  text: string,\n  options: {\n    fg?: string;\n    bg?: string;\n    bold?: boolean;\n    dim?: boolean;\n    italic?: boolean;\n  }\n): string {\n  let prefix = \"\";\n  const suffix = RESET;\n\n  if (options.bold) prefix += BOLD;\n  if (options.dim) prefix += DIM;\n  if (options.italic) prefix += ITALIC;\n  if (options.fg) prefix += fg(options.fg);\n  if (options.bg) prefix += bg(options.bg);\n\n  return `${prefix}${text}${suffix}`;\n}\n\n// =============================================================================\n// Box Drawing Characters\n// =============================================================================\n\nexport const BOX = {\n  // Single line\n  horizontal: \"─\",\n  vertical: \"│\",\n  topLeft: \"┌\",\n  topRight: \"┐\",\n  bottomLeft: \"└\",\n  bottomRight: \"┘\",\n  teeRight: \"├\",\n  teeLeft: \"┤\",\n  teeDown: \"┬\",\n  teeUp: \"┴\",\n  cross: \"┼\",\n\n  // Rounded corners\n  roundTopLeft: \"╭\",\n  roundTopRight: \"╮\",\n  roundBottomLeft: \"╰\",\n  roundBottomRight: \"╯\",\n\n  // Double line\n  doubleHorizontal: \"═\",\n  doubleVertical: \"║\",\n\n  // Bullets and markers\n  bullet: \"●\",\n  bulletHollow: \"○\",\n  check: \"✓\",\n  crossMark: \"✗\",\n  arrow: \"→\",\n  arrowDown: \"↓\",\n  arrowSubagent: \"⤵\",\n  indent: \"⎿\",\n} as const;\n\n// =============================================================================\n// Text Manipulation\n// =============================================================================\n\n/** Wrap text to specified width, preserving words when possible, hard-breaking when necessary */\nexport function wordWrap(text: string, width: number): string[] {\n  if (width <= 0) return [text];\n\n  const lines: string[] = [];\n  const paragraphs = text.split(\"\\n\");\n\n  for (const paragraph of paragraphs) {\n    if (paragraph.length <= width) {\n      lines.push(paragraph);\n      continue;\n    }\n\n    const words = paragraph.split(/\\s+/);\n    let currentLine = \"\";\n\n    for (const word of words) {\n      // Handle words longer than width - hard break them\n      if (word.length > width) {\n        // First, flush current line if any\n        if (currentLine.length > 0) {\n          lines.push(currentLine);\n          currentLine = \"\";\n        }\n        // Break long word into chunks\n        for (let i = 0; i < word.length; i += width) {\n          lines.push(word.slice(i, i + width));\n        }\n        continue;\n      }\n\n      if (currentLine.length === 0) {\n        currentLine = word;\n      } else if (currentLine.length + 1 + word.length <= width) {\n        currentLine += \" \" + word;\n      } else {\n        lines.push(currentLine);\n        currentLine = word;\n      }\n    }\n\n    if (currentLine.length > 0) {\n      lines.push(currentLine);\n    }\n  }\n\n  return lines;\n}\n\n/** Truncate text with ellipsis */\nexport function truncate(text: string, maxLength: number): string {\n  if (text.length <= maxLength) return text;\n  return text.substring(0, maxLength - 1) + \"…\";\n}\n\n/** Indent each line of text */\nexport function indent(text: string, spaces: number): string {\n  const prefix = \" \".repeat(spaces);\n  return text\n    .split(\"\\n\")\n    .map((line) => prefix + line)\n    .join(\"\\n\");\n}\n\n/** Remove ANSI escape codes for length calculation */\nexport function stripAnsi(text: string): string {\n  // eslint-disable-next-line no-control-regex\n  return text.replace(/\\x1b\\[[0-9;]*m/g, \"\");\n}\n\n/** Get visible length of text (excluding ANSI codes) */\nexport function visibleLength(text: string): number {\n  return stripAnsi(text).length;\n}\n\n// =============================================================================\n// Line Building Helpers\n// =============================================================================\n\n/** Create a horizontal rule */\nexport function horizontalRule(width: number, color?: string): string {\n  const line = BOX.horizontal.repeat(width);\n  return color ? colorize(line, color) : line;\n}\n\n// =============================================================================\n// Cursor Control\n// =============================================================================\n\n/** Save cursor position */\nexport function saveCursor(): string {\n  return `${CSI}s`;\n}\n\n/** Restore cursor position */\nexport function restoreCursor(): string {\n  return `${CSI}u`;\n}\n\n/** Move cursor to row, col (1-indexed) */\nexport function moveTo(row: number, col: number = 1): string {\n  return `${CSI}${row};${col}H`;\n}\n\n/** Move cursor to column (1-indexed) */\nexport function moveToCol(col: number): string {\n  return `${CSI}${col}G`;\n}\n\n/** Erase from cursor to end of line */\nexport function eraseToEndOfLine(): string {\n  return `${CSI}K`;\n}\n\n/** Erase entire line */\nexport function eraseLine(): string {\n  return `${CSI}2K`;\n}\n\n/** Set scroll region (top and bottom rows, 1-indexed) */\nexport function setScrollRegion(top: number, bottom: number): string {\n  return `${CSI}${top};${bottom}r`;\n}\n\n/** Reset scroll region to full terminal */\nexport function resetScrollRegion(): string {\n  return `${CSI}r`;\n}\n\n// =============================================================================\n// Box Drawing\n// =============================================================================\n\n/** Create a box around text */\nexport function box(\n  content: string,\n  options: {\n    width?: number;\n    borderColor?: string;\n    rounded?: boolean;\n  } = {}\n): string {\n  const { width = 80, borderColor, rounded = false } = options;\n  const lines = content.split(\"\\n\");\n  const innerWidth = width - 4; // 2 for borders, 2 for padding\n\n  const tl = rounded ? BOX.roundTopLeft : BOX.topLeft;\n  const tr = rounded ? BOX.roundTopRight : BOX.topRight;\n  const bl = rounded ? BOX.roundBottomLeft : BOX.bottomLeft;\n  const br = rounded ? BOX.roundBottomRight : BOX.bottomRight;\n\n  const colorFn = borderColor ? (s: string) => colorize(s, borderColor) : (s: string) => s;\n\n  const top = colorFn(tl + BOX.horizontal.repeat(width - 2) + tr);\n  const bottom = colorFn(bl + BOX.horizontal.repeat(width - 2) + br);\n\n  const wrappedLines: string[] = [];\n  for (const line of lines) {\n    const wrapped = wordWrap(line, innerWidth);\n    wrappedLines.push(...wrapped);\n  }\n\n  const middle = wrappedLines.map((line) => {\n    const padding = \" \".repeat(Math.max(0, innerWidth - visibleLength(line)));\n    return colorFn(BOX.vertical) + \" \" + line + padding + \" \" + colorFn(BOX.vertical);\n  });\n\n  return [top, ...middle, bottom].join(\"\\n\");\n}\n","/**\n * Theme configuration for rendering\n * Provides semantic colors for different message types\n */\n\nimport { THEMES, type AsciicastTheme } from \"../types/asciicast.js\";\n\n/** Semantic colors for message rendering */\nexport interface RenderTheme {\n  /** Terminal foreground */\n  fg: string;\n  /** Terminal background */\n  bg: string;\n  /** User prompt prefix and text */\n  userPrompt: string;\n  /** User prompt background color */\n  userPromptBg: string;\n  /** Assistant response text */\n  assistantText: string;\n  /** Tool name in tool calls */\n  toolName: string;\n  /** Success bullet for tool calls */\n  toolBulletSuccess: string;\n  /** Error bullet for failed tool calls */\n  toolBulletError: string;\n  /** Thinking block text (dimmed) */\n  thinking: string;\n  /** Box drawing characters */\n  boxDrawing: string;\n  /** File paths in tool calls */\n  filePath: string;\n  /** Muted/secondary text */\n  muted: string;\n  /** Agent/sidechain indicator */\n  agent: string;\n  /** Diff: line background for additions */\n  diffAddLineBg: string;\n  /** Diff: character background for changed chars in additions */\n  diffAddCharBg: string;\n  /** Diff: line background for removals */\n  diffRemoveLineBg: string;\n  /** Diff: character background for changed chars in removals */\n  diffRemoveCharBg: string;\n}\n\n/** Tokyo Night theme (default) */\nexport const TOKYO_NIGHT: RenderTheme = {\n  fg: \"#a9b1d6\",\n  bg: \"#1a1b26\",\n  userPrompt: \"#7aa2f7\",\n  userPromptBg: \"#373737\",\n  assistantText: \"#a9b1d6\",\n  toolName: \"#e0af68\",\n  toolBulletSuccess: \"#9ece6a\",\n  toolBulletError: \"#f7768e\",\n  thinking: \"#565f89\",\n  boxDrawing: \"#414868\",\n  filePath: \"#7dcfff\",\n  muted: \"#565f89\",\n  agent: \"#bb9af7\",\n  diffAddLineBg: \"#225c2b\",\n  diffAddCharBg: \"#38a660\",\n  diffRemoveLineBg: \"#5c2b2b\",\n  diffRemoveCharBg: \"#a63838\",\n};\n\n/** Tokyo Storm theme */\nexport const TOKYO_STORM: RenderTheme = {\n  ...TOKYO_NIGHT,\n  bg: \"#24283b\",\n};\n\n/** Dracula theme */\nexport const DRACULA: RenderTheme = {\n  fg: \"#f8f8f2\",\n  bg: \"#282a36\",\n  userPrompt: \"#8be9fd\",\n  userPromptBg: \"#373737\",\n  assistantText: \"#f8f8f2\",\n  toolName: \"#f1fa8c\",\n  toolBulletSuccess: \"#50fa7b\",\n  toolBulletError: \"#ff5555\",\n  thinking: \"#6272a4\",\n  boxDrawing: \"#44475a\",\n  filePath: \"#ff79c6\",\n  muted: \"#6272a4\",\n  agent: \"#bd93f9\",\n  diffAddLineBg: \"#1e4620\",\n  diffAddCharBg: \"#2e7d32\",\n  diffRemoveLineBg: \"#4a1e1e\",\n  diffRemoveCharBg: \"#8b2e2e\",\n};\n\n/** Nord theme */\nexport const NORD: RenderTheme = {\n  fg: \"#d8dee9\",\n  bg: \"#2e3440\",\n  userPrompt: \"#81a1c1\",\n  userPromptBg: \"#373737\",\n  assistantText: \"#d8dee9\",\n  toolName: \"#ebcb8b\",\n  toolBulletSuccess: \"#a3be8c\",\n  toolBulletError: \"#bf616a\",\n  thinking: \"#4c566a\",\n  boxDrawing: \"#3b4252\",\n  filePath: \"#88c0d0\",\n  muted: \"#4c566a\",\n  agent: \"#b48ead\",\n  diffAddLineBg: \"#2e4a3a\",\n  diffAddCharBg: \"#4a7a5c\",\n  diffRemoveLineBg: \"#4a2e2e\",\n  diffRemoveCharBg: \"#7a4a4a\",\n};\n\n/** Catppuccin Mocha theme */\nexport const CATPPUCCIN_MOCHA: RenderTheme = {\n  fg: \"#cdd6f4\",\n  bg: \"#1e1e2e\",\n  userPrompt: \"#89b4fa\",\n  userPromptBg: \"#373737\",\n  assistantText: \"#cdd6f4\",\n  toolName: \"#f9e2af\",\n  toolBulletSuccess: \"#a6e3a1\",\n  toolBulletError: \"#f38ba8\",\n  thinking: \"#585b70\",\n  boxDrawing: \"#45475a\",\n  filePath: \"#94e2d5\",\n  muted: \"#585b70\",\n  agent: \"#f5c2e7\",\n  diffAddLineBg: \"#264a35\",\n  diffAddCharBg: \"#40a060\",\n  diffRemoveLineBg: \"#4a2635\",\n  diffRemoveCharBg: \"#a04050\",\n};\n\n/** All available render themes */\nexport const RENDER_THEMES: Record<string, RenderTheme> = {\n  \"tokyo-night\": TOKYO_NIGHT,\n  \"tokyo-storm\": TOKYO_STORM,\n  dracula: DRACULA,\n  nord: NORD,\n  \"catppuccin-mocha\": CATPPUCCIN_MOCHA,\n};\n\n/** Get render theme by name, defaulting to tokyo-night */\nexport function getTheme(name: string): RenderTheme {\n  return RENDER_THEMES[name] ?? TOKYO_NIGHT;\n}\n\n/** Convert render theme to asciicast theme for embedding */\nexport function toAsciicastTheme(theme: RenderTheme): AsciicastTheme {\n  const name = Object.entries(RENDER_THEMES).find(\n    ([, t]) => t === theme\n  )?.[0];\n\n  if (name && THEMES[name]) {\n    return THEMES[name];\n  }\n\n  // Generate palette from theme colors\n  // ANSI colors 0-7: black, red, green, yellow, blue, magenta, cyan, white\n  // ANSI colors 8-15: bright variants\n  const palette = [\n    theme.bg, // black (background)\n    theme.toolBulletError, // red\n    theme.toolBulletSuccess, // green\n    theme.toolName, // yellow\n    theme.userPrompt, // blue\n    theme.agent, // magenta\n    theme.filePath, // cyan\n    theme.fg, // white (foreground)\n    theme.muted, // bright black\n    theme.toolBulletError, // bright red\n    theme.toolBulletSuccess, // bright green\n    theme.toolName, // bright yellow\n    theme.userPrompt, // bright blue\n    theme.agent, // bright magenta\n    theme.filePath, // bright cyan\n    theme.assistantText, // bright white\n  ].join(\":\");\n\n  return {\n    fg: theme.fg,\n    bg: theme.bg,\n    palette,\n  };\n}\n","/**\n * Content normalization utilities for rendering\n * Handles extraction and formatting of message content\n */\n\nimport type {\n  ContentItem,\n  TextContent,\n  ThinkingContent,\n  ToolUseContent,\n  AssistantMessage,\n  UserMessage,\n} from \"../types/messages.js\";\n\n// =============================================================================\n// Content Extraction\n// =============================================================================\n\n/** Extract all text content from a ContentItem array */\nexport function extractText(content: string | ContentItem[]): string {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  return content\n    .filter((item): item is TextContent => item.type === \"text\")\n    .map((item) => item.text)\n    .join(\"\\n\");\n}\n\n/** Extract thinking content from a ContentItem array */\nexport function extractThinking(content: ContentItem[]): string[] {\n  return content\n    .filter((item): item is ThinkingContent => item.type === \"thinking\")\n    .map((item) => item.thinking);\n}\n\n/** Extract tool use items from a ContentItem array */\nexport function extractToolUse(content: ContentItem[]): ToolUseContent[] {\n  return content.filter(\n    (item): item is ToolUseContent => item.type === \"tool_use\"\n  );\n}\n\n/** Check if content contains any tool use */\nexport function hasToolUse(content: ContentItem[]): boolean {\n  return content.some((item) => item.type === \"tool_use\");\n}\n\n/** Check if content contains thinking */\nexport function hasThinking(content: ContentItem[]): boolean {\n  return content.some((item) => item.type === \"thinking\");\n}\n\n// =============================================================================\n// Content Classification\n// =============================================================================\n\nexport type ContentCategory = \"text\" | \"tool-call\" | \"tool-result\" | \"thinking\" | \"mixed\";\n\n/** Classify what type of content a message contains */\nexport function classifyContent(content: ContentItem[]): ContentCategory {\n  const types = new Set(content.map((item) => item.type));\n\n  if (types.size === 0) return \"text\";\n  if (types.size === 1) {\n    if (types.has(\"text\")) return \"text\";\n    if (types.has(\"thinking\")) return \"thinking\";\n    if (types.has(\"tool_use\")) return \"tool-call\";\n  }\n\n  return \"mixed\";\n}\n\n// =============================================================================\n// Message Analysis\n// =============================================================================\n\n/** Get a summary label for a user message */\nexport function getUserMessageLabel(msg: UserMessage, maxLength = 30): string {\n  if (msg.toolUseResult) {\n    // String results are errors, object results check is_error flag\n    if (typeof msg.toolUseResult === \"string\") {\n      return \"Tool error\";\n    }\n    return msg.toolUseResult.is_error ? \"Tool error\" : \"Tool result\";\n  }\n\n  const text = extractText(msg.message.content);\n  if (text.length <= maxLength) {\n    return text.replace(/\\n/g, \" \");\n  }\n\n  return text.substring(0, maxLength - 1).replace(/\\n/g, \" \") + \"…\";\n}\n\n/** Get a summary label for an assistant message */\nexport function getAssistantMessageLabel(\n  msg: AssistantMessage,\n  maxLength = 30\n): string {\n  const content = msg.message.content;\n\n  // If it's primarily a tool call, describe the tool\n  const tools = extractToolUse(content);\n  if (tools.length > 0) {\n    const firstTool = tools[0]!;\n    if (tools.length === 1) {\n      return `${firstTool.name}`;\n    }\n    return `${firstTool.name} (+${tools.length - 1} more)`;\n  }\n\n  // Otherwise, use the text content\n  const text = extractText(content);\n  if (text.length <= maxLength) {\n    return text.replace(/\\n/g, \" \");\n  }\n\n  return text.substring(0, maxLength - 1).replace(/\\n/g, \" \") + \"…\";\n}\n\n// =============================================================================\n// Tool Input Formatting\n// =============================================================================\n\n/** Get a short description of tool input for display */\nexport function formatToolInputSummary(tool: ToolUseContent): string {\n  const { name, input } = tool;\n\n  switch (name) {\n    case \"Read\":\n    case \"Write\":\n    case \"Edit\":\n    case \"MultiEdit\":\n      if (typeof input[\"file_path\"] === \"string\") {\n        return input[\"file_path\"];\n      }\n      break;\n\n    case \"Bash\":\n      if (typeof input[\"command\"] === \"string\") {\n        const cmd = input[\"command\"];\n        return cmd.length > 50 ? cmd.substring(0, 49) + \"…\" : cmd;\n      }\n      break;\n\n    case \"Glob\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        return input[\"pattern\"];\n      }\n      break;\n\n    case \"Grep\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        return `/${input[\"pattern\"]}/`;\n      }\n      break;\n\n    case \"Task\":\n      if (typeof input[\"description\"] === \"string\") {\n        return input[\"description\"];\n      }\n      if (typeof input[\"prompt\"] === \"string\") {\n        const prompt = input[\"prompt\"];\n        return prompt.length > 50 ? prompt.substring(0, 49) + \"…\" : prompt;\n      }\n      break;\n\n    case \"WebFetch\":\n      if (typeof input[\"url\"] === \"string\") {\n        return input[\"url\"];\n      }\n      break;\n\n    case \"WebSearch\":\n      if (typeof input[\"query\"] === \"string\") {\n        return input[\"query\"];\n      }\n      break;\n\n    case \"TodoWrite\":\n      if (Array.isArray(input[\"todos\"])) {\n        return `${input[\"todos\"].length} items`;\n      }\n      break;\n  }\n\n  return \"\";\n}\n\n// =============================================================================\n// Output Truncation\n// =============================================================================\n\n/** Truncate multi-line output with line count indicator */\nexport function truncateOutput(\n  text: string,\n  maxLines: number,\n  maxLineLength = 200\n): { text: string; truncated: boolean; hiddenLines: number } {\n  const lines = text.split(\"\\n\");\n\n  // Truncate individual lines that are too long\n  const truncatedLines = lines.map((line) =>\n    line.length > maxLineLength\n      ? line.substring(0, maxLineLength - 1) + \"…\"\n      : line\n  );\n\n  if (truncatedLines.length <= maxLines) {\n    return {\n      text: truncatedLines.join(\"\\n\"),\n      truncated: false,\n      hiddenLines: 0,\n    };\n  }\n\n  return {\n    text: truncatedLines.slice(0, maxLines).join(\"\\n\"),\n    truncated: true,\n    hiddenLines: truncatedLines.length - maxLines,\n  };\n}\n","/**\n * Todo list visualization for TodoWrite tool results\n * Renders todo items with status indicators, tree connectors, and styling\n */\n\nimport {\n  indent,\n  fg,\n  RESET,\n  BOLD,\n  RESET_BOLD,\n  STRIKETHROUGH,\n  RESET_STRIKETHROUGH,\n  wordWrap,\n} from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\nimport type { TodoItem } from \"../types/messages.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** TodoWrite tool result with old and new state */\nexport interface TodoWriteToolResult {\n  oldTodos?: TodoItem[];\n  newTodos: TodoItem[];\n}\n\n/** Configuration for todo list rendering */\nexport interface TodoRenderConfig {\n  theme: RenderTheme;\n  indentSize: number;\n  width: number;\n}\n\n// =============================================================================\n// Unicode Characters\n// =============================================================================\n\nconst TODO_CHARS = {\n  /** Unchecked ballot box (pending/in_progress) */\n  unchecked: \"\\u2610\", // ☐\n  /** Checked ballot box with X (completed) */\n  checked: \"\\u2612\", // ☒\n  /** Tree connector for first item */\n  treeConnector: \"\\u23BF\", // ⎿\n} as const;\n\n// =============================================================================\n// Type Guard\n// =============================================================================\n\n/**\n * Check if a tool result is a TodoWrite result with todo items\n */\nexport function isTodoWriteToolResult(result: unknown): result is TodoWriteToolResult {\n  if (typeof result !== \"object\" || result === null) return false;\n  const r = result as Record<string, unknown>;\n  return Array.isArray(r.newTodos) && r.newTodos.length > 0;\n}\n\n// =============================================================================\n// Main Renderer\n// =============================================================================\n\n/**\n * Render a TodoWrite tool result as a styled todo list\n */\nexport function renderTodoList(result: TodoWriteToolResult, cfg: TodoRenderConfig): string {\n  return renderTodos(result.newTodos, cfg);\n}\n\n/**\n * Render todos from tool call input (input.todos array)\n */\nexport function renderTodosFromInput(\n  input: Record<string, unknown>,\n  cfg: TodoRenderConfig\n): string | null {\n  if (!Array.isArray(input.todos) || input.todos.length === 0) {\n    return null;\n  }\n  return renderTodos(input.todos as TodoItem[], cfg);\n}\n\n/**\n * Core renderer for a list of todo items\n */\nfunction renderTodos(todos: TodoItem[], cfg: TodoRenderConfig): string {\n  const { theme, indentSize, width } = cfg;\n  const output: string[] = [];\n\n  // Prefix chars: \"⎿  \" or \"   \" = 3 chars, plus checkbox \"☐ \" = 2 chars = 5 total\n  // Available width for content = width - indentSize - 5\n  const prefixLen = 3; // tree connector/spaces\n  const checkboxLen = 2; // \"☐ \" or \"☒ \"\n  const contentWidth = width - indentSize - prefixLen - checkboxLen;\n\n  for (let i = 0; i < todos.length; i++) {\n    const todo = todos[i];\n    const isFirst = i === 0;\n\n    // Build the prefix: tree connector for first, spaces for rest\n    // Format: \"⎿  \" for first, \"   \" for rest (indentSize handles base indent)\n    const prefix = isFirst\n      ? `${TODO_CHARS.treeConnector}  `\n      : \"   \";\n\n    // Render the todo item based on status, with word wrapping\n    const itemLines = renderTodoItem(todo, theme, contentWidth);\n\n    // First line gets the prefix, continuation lines get spaces\n    for (let j = 0; j < itemLines.length; j++) {\n      const linePrefix = j === 0 ? prefix : \"   \";\n      output.push(indent(linePrefix + itemLines[j], indentSize));\n    }\n  }\n\n  return output.join(\"\\n\");\n}\n\n// =============================================================================\n// Item Rendering\n// =============================================================================\n\n/**\n * Render a single todo item with appropriate styling, returning wrapped lines\n */\nfunction renderTodoItem(todo: TodoItem, theme: RenderTheme, contentWidth: number): string[] {\n  switch (todo.status) {\n    case \"completed\":\n      return renderCompletedTodo(todo, theme, contentWidth);\n    case \"in_progress\":\n      return renderInProgressTodo(todo, theme, contentWidth);\n    case \"pending\":\n    default:\n      return renderPendingTodo(todo, theme, contentWidth);\n  }\n}\n\n/**\n * Render a pending todo: ☐ content (no special styling)\n */\nfunction renderPendingTodo(todo: TodoItem, _theme: RenderTheme, contentWidth: number): string[] {\n  const lines = wordWrap(todo.content, contentWidth);\n  return lines.map((line, i) =>\n    i === 0 ? `${TODO_CHARS.unchecked} ${line}` : `  ${line}`\n  );\n}\n\n/**\n * Render an in-progress todo: ☐ **content** (bold text)\n */\nfunction renderInProgressTodo(todo: TodoItem, _theme: RenderTheme, contentWidth: number): string[] {\n  const lines = wordWrap(todo.content, contentWidth);\n  return lines.map((line, i) =>\n    i === 0\n      ? `${TODO_CHARS.unchecked} ${BOLD}${line}${RESET_BOLD}`\n      : `  ${BOLD}${line}${RESET_BOLD}`\n  );\n}\n\n/**\n * Render a completed todo: ☒ ~~content~~ (gray + strikethrough)\n */\nfunction renderCompletedTodo(todo: TodoItem, theme: RenderTheme, contentWidth: number): string[] {\n  const grayFg = fg(theme.muted);\n  const lines = wordWrap(todo.content, contentWidth);\n  return lines.map((line, i) =>\n    i === 0\n      ? `${grayFg}${TODO_CHARS.checked} ${STRIKETHROUGH}${line}${RESET_STRIKETHROUGH}${RESET}`\n      : `${grayFg}  ${STRIKETHROUGH}${line}${RESET_STRIKETHROUGH}${RESET}`\n  );\n}\n","/**\n * Markdown-to-ANSI parser for assistant text\n * Converts markdown syntax to ANSI escape sequences for terminal rendering\n */\n\nimport { BOLD, RESET_BOLD, ITALIC, RESET_ITALIC, UNDERLINE, RESET_UNDERLINE, visibleLength, colorize, style } from \"./ansi.js\";\nimport type { RenderConfig } from \"./messages.js\";\n\n/**\n * Render markdown text to ANSI-styled output\n * Handles inline formatting (bold, italic, code), tables, and word wrapping\n */\nexport function renderMarkdown(text: string, cfg: RenderConfig): string {\n  const { theme, width } = cfg;\n\n  // Split into lines to preserve explicit line breaks\n  const inputLines = text.split(\"\\n\");\n  const outputLines: string[] = [];\n\n  let i = 0;\n  while (i < inputLines.length) {\n    const line = inputLines[i];\n\n    // Check if this starts a code block (```)\n    if (line.trimStart().startsWith(\"```\")) {\n      const indent = line.match(/^(\\s*)/)?.[1] || \"\";\n      // Collect lines until closing ```\n      const codeLines: string[] = [];\n      i++; // Skip opening fence\n      while (i < inputLines.length && !inputLines[i].trimStart().startsWith(\"```\")) {\n        codeLines.push(inputLines[i]);\n        i++;\n      }\n      i++; // Skip closing fence (if found)\n      // Render code block with muted styling, no word wrap\n      const rendered = renderCodeBlock(codeLines, indent, cfg);\n      outputLines.push(...rendered);\n      continue;\n    }\n\n    // Check if this is a horizontal rule (---, ***, ___)\n    if (/^(\\s*)[-*_]{3,}\\s*$/.test(line)) {\n      // Render as a line of dashes using box drawing character\n      const rule = \"─\".repeat(Math.min(width, 40)); // Cap at 40 chars for visual balance\n      outputLines.push(colorize(rule, theme.muted));\n      i++;\n      continue;\n    }\n\n    // Check if this is a header (starts with #)\n    const headerMatch = line.match(/^(#{1,6})\\s+(.+)$/);\n    if (headerMatch) {\n      const content = headerMatch[2];\n      // Render header as bold\n      const formatted = parseInlineFormatting(content, cfg);\n      // Wrap with bold\n      outputLines.push(`${BOLD}${formatted}${RESET_BOLD}`);\n      i++;\n      continue;\n    }\n\n    // Check if this is an unordered list item (-, *, +)\n    const unorderedMatch = line.match(/^(\\s*)([-*+])\\s+(.+)$/);\n    if (unorderedMatch) {\n      const indent = unorderedMatch[1];\n      const content = unorderedMatch[3];\n      const formatted = parseInlineFormatting(content, cfg);\n      // Use bullet character\n      outputLines.push(`${indent}• ${formatted}`);\n      i++;\n      continue;\n    }\n\n    // Check if this is an ordered list item (1., 2., etc.)\n    const orderedMatch = line.match(/^(\\s*)(\\d+)\\.\\s+(.+)$/);\n    if (orderedMatch) {\n      const indent = orderedMatch[1];\n      const num = orderedMatch[2];\n      const content = orderedMatch[3];\n      const formatted = parseInlineFormatting(content, cfg);\n      outputLines.push(`${indent}${num}. ${formatted}`);\n      i++;\n      continue;\n    }\n\n    // Check if this starts a table (line contains | and looks like a table row)\n    if (isTableRow(line)) {\n      // Collect all consecutive table rows\n      const tableLines: string[] = [];\n      while (i < inputLines.length && isTableRow(inputLines[i])) {\n        tableLines.push(inputLines[i]);\n        i++;\n      }\n      // Render the table with alignment\n      const renderedTable = renderTable(tableLines, cfg);\n      outputLines.push(...renderedTable);\n    } else {\n      // Regular line - parse inline formatting and word wrap\n      const formatted = parseInlineFormatting(line, cfg);\n      const wrapped = wordWrapAnsi(formatted, width, cfg);\n      outputLines.push(...wrapped);\n      i++;\n    }\n  }\n\n  return outputLines.join(\"\\n\");\n}\n\n/**\n * Check if a line looks like a markdown table row\n */\nfunction isTableRow(line: string): boolean {\n  // Must have at least one | and not be just dashes/pipes (separator row counts too)\n  return line.includes(\"|\") && line.trim().length > 0;\n}\n\n/**\n * Render a markdown table with aligned columns\n */\nfunction renderTable(lines: string[], cfg: RenderConfig): string[] {\n  const { theme } = cfg;\n\n  // Parse all rows into cells\n  const rows: string[][] = [];\n  const separatorIndices: number[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    // Check if this is a separator row (|---|---|)\n    if (/^\\|?[\\s\\-:|]+\\|?$/.test(line)) {\n      separatorIndices.push(i);\n      rows.push([]); // Placeholder\n      continue;\n    }\n\n    // Parse cells: split by |, trim, filter empty edge cells\n    const cells = line\n      .split(\"|\")\n      .map((c) => c.trim())\n      .filter((c, idx, arr) => {\n        // Filter out empty first/last cells from leading/trailing |\n        if (idx === 0 && c === \"\") return false;\n        if (idx === arr.length - 1 && c === \"\") return false;\n        return true;\n      });\n    rows.push(cells);\n  }\n\n  // Apply inline formatting to cells and calculate visible widths\n  const formattedRows: string[][] = [];\n  const colWidths: number[] = [];\n\n  for (let i = 0; i < rows.length; i++) {\n    if (separatorIndices.includes(i)) {\n      formattedRows.push([]); // Placeholder for separator\n      continue;\n    }\n    const formattedCells = rows[i].map((cell) => parseInlineFormatting(cell, cfg));\n    formattedRows.push(formattedCells);\n\n    // Calculate widths based on visible length (strips ANSI codes)\n    for (let col = 0; col < formattedCells.length; col++) {\n      const cellWidth = visibleLength(formattedCells[col]);\n      if (colWidths[col] === undefined || cellWidth > colWidths[col]) {\n        colWidths[col] = cellWidth;\n      }\n    }\n  }\n\n  // Render each row with padding based on visible width\n  const output: string[] = [];\n  for (let i = 0; i < formattedRows.length; i++) {\n    if (separatorIndices.includes(i)) {\n      // Render separator row with same spacing as data rows\n      const sep = colWidths.map((w) => \"-\".repeat(w)).join(\" | \");\n      output.push(colorize(sep, theme.muted));\n    } else {\n      // Render data row with ANSI-aware padding\n      const row = formattedRows[i];\n      const paddedCells = row.map((cell, col) => {\n        const targetWidth = colWidths[col] || visibleLength(cell);\n        const currentWidth = visibleLength(cell);\n        const padding = Math.max(0, targetWidth - currentWidth);\n        return cell + \" \".repeat(padding);\n      });\n      const rowStr = paddedCells.join(\" | \");\n      output.push(rowStr);\n    }\n  }\n\n  return output;\n}\n\n/**\n * Render a code block with preserved formatting\n * No word wrap, muted styling to distinguish from regular text\n */\nfunction renderCodeBlock(lines: string[], indent: string, cfg: RenderConfig): string[] {\n  const { theme } = cfg;\n  // Render each line with dim styling, preserve exact content\n  return lines.map((line) => {\n    // Preserve original indentation, add block indent if any\n    const content = indent + line;\n    return style(content, { dim: true, fg: theme.muted });\n  });\n}\n\n/**\n * Parse inline markdown formatting and convert to ANSI\n * Processing order: code first (protected), then bold, then italic\n */\nfunction parseInlineFormatting(text: string, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  // Step 1: Protect and render inline code first\n  // Use placeholder to prevent code content from being parsed\n  const codePlaceholders: string[] = [];\n  let result = text.replace(/`([^`]+)`/g, (_, code) => {\n    const rendered = colorize(code, theme.agent); // Purple accent like Ink\n    const placeholder = `\\x00CODE${codePlaceholders.length}\\x00`;\n    codePlaceholders.push(rendered);\n    return placeholder;\n  });\n\n  // Step 2: Handle escaped characters\n  // Replace \\* and \\_ with placeholders (without the literal char to avoid matching)\n  result = result.replace(/\\\\\\*/g, \"\\x00ESCSTAR\\x00\");\n  result = result.replace(/\\\\_/g, \"\\x00ESCUNDER\\x00\");\n\n  // Step 3: Parse links [text](url) - render as \"text\" with underline\n  result = result.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, (_, text, url) => {\n    // Show text underlined, URL in muted color after\n    return `${UNDERLINE}${text}${RESET_UNDERLINE} (${colorize(url, theme.muted)})`;\n  });\n\n  // Step 4: Parse bold (**text** or __text__)\n  result = result.replace(/\\*\\*([^*]+)\\*\\*/g, (_, content) => {\n    return `${BOLD}${content}${RESET_BOLD}`;\n  });\n  result = result.replace(/__([^_]+)__/g, (_, content) => {\n    return `${BOLD}${content}${RESET_BOLD}`;\n  });\n\n  // Step 5: Parse italic (*text* or _text_)\n  // Must not match inside words for underscore\n  result = result.replace(/\\*([^*]+)\\*/g, (_, content) => {\n    return `${ITALIC}${content}${RESET_ITALIC}`;\n  });\n  result = result.replace(/(?<![a-zA-Z0-9])_([^_]+)_(?![a-zA-Z0-9])/g, (_, content) => {\n    return `${ITALIC}${content}${RESET_ITALIC}`;\n  });\n\n  // Step 6: Restore escaped characters\n  /* eslint-disable no-control-regex */\n  result = result.replace(/\\x00ESCSTAR\\x00/g, \"*\");\n  result = result.replace(/\\x00ESCUNDER\\x00/g, \"_\");\n  /* eslint-enable no-control-regex */\n\n  // Step 7: Restore code placeholders\n  for (let i = 0; i < codePlaceholders.length; i++) {\n    result = result.replace(`\\x00CODE${i}\\x00`, codePlaceholders[i]);\n  }\n\n  // Apply base text color\n  return colorize(result, theme.assistantText);\n}\n\n/**\n * Word wrap text containing ANSI escape sequences\n * Uses visibleLength() to calculate actual display width\n */\nfunction wordWrapAnsi(text: string, width: number, _cfg: RenderConfig): string[] {\n  if (width <= 0) return [text];\n\n  const words = text.split(/(\\s+)/);\n  const lines: string[] = [];\n  let currentLine = \"\";\n  let currentWidth = 0;\n\n  for (const word of words) {\n    const wordWidth = visibleLength(word);\n\n    if (currentWidth === 0) {\n      // Start of line\n      currentLine = word;\n      currentWidth = wordWidth;\n    } else if (currentWidth + wordWidth <= width) {\n      // Word fits on current line\n      currentLine += word;\n      currentWidth += wordWidth;\n    } else if (word.match(/^\\s+$/)) {\n      // Whitespace that would exceed width - skip it\n      continue;\n    } else {\n      // Word doesn't fit - start new line\n      if (currentLine.trim()) {\n        lines.push(currentLine);\n      }\n      currentLine = word.trimStart();\n      currentWidth = visibleLength(currentLine);\n    }\n  }\n\n  // Don't forget the last line\n  if (currentLine.trim()) {\n    lines.push(currentLine);\n  }\n\n  // Handle empty input\n  if (lines.length === 0) {\n    lines.push(\"\");\n  }\n\n  return lines;\n}\n","/**\n * Diff visualization for Edit tool results\n * Renders structured patches with line numbers, +/- indicators, and colored backgrounds\n * Supports character-level highlighting for modified lines\n */\n\nimport { colorize, style, indent, RESET, wordWrap } from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\n\n// Line number width (5) + space (1) + prefix \" + \" (3) = 9 chars before content\nconst LINE_PREFIX_WIDTH = 9;\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** A single hunk from a unified diff */\nexport interface PatchHunk {\n  oldStart: number;\n  oldLines: number;\n  newStart: number;\n  newLines: number;\n  lines: string[]; // Each line prefixed with ' ', '+', or '-'\n}\n\n/** Edit tool result with structured patch data */\nexport interface EditToolResult {\n  filePath: string;\n  oldString: string;\n  newString: string;\n  originalFile?: string;\n  structuredPatch?: PatchHunk[];\n  userModified?: boolean;\n  replaceAll?: boolean;\n  content?: string;\n}\n\n/** Configuration for diff rendering */\nexport interface DiffRenderConfig {\n  theme: RenderTheme;\n  indentSize: number;\n  width: number;\n}\n\n/** A segment of text with change flag for character-level diff */\ninterface DiffSegment {\n  text: string;\n  changed: boolean;\n}\n\n// =============================================================================\n// Main Renderer\n// =============================================================================\n\n/**\n * Check if a tool result is an Edit result with structured patch data\n */\nexport function isEditToolResult(result: unknown): result is EditToolResult {\n  if (typeof result !== \"object\" || result === null) return false;\n  const r = result as Record<string, unknown>;\n  return (\n    typeof r.filePath === \"string\" &&\n    Array.isArray(r.structuredPatch) &&\n    r.structuredPatch.length > 0\n  );\n}\n\n/**\n * Render an Edit tool result as a diff visualization\n */\nexport function renderEditDiff(result: EditToolResult, cfg: DiffRenderConfig): string {\n  const { theme, indentSize } = cfg;\n  const output: string[] = [];\n\n  // Calculate statistics\n  let additions = 0;\n  let removals = 0;\n  for (const hunk of result.structuredPatch ?? []) {\n    for (const line of hunk.lines) {\n      if (line[0] === \"+\") additions++;\n      if (line[0] === \"-\") removals++;\n    }\n  }\n\n  // Render header\n  const statsText = `${additions} addition${additions !== 1 ? \"s\" : \"\"} and ${removals} removal${removals !== 1 ? \"s\" : \"\"}`;\n  const header = colorize(`Updated ${result.filePath} with ${statsText}`, theme.muted);\n  output.push(indent(header, indentSize));\n\n  // Render each hunk\n  // Calculate available width for content: total width - indent - prefix\n  const contentWidth = cfg.width - indentSize - LINE_PREFIX_WIDTH;\n  for (const hunk of result.structuredPatch ?? []) {\n    const hunkLines = renderHunk(hunk, theme, contentWidth);\n    for (const line of hunkLines) {\n      output.push(indent(line, indentSize));\n    }\n  }\n\n  return output.join(\"\\n\");\n}\n\n// =============================================================================\n// Hunk Rendering\n// =============================================================================\n\n/**\n * Render a single diff hunk with line numbers and colored backgrounds.\n * Identifies paired -/+ lines for character-level diff highlighting.\n */\nfunction renderHunk(hunk: PatchHunk, theme: RenderTheme, contentWidth: number): string[] {\n  const output: string[] = [];\n  let oldLineNum = hunk.oldStart;\n  let newLineNum = hunk.newStart;\n  const lines = hunk.lines;\n\n  let i = 0;\n  while (i < lines.length) {\n    const line = lines[i];\n    const prefix = line[0];\n    const content = line.slice(1);\n\n    switch (prefix) {\n      case \" \":\n        // Context line - show line number, no background\n        output.push(...renderContextLine(newLineNum, content, theme, contentWidth));\n        oldLineNum++;\n        newLineNum++;\n        i++;\n        break;\n\n      case \"-\": {\n        // Check if this is a modification (- followed by +)\n        const nextLine = lines[i + 1];\n        if (nextLine && nextLine[0] === \"+\") {\n          // Paired modification - render with character-level diff\n          const oldContent = content;\n          const newContent = nextLine.slice(1);\n          const { oldSegments, newSegments } = diffWords(oldContent, newContent);\n\n          output.push(...renderRemovalLineWithHighlight(oldLineNum, oldSegments, theme, contentWidth));\n          output.push(...renderAdditionLineWithHighlight(newLineNum, newSegments, theme, contentWidth));\n\n          oldLineNum++;\n          newLineNum++;\n          i += 2; // Skip both lines\n        } else {\n          // Pure removal\n          output.push(...renderRemovalLine(oldLineNum, content, theme, contentWidth));\n          oldLineNum++;\n          i++;\n        }\n        break;\n      }\n\n      case \"+\":\n        // Pure addition (not paired with a removal)\n        output.push(...renderAdditionLine(newLineNum, content, theme, contentWidth));\n        newLineNum++;\n        i++;\n        break;\n\n      default:\n        // Unknown prefix, render as context\n        output.push(...renderContextLine(newLineNum, line, theme, contentWidth));\n        newLineNum++;\n        i++;\n    }\n  }\n\n  return output;\n}\n\n// =============================================================================\n// Word-based Diff Algorithm\n// =============================================================================\n\n/**\n * Compute word-based diff between two lines.\n * Returns segments marked as changed or unchanged for both lines.\n */\nfunction diffWords(\n  oldLine: string,\n  newLine: string\n): { oldSegments: DiffSegment[]; newSegments: DiffSegment[] } {\n  // Split on word boundaries while preserving whitespace\n  const oldTokens = tokenize(oldLine);\n  const newTokens = tokenize(newLine);\n\n  // Compute LCS (longest common subsequence) to identify unchanged tokens\n  const lcs = longestCommonSubsequence(oldTokens, newTokens);\n\n  // Build segments for old line\n  const oldSegments = buildSegments(oldTokens, lcs, \"old\");\n\n  // Build segments for new line\n  const newSegments = buildSegments(newTokens, lcs, \"new\");\n\n  return { oldSegments, newSegments };\n}\n\n/**\n * Tokenize a line into words and whitespace, preserving order.\n */\nfunction tokenize(line: string): string[] {\n  // Split on whitespace boundaries while keeping the whitespace\n  const tokens: string[] = [];\n  let current = \"\";\n  let inWhitespace: boolean | null = null;\n\n  for (const char of line) {\n    const isWs = /\\s/.test(char);\n    if (inWhitespace === null) {\n      // First character\n      current = char;\n      inWhitespace = isWs;\n    } else if (isWs === inWhitespace) {\n      // Same type as current token, append\n      current += char;\n    } else {\n      // Different type, push current and start new\n      tokens.push(current);\n      current = char;\n      inWhitespace = isWs;\n    }\n  }\n\n  if (current) {\n    tokens.push(current);\n  }\n\n  return tokens;\n}\n\n/**\n * Find the longest common subsequence of tokens.\n * Returns a Set of token indices that are part of the LCS.\n */\nfunction longestCommonSubsequence(\n  oldTokens: string[],\n  newTokens: string[]\n): Map<string, Set<number>> {\n  const m = oldTokens.length;\n  const n = newTokens.length;\n\n  // DP table\n  const dp: number[][] = Array(m + 1)\n    .fill(null)\n    .map(() => Array(n + 1).fill(0));\n\n  // Fill DP table\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (oldTokens[i - 1] === newTokens[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n\n  // Backtrack to find LCS indices\n  const oldLcsIndices = new Set<number>();\n  const newLcsIndices = new Set<number>();\n\n  let i = m;\n  let j = n;\n  while (i > 0 && j > 0) {\n    if (oldTokens[i - 1] === newTokens[j - 1]) {\n      oldLcsIndices.add(i - 1);\n      newLcsIndices.add(j - 1);\n      i--;\n      j--;\n    } else if (dp[i - 1][j] > dp[i][j - 1]) {\n      i--;\n    } else {\n      j--;\n    }\n  }\n\n  return new Map([\n    [\"old\", oldLcsIndices],\n    [\"new\", newLcsIndices],\n  ]);\n}\n\n/**\n * Build diff segments from tokens, marking which are changed.\n */\nfunction buildSegments(\n  tokens: string[],\n  lcs: Map<string, Set<number>>,\n  side: \"old\" | \"new\"\n): DiffSegment[] {\n  const lcsIndices = lcs.get(side) ?? new Set();\n  const segments: DiffSegment[] = [];\n\n  for (let i = 0; i < tokens.length; i++) {\n    const changed = !lcsIndices.has(i);\n    const text = tokens[i];\n\n    // Merge with previous segment if same change status\n    if (segments.length > 0 && segments[segments.length - 1].changed === changed) {\n      segments[segments.length - 1].text += text;\n    } else {\n      segments.push({ text, changed });\n    }\n  }\n\n  return segments;\n}\n\n// =============================================================================\n// Line Rendering\n// =============================================================================\n\n/**\n * Render a context line (unchanged), with wrapping support\n */\nfunction renderContextLine(lineNum: number, content: string, theme: RenderTheme, contentWidth: number): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Wrap content if needed\n  if (contentWidth > 0 && content.length > contentWidth) {\n    const wrapped = wordWrap(content, contentWidth);\n    return wrapped.map((line, idx) => {\n      if (idx === 0) {\n        return `${lineNumStr}      ${line}`;\n      }\n      return `${lineNumPadding}      ${line}`;\n    });\n  }\n\n  return [`${lineNumStr}      ${content}`];\n}\n\n/**\n * Render a removal line with red background (no character highlighting), with wrapping\n */\nfunction renderRemovalLine(lineNum: number, content: string, theme: RenderTheme, contentWidth: number): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Wrap content if needed\n  if (contentWidth > 0 && content.length > contentWidth) {\n    const wrapped = wordWrap(content, contentWidth);\n    return wrapped.map((line, idx) => {\n      const styledContent = style(` - ${line}`, {\n        fg: \"#ffffff\",\n        bg: theme.diffRemoveLineBg,\n      });\n      if (idx === 0) {\n        return `${lineNumStr} ${styledContent}`;\n      }\n      return `${lineNumPadding} ${styledContent}`;\n    });\n  }\n\n  const styledContent = style(` - ${content}`, {\n    fg: \"#ffffff\",\n    bg: theme.diffRemoveLineBg,\n  });\n  return [`${lineNumStr} ${styledContent}`];\n}\n\n/**\n * Render an addition line with green background (no character highlighting), with wrapping\n */\nfunction renderAdditionLine(lineNum: number, content: string, theme: RenderTheme, contentWidth: number): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Wrap content if needed\n  if (contentWidth > 0 && content.length > contentWidth) {\n    const wrapped = wordWrap(content, contentWidth);\n    return wrapped.map((line, idx) => {\n      const styledContent = style(` + ${line}`, {\n        fg: \"#ffffff\",\n        bg: theme.diffAddLineBg,\n      });\n      if (idx === 0) {\n        return `${lineNumStr} ${styledContent}`;\n      }\n      return `${lineNumPadding} ${styledContent}`;\n    });\n  }\n\n  const styledContent = style(` + ${content}`, {\n    fg: \"#ffffff\",\n    bg: theme.diffAddLineBg,\n  });\n  return [`${lineNumStr} ${styledContent}`];\n}\n\n/**\n * Render a removal line with character-level highlighting for changed segments, with wrapping\n */\nfunction renderRemovalLineWithHighlight(\n  lineNum: number,\n  segments: DiffSegment[],\n  theme: RenderTheme,\n  contentWidth: number\n): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Calculate total visible content length\n  const totalLength = segments.reduce((sum, seg) => sum + seg.text.length, 0);\n\n  // If no wrapping needed, render simply\n  if (contentWidth <= 0 || totalLength <= contentWidth) {\n    let content = \"\";\n    for (const seg of segments) {\n      if (seg.changed) {\n        content += style(seg.text, { fg: \"#ffffff\", bg: theme.diffRemoveCharBg });\n      } else {\n        content += style(seg.text, { fg: \"#ffffff\", bg: theme.diffRemoveLineBg });\n      }\n    }\n    const prefix = style(\" - \", { fg: \"#ffffff\", bg: theme.diffRemoveLineBg });\n    return [`${lineNumStr} ${prefix}${content}${RESET}`];\n  }\n\n  // Wrap segments across multiple lines\n  return wrapSegmentedLine(\n    lineNumStr,\n    lineNumPadding,\n    \" - \",\n    segments,\n    theme.diffRemoveLineBg,\n    theme.diffRemoveCharBg,\n    contentWidth\n  );\n}\n\n/**\n * Render an addition line with character-level highlighting for changed segments, with wrapping\n */\nfunction renderAdditionLineWithHighlight(\n  lineNum: number,\n  segments: DiffSegment[],\n  theme: RenderTheme,\n  contentWidth: number\n): string[] {\n  const lineNumStr = colorize(String(lineNum).padStart(5), theme.muted);\n  const lineNumPadding = \"     \"; // 5 spaces to replace line number on continuation\n\n  // Calculate total visible content length\n  const totalLength = segments.reduce((sum, seg) => sum + seg.text.length, 0);\n\n  // If no wrapping needed, render simply\n  if (contentWidth <= 0 || totalLength <= contentWidth) {\n    let content = \"\";\n    for (const seg of segments) {\n      if (seg.changed) {\n        content += style(seg.text, { fg: \"#ffffff\", bg: theme.diffAddCharBg });\n      } else {\n        content += style(seg.text, { fg: \"#ffffff\", bg: theme.diffAddLineBg });\n      }\n    }\n    const prefix = style(\" + \", { fg: \"#ffffff\", bg: theme.diffAddLineBg });\n    return [`${lineNumStr} ${prefix}${content}${RESET}`];\n  }\n\n  // Wrap segments across multiple lines\n  return wrapSegmentedLine(\n    lineNumStr,\n    lineNumPadding,\n    \" + \",\n    segments,\n    theme.diffAddLineBg,\n    theme.diffAddCharBg,\n    contentWidth\n  );\n}\n\n// =============================================================================\n// Wrapping Helper for Segmented Lines\n// =============================================================================\n\n/**\n * Wrap a line with character-level highlighting across multiple output lines.\n * Handles segments with different backgrounds and maintains styling across wraps.\n */\nfunction wrapSegmentedLine(\n  lineNumStr: string,\n  lineNumPadding: string,\n  prefixText: string,\n  segments: DiffSegment[],\n  lineBg: string,\n  charBg: string,\n  contentWidth: number\n): string[] {\n  const outputLines: string[] = [];\n  let currentLineContent = \"\";\n  let currentLineWidth = 0;\n  let isFirstLine = true;\n\n  // Process each segment\n  for (const seg of segments) {\n    const segBg = seg.changed ? charBg : lineBg;\n    let remaining = seg.text;\n\n    while (remaining.length > 0) {\n      const spaceLeft = contentWidth - currentLineWidth;\n\n      if (remaining.length <= spaceLeft) {\n        // Whole segment fits on current line\n        currentLineContent += style(remaining, { fg: \"#ffffff\", bg: segBg });\n        currentLineWidth += remaining.length;\n        remaining = \"\";\n      } else {\n        // Need to split segment\n        // Try to split at word boundary\n        let splitPoint = spaceLeft;\n        const lastSpace = remaining.lastIndexOf(\" \", spaceLeft);\n        if (lastSpace > 0) {\n          splitPoint = lastSpace + 1; // Include the space\n        }\n\n        // Safety: force progress if splitPoint is 0 (prevents infinite loop)\n        if (splitPoint <= 0) {\n          // Line is full with no room - emit it and continue\n          if (currentLineContent) {\n            const prefix = style(prefixText, { fg: \"#ffffff\", bg: lineBg });\n            if (isFirstLine) {\n              outputLines.push(`${lineNumStr} ${prefix}${currentLineContent}${RESET}`);\n              isFirstLine = false;\n            } else {\n              outputLines.push(`${lineNumPadding} ${prefix}${currentLineContent}${RESET}`);\n            }\n            currentLineContent = \"\";\n            currentLineWidth = 0;\n          }\n          // Force at least one character to prevent infinite loop\n          const chunk = remaining.slice(0, 1);\n          currentLineContent += style(chunk, { fg: \"#ffffff\", bg: segBg });\n          currentLineWidth += 1;\n          remaining = remaining.slice(1);\n          continue;\n        }\n\n        const chunk = remaining.slice(0, splitPoint);\n        currentLineContent += style(chunk, { fg: \"#ffffff\", bg: segBg });\n        remaining = remaining.slice(splitPoint);\n\n        // Emit current line\n        const prefix = style(prefixText, { fg: \"#ffffff\", bg: lineBg });\n        if (isFirstLine) {\n          outputLines.push(`${lineNumStr} ${prefix}${currentLineContent}${RESET}`);\n          isFirstLine = false;\n        } else {\n          outputLines.push(`${lineNumPadding} ${prefix}${currentLineContent}${RESET}`);\n        }\n\n        // Start new line\n        currentLineContent = \"\";\n        currentLineWidth = 0;\n      }\n    }\n  }\n\n  // Emit final line if there's content\n  if (currentLineContent || outputLines.length === 0) {\n    const prefix = style(prefixText, { fg: \"#ffffff\", bg: lineBg });\n    if (isFirstLine) {\n      outputLines.push(`${lineNumStr} ${prefix}${currentLineContent}${RESET}`);\n    } else {\n      outputLines.push(`${lineNumPadding} ${prefix}${currentLineContent}${RESET}`);\n    }\n  }\n\n  return outputLines;\n}\n","/**\n * Tool result extraction and rendering\n * Handles all Claude Code tool output formats (Read, Bash, Glob, TodoWrite, WebFetch, WebSearch, Task/Agent)\n */\n\nimport type { RenderConfig } from \"./messages.js\";\nimport { BOX, colorize, indent, wordWrap } from \"./ansi.js\";\nimport { isEditToolResult, renderEditDiff } from \"./diff.js\";\nimport { isTodoWriteToolResult } from \"./todos.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Tool result object - flexible to accommodate all tool formats */\nexport interface ToolResultContent {\n  content?: string | Array<{ type?: string; text?: string }>;\n  stdout?: string;\n  stderr?: string;\n  is_error?: boolean;\n  type?: string;\n  file?: { content?: string; filePath?: string };\n  filenames?: string[];\n  oldTodos?: unknown[];\n  newTodos?: unknown[];\n  // WebFetch result fields\n  result?: string;\n  url?: string;\n  // WebSearch result fields\n  query?: string;\n  results?: Array<{ title?: string; url?: string; snippet?: string } | string>;\n}\n\n// =============================================================================\n// Main Renderer\n// =============================================================================\n\n/**\n * Renders tool execution result with proper formatting.\n *\n * Supports multiple Claude Code tool result formats:\n * - Standard: `{ content: string }`\n * - Read tool: `{ type: \"text\", file: { content: string, filePath: string } }`\n * - Bash tool: `{ stdout: string, stderr: string }`\n * - Glob tool: `{ filenames: string[] }`\n * - TodoWrite: `{ oldTodos: [], newTodos: [] }`\n * - Empty results: `{}` (renders as bullet only)\n *\n * Priority: content > file.content > stdout/stderr > filenames > TodoWrite\n */\nexport function renderToolResult(\n  result: ToolResultContent,\n  cfg: RenderConfig\n): string {\n  const { theme, maxToolOutputLines } = cfg;\n\n  // Special handling for Edit tool results with diff visualization\n  if (isEditToolResult(result)) {\n    return renderEditDiff(result, {\n      theme,\n      indentSize: cfg.indentSize,\n      width: cfg.width,\n    });\n  }\n\n  // TodoWrite: suppress result rendering (todos shown with tool call)\n  if (isTodoWriteToolResult(result)) {\n    return \"\";\n  }\n\n  // Extract content from various formats\n  let contentText = \"\";\n  if (Array.isArray(result.content)) {\n    // Task/Agent/MCP result with content array: [{type: \"text\", text: \"...\"}, {type: \"image\", ...}]\n    const parts: string[] = [];\n    let hasImage = false;\n    for (const item of result.content) {\n      if (item && typeof item.text === \"string\") {\n        parts.push(item.text);\n      } else if (item && item.type === \"image\") {\n        hasImage = true;\n      }\n    }\n    if (hasImage) {\n      parts.push(\"[Screenshot captured]\");\n    }\n    contentText = parts.join(\"\\n\");\n  } else if (typeof result.content === \"string\") {\n    // Standard content field\n    contentText = result.content;\n  } else if (typeof result.result === \"string\") {\n    // WebFetch result with fetched content\n    contentText = result.result;\n  } else if (Array.isArray(result.results)) {\n    // WebSearch result with results array\n    const parts: string[] = [];\n    if (result.query) {\n      parts.push(`Query: ${result.query}`);\n    }\n    for (const item of result.results) {\n      if (typeof item === \"string\") {\n        parts.push(item);\n      } else if (item && typeof item.title === \"string\") {\n        // Format: title + url + snippet\n        parts.push(`• ${item.title}`);\n        if (item.url) parts.push(`  ${item.url}`);\n        if (item.snippet) parts.push(`  ${item.snippet}`);\n      }\n    }\n    contentText = parts.join(\"\\n\");\n  } else if (result.file && typeof result.file.content === \"string\") {\n    // Read tool result with nested file.content\n    contentText = result.file.content;\n  } else if (result.stdout || result.stderr) {\n    // Bash-style result with stdout/stderr\n    const parts: string[] = [];\n    if (typeof result.stdout === \"string\") parts.push(result.stdout);\n    if (typeof result.stderr === \"string\") parts.push(result.stderr);\n    contentText = parts.join(\"\\n\");\n  } else if (Array.isArray(result.filenames)) {\n    // Glob result with filenames array\n    if (result.filenames.length === 0) {\n      contentText = \"(no matches)\";\n    } else {\n      contentText = result.filenames.join(\"\\n\");\n    }\n  } else if (result.oldTodos || result.newTodos) {\n    // TodoWrite result - minimal display\n    const count = Array.isArray(result.newTodos) ? result.newTodos.length : 0;\n    contentText = `Updated ${count} todos`;\n  }\n\n  // Handle empty content - return early with muted connector + bullet\n  if (!contentText) {\n    const bullet = result.is_error ? BOX.crossMark : BOX.check;\n    const bulletColor = result.is_error ? theme.toolBulletError : theme.toolBulletSuccess;\n    return colorize(`  ${BOX.indent} `, theme.muted) + colorize(bullet, bulletColor);\n  }\n\n  // Alignment constants: \"  ⎿  \" prefix = 5 chars\n  const treePrefix = \"  \"; // Align under tool bullet\n  const contentIndent = 5; // \"  ⎿  \" = 5 chars to align continuation lines\n\n  // Wrap each line to terminal width (accounting for content indent)\n  const wrapWidth = cfg.width - contentIndent;\n  const rawLines = contentText.split(\"\\n\");\n  const lines: string[] = [];\n  for (const rawLine of rawLines) {\n    const wrapped = wordWrap(rawLine, wrapWidth);\n    lines.push(...wrapped);\n  }\n\n  const truncated = lines.length > maxToolOutputLines;\n  const displayLines = truncated ? lines.slice(0, maxToolOutputLines) : lines;\n\n  const bulletColor = result.is_error ? theme.toolBulletError : theme.toolBulletSuccess;\n  const bullet = result.is_error ? BOX.crossMark : BOX.check;\n  const treeConnector = \"\\u23BF\"; // ⎿\n\n  const output: string[] = [];\n\n  for (let i = 0; i < displayLines.length; i++) {\n    const line = displayLines[i] ?? \"\";\n    if (i === 0) {\n      // First line: indented tree connector with bullet color\n      output.push(treePrefix + colorize(treeConnector, theme.muted) + \"  \" + line);\n    } else {\n      // Continuation lines: aligned with first line content\n      output.push(indent(line, contentIndent));\n    }\n  }\n\n  if (truncated) {\n    output.push(\n      indent(\n        colorize(`… +${lines.length - maxToolOutputLines} lines (ctrl+o to expand)`, theme.muted),\n        contentIndent\n      )\n    );\n  }\n\n  if (output.length === 0) {\n    return treePrefix + colorize(bullet, bulletColor);\n  }\n\n  return output.join(\"\\n\");\n}\n","/**\n * Tool name and argument formatting utilities\n * Converts tool metadata into display-friendly strings for terminal rendering\n */\n\nimport type { ToolUseContent } from \"../types/messages.js\";\nimport { colorize, truncate } from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Result of parsing and formatting a tool name */\nexport interface FormattedToolName {\n  displayName: string;\n  isMcp: boolean;\n}\n\n// =============================================================================\n// Tool Name Formatting\n// =============================================================================\n\n/**\n * Parse MCP tool name into display format.\n * \"mcp__chrome-devtools__click\" -> { displayName: \"chrome-devtools - click\", isMcp: true }\n */\nexport function formatToolName(name: string): FormattedToolName {\n  if (name.startsWith(\"mcp__\")) {\n    const parts = name.slice(5).split(\"__\"); // Remove \"mcp__\" prefix, split on \"__\"\n    if (parts.length >= 2) {\n      const server = parts[0];\n      const tool = parts.slice(1).join(\"__\"); // Handle tools with __ in name\n      return { displayName: `${server} - ${tool}`, isMcp: true };\n    }\n  }\n  return { displayName: name, isMcp: false };\n}\n\n// =============================================================================\n// Tool Arguments Formatting\n// =============================================================================\n\n/**\n * Format tool arguments for display in tool call headers\n * Handles tool-specific argument extraction and truncation\n */\nexport function formatToolArgs(\n  tool: ToolUseContent,\n  theme: RenderTheme,\n  isMcp = false\n): string {\n  const input = tool.input;\n\n  // MCP tools: show first param as (key: \"value\")\n  if (isMcp && input && typeof input === \"object\") {\n    const keys = Object.keys(input);\n    if (keys.length > 0) {\n      const key = keys[0]!;\n      const value = input[key];\n      if (typeof value === \"string\") {\n        const truncated = truncate(value, 40);\n        return `(${key}: \"${colorize(truncated, theme.muted)}\")`;\n      }\n    }\n    return \"\";\n  }\n\n  // Format based on tool type\n  switch (tool.name) {\n    case \"Read\":\n    case \"Write\":\n    case \"Edit\":\n    case \"MultiEdit\":\n      if (typeof input[\"file_path\"] === \"string\") {\n        return `(${colorize(input[\"file_path\"], theme.filePath)})`;\n      }\n      break;\n\n    case \"Bash\":\n      if (typeof input[\"command\"] === \"string\") {\n        const cmd = truncate(input[\"command\"], 60);\n        return `(${colorize(cmd, theme.muted)})`;\n      }\n      break;\n\n    case \"Glob\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        return `(${colorize(input[\"pattern\"], theme.filePath)})`;\n      }\n      break;\n\n    case \"Grep\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        const pattern = truncate(input[\"pattern\"], 40);\n        return `(${colorize(pattern, theme.muted)})`;\n      }\n      break;\n\n    case \"Task\":\n      if (typeof input[\"description\"] === \"string\") {\n        const desc = truncate(input[\"description\"], 50);\n        return `(${colorize(desc, theme.agent)})`;\n      }\n      if (typeof input[\"prompt\"] === \"string\") {\n        const prompt = truncate(input[\"prompt\"], 50);\n        return `(${colorize(prompt, theme.agent)})`;\n      }\n      break;\n\n    case \"TodoWrite\":\n      return colorize(\" (updating todos)\", theme.muted);\n\n    case \"WebFetch\":\n    case \"WebSearch\":\n      if (typeof input[\"url\"] === \"string\") {\n        const url = truncate(input[\"url\"], 50);\n        return `(${colorize(url, theme.filePath)})`;\n      }\n      if (typeof input[\"query\"] === \"string\") {\n        const query = truncate(input[\"query\"], 50);\n        return `(${colorize(query, theme.muted)})`;\n      }\n      break;\n  }\n\n  // Fallback: show nothing or simple indicator\n  return \"\";\n}\n","/**\n * Slash command parsing and rendering for Claude Code CLI commands\n * Handles XML-formatted command tags in user messages\n */\n\nimport { BOX, colorize, style } from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Parsed slash command from XML tags */\nexport interface ParsedCommand {\n  /** Command name (e.g., \"/clear\", \"/status\") */\n  name: string;\n  /** Human-readable message (e.g., \"clear\", \"status\") */\n  message: string;\n  /** Command arguments (often empty) */\n  args: string;\n  /** Command stdout output (may be empty) */\n  stdout: string;\n}\n\n/** Parsed bash mode command from XML tags */\nexport interface ParsedBashCommand {\n  /** The bash command that was executed */\n  input: string;\n  /** Standard output (may be empty) */\n  stdout: string;\n  /** Standard error (may be empty) */\n  stderr: string;\n}\n\n// =============================================================================\n// Command Tag Parsing\n// =============================================================================\n\n/**\n * Parse command XML tags from user message content.\n * Returns parsed command if found, null otherwise.\n *\n * Expected format:\n * <command-name>/clear</command-name>\n * <command-message>clear</command-message>\n * <command-args></command-args>\n *\n * And optionally in a following message:\n * <local-command-stdout>output text</local-command-stdout>\n */\nexport function parseCommandTags(content: string): ParsedCommand | null {\n  // Check for command-name tag\n  const nameMatch = content.match(/<command-name>([^<]*)<\\/command-name>/);\n  if (!nameMatch) {\n    return null;\n  }\n\n  const name = nameMatch[1] || \"\";\n\n  // Extract other tags\n  const messageMatch = content.match(/<command-message>([^<]*)<\\/command-message>/);\n  const argsMatch = content.match(/<command-args>([^<]*)<\\/command-args>/);\n  const stdoutMatch = content.match(/<local-command-stdout>([^<]*)<\\/local-command-stdout>/);\n\n  return {\n    name,\n    message: messageMatch?.[1] || \"\",\n    args: argsMatch?.[1] || \"\",\n    stdout: stdoutMatch?.[1] || \"\",\n  };\n}\n\n/**\n * Parse local-command-stdout tag from content.\n * Used for standalone stdout messages that follow command messages.\n */\nexport function parseLocalCommandStdout(content: string): string | null {\n  const match = content.match(/<local-command-stdout>([^<]*)<\\/local-command-stdout>/);\n  return match ? (match[1] || \"\") : null;\n}\n\n/**\n * Check if content is a command message (starts with command tags, not just contains them)\n */\nexport function isCommandMessage(content: string): boolean {\n  const trimmed = content.trim();\n  return trimmed.startsWith(\"<command-name>\") || trimmed.startsWith(\"<local-command-stdout>\");\n}\n\n// =============================================================================\n// Bash Mode Tag Parsing\n// =============================================================================\n\n/**\n * Check if content is a bash mode message (starts with bash tags)\n */\nexport function isBashMessage(content: string): boolean {\n  // Use includes to detect bash tags anywhere in content (may have \"Caveat:\" prefix)\n  return (\n    content.includes(\"<bash-input>\") ||\n    content.includes(\"<bash-stdout>\") ||\n    content.includes(\"<bash-stderr>\")\n  );\n}\n\n/**\n * Check if content is specifically a bash input message (command, not output)\n */\nexport function isBashInputMessage(content: string): boolean {\n  return content.includes(\"<bash-input>\");\n}\n\n/**\n * Parse bash-input tag from content.\n * Returns the command string if found, null otherwise.\n */\nexport function parseBashInput(content: string): string | null {\n  const match = content.match(/<bash-input>([\\s\\S]*?)<\\/bash-input>/);\n  return match ? (match[1] ?? \"\").trim() : null;\n}\n\n/**\n * Parse bash-stdout and bash-stderr tags from content.\n * Returns parsed output if found, null otherwise.\n */\nexport function parseBashOutput(content: string): { stdout: string; stderr: string } | null {\n  const stdoutMatch = content.match(/<bash-stdout>([\\s\\S]*?)<\\/bash-stdout>/);\n  const stderrMatch = content.match(/<bash-stderr>([\\s\\S]*?)<\\/bash-stderr>/);\n\n  if (!stdoutMatch && !stderrMatch) {\n    return null;\n  }\n\n  return {\n    stdout: (stdoutMatch?.[1] || \"\").trim(),\n    stderr: (stderrMatch?.[1] || \"\").trim(),\n  };\n}\n\n// =============================================================================\n// Command Rendering\n// =============================================================================\n\n/** Configuration for command rendering */\nexport interface CommandRenderConfig {\n  theme: RenderTheme;\n  width: number;\n  maxOutputLines?: number; // Max lines before truncation (default: 5)\n}\n\n/**\n * Render a parsed slash command for terminal display.\n * Format: [/command] args (if any)\n *         stdout (if non-empty)\n */\nexport function renderSlashCommand(\n  command: ParsedCommand,\n  cfg: CommandRenderConfig\n): string {\n  const { theme } = cfg;\n\n  // Format: \"> /command \" with arrow prefix, trailing space, white text on dark gray\n  // Note: command.name already includes the slash (e.g., \"/status\")\n  let line = `${BOX.arrow} ${command.name}`;\n\n  if (command.args.trim()) {\n    line += ` (${command.args})`;\n  }\n\n  // Add trailing space (matches Claude Code UI)\n  line += \" \";\n\n  // White text on dark gray background (matching Claude Code UI)\n  // fg: #ffffff (255;255;255), bg: #373737 (55;55;55)\n  const result = style(line, { fg: \"#ffffff\", bg: \"#373737\" });\n\n  // Include stdout if present (indented on next line)\n  if (command.stdout.trim()) {\n    const stdoutLine = colorize(`  ${command.stdout}`, theme.muted);\n    return `${result}\\n${stdoutLine}`;\n  }\n\n  return result;\n}\n\n/**\n * Render standalone local-command-stdout for terminal display.\n * Used when stdout appears in a separate message from the command.\n */\nexport function renderLocalStdout(\n  stdout: string,\n  cfg: CommandRenderConfig\n): string {\n  const { theme } = cfg;\n\n  // Skip empty or placeholder output\n  if (!stdout.trim() || stdout === \"...\") {\n    return \"\";\n  }\n\n  return colorize(`  ${stdout}`, theme.muted);\n}\n\n// =============================================================================\n// Bash Mode Rendering\n// =============================================================================\n\n// Bash mode colors (from authentic Claude Code rendering)\nconst BASH_MODE_PINK = \"#fd5db1\"; // rgb(253,93,177) - for ! prefix\nconst BASH_COMMAND_BG = \"#413c41\"; // rgb(65,60,65) - command box background\nconst BASH_COMMAND_TEXT = \"#ffffff\"; // rgb(255,255,255) - command text\nconst BASH_STDERR_COLOR = \"#ff6b80\"; // rgb(255,107,128) - error text\n\n/**\n * Render a bash mode command input for terminal display.\n * Format: [pink !][white command] on dark background\n */\nexport function renderBashInput(\n  command: string,\n  cfg: CommandRenderConfig\n): string {\n  // Format: \"! command \" with pink !, white text, dark bg, trailing space\n  const prefix = style(\"!\", { fg: BASH_MODE_PINK, bg: BASH_COMMAND_BG });\n  const cmdText = style(` ${command} `, { fg: BASH_COMMAND_TEXT, bg: BASH_COMMAND_BG });\n\n  return prefix + cmdText;\n}\n\n/**\n * Render bash mode output (stdout/stderr) for terminal display.\n * Format:   ⎿  output text (with tree connector)\n * Stderr is rendered in red, stdout in default/muted color.\n */\nexport function renderBashOutput(\n  output: { stdout: string; stderr: string },\n  cfg: CommandRenderConfig\n): string {\n  const { theme, maxOutputLines = 5 } = cfg;\n  const lines: string[] = [];\n\n  // Helper to render output lines with truncation\n  const renderLines = (\n    rawLines: string[],\n    color: string | null,\n    useConnector: boolean\n  ): number => {\n    const truncated = rawLines.length > maxOutputLines;\n    const displayLines = truncated ? rawLines.slice(0, maxOutputLines) : rawLines;\n\n    for (let i = 0; i < displayLines.length; i++) {\n      const line = displayLines[i];\n      const prefix = i === 0 && useConnector ? `  ${BOX.indent}  ` : \"     \";\n      const formatted = `${prefix}${line}`;\n      lines.push(color ? colorize(formatted, color) : formatted);\n    }\n\n    if (truncated) {\n      const hiddenCount = rawLines.length - maxOutputLines;\n      lines.push(\n        colorize(`     … +${hiddenCount} lines (ctrl+o to expand)`, theme.muted)\n      );\n    }\n\n    return displayLines.length;\n  };\n\n  // Render stderr first (if present) - in red\n  if (output.stderr.trim()) {\n    const stderrLines = output.stderr.split(\"\\n\");\n    renderLines(stderrLines, BASH_STDERR_COLOR, true);\n  }\n\n  // Render stdout (if present) - in muted/default color\n  if (output.stdout.trim()) {\n    const stdoutLines = output.stdout.split(\"\\n\");\n    const startWithConnector = lines.length === 0; // Only use connector if no stderr\n    renderLines(stdoutLines, null, startWithConnector);\n  }\n\n  return lines.join(\"\\n\");\n}\n","/**\n * Message renderers - convert transcript entries to ANSI output\n */\n\nimport type {\n  TranscriptEntry,\n  UserMessage,\n  AssistantMessage,\n  SystemMessage,\n  ContentItem,\n  ToolUseContent,\n} from \"../types/messages.js\";\nimport { BOX, colorize, style, wordWrap } from \"./ansi.js\";\nimport { renderTodosFromInput } from \"./todos.js\";\nimport { renderMarkdown } from \"./markdown.js\";\nimport type { RenderTheme } from \"./theme.js\";\nimport { TOKYO_NIGHT } from \"./theme.js\";\nimport { renderToolResult } from \"./tool-results.js\";\nimport { formatToolName, formatToolArgs } from \"./tool-formatting.js\";\nimport {\n  isCommandMessage,\n  parseCommandTags,\n  parseLocalCommandStdout,\n  renderSlashCommand,\n  renderLocalStdout,\n  isBashMessage,\n  parseBashInput,\n  parseBashOutput,\n  renderBashInput,\n  renderBashOutput,\n} from \"./commands.js\";\n\n// =============================================================================\n// Render Configuration\n// =============================================================================\n\nexport interface RenderConfig {\n  /** Theme to use for colors */\n  theme: RenderTheme;\n  /** Terminal width for word wrapping */\n  width: number;\n  /** Maximum lines for tool output */\n  maxToolOutputLines: number;\n  /** Show thinking blocks */\n  showThinking: boolean;\n  /** Indent for nested content */\n  indentSize: number;\n}\n\nexport const DEFAULT_RENDER_CONFIG: RenderConfig = {\n  theme: TOKYO_NIGHT,\n  width: 100,\n  maxToolOutputLines: 5, // Matches Claude Code's compact display (wrapped lines counted)\n  showThinking: true,\n  indentSize: 2,\n};\n\n// =============================================================================\n// Main Renderer\n// =============================================================================\n\n/** Render a transcript entry to ANSI string */\nexport function renderMessage(\n  entry: TranscriptEntry,\n  config: Partial<RenderConfig> = {}\n): string {\n  const cfg = { ...DEFAULT_RENDER_CONFIG, ...config };\n\n  switch (entry.type) {\n    case \"user\":\n      // Skip meta messages (e.g., \"Caveat:\" system info)\n      if (entry.isMeta) {\n        return \"\";\n      }\n      return renderUserMessage(entry, cfg);\n    case \"assistant\":\n      return renderAssistantMessage(entry, cfg);\n    case \"system\":\n      return renderSystemMessage(entry, cfg);\n    case \"summary\":\n      return \"\"; // Skip rendering\n    case \"queue-operation\":\n      if (entry.operation === \"remove\") {\n        return renderQueueRemove(entry.content, cfg);\n      }\n      return \"\";\n    case \"file-history-snapshot\":\n      return \"\"; // Skip rendering\n    default:\n      return \"\";\n  }\n}\n\n// =============================================================================\n// User Message Renderer\n// =============================================================================\n\nfunction renderUserMessage(msg: UserMessage, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  // Tool result\n  if (msg.toolUseResult) {\n    // Handle string error results (e.g., hook errors)\n    if (typeof msg.toolUseResult === \"string\") {\n      return renderToolResult({ content: msg.toolUseResult, is_error: true }, cfg);\n    }\n    // Handle MCP array-format results: [{type:'text', text:'...'}, {type:'image', ...}]\n    if (Array.isArray(msg.toolUseResult)) {\n      return renderToolResult({ content: msg.toolUseResult }, cfg);\n    }\n    return renderToolResult(msg.toolUseResult, cfg);\n  }\n\n  // Regular user prompt\n  const content = extractTextContent(msg.message.content);\n  if (!content.trim()) return \"\";\n\n  // Check for interrupt message\n  if (content.includes(\"[Request interrupted by user]\")) {\n    return renderInterruptMessage(content, { theme, width: cfg.width });\n  }\n\n  // Check for slash command tags (e.g., <command-name>/clear</command-name>)\n  if (isCommandMessage(content)) {\n    // Full command with name, message, args\n    const command = parseCommandTags(content);\n    if (command) {\n      return renderSlashCommand(command, { theme, width: cfg.width });\n    }\n\n    // Standalone local-command-stdout\n    const stdout = parseLocalCommandStdout(content);\n    if (stdout !== null) {\n      return renderLocalStdout(stdout, { theme, width: cfg.width });\n    }\n  }\n\n  // Check for bash mode tags (e.g., <bash-input>pwd</bash-input>)\n  if (isBashMessage(content)) {\n    const bashInput = parseBashInput(content);\n    const bashOutput = parseBashOutput(content);\n    const cmdCfg = { theme, width: cfg.width };\n\n    // Render both input and output together when both present\n    if (bashInput !== null && bashOutput) {\n      return (\n        renderBashInput(bashInput, cmdCfg) +\n        \"\\n\" +\n        renderBashOutput(bashOutput, cmdCfg)\n      );\n    }\n\n    // Bash command input only\n    if (bashInput !== null) {\n      return renderBashInput(bashInput, cmdCfg);\n    }\n\n    // Bash output only (stdout/stderr)\n    if (bashOutput) {\n      return renderBashOutput(bashOutput, cmdCfg);\n    }\n  }\n\n  const lines = wordWrap(content, cfg.width - 4); // Account for \"> \" prefix\n\n  return lines\n    .map((line, i) => {\n      const text = i === 0 ? `${BOX.arrow} ${line}` : `  ${line}`;\n      return style(text, { fg: theme.userPrompt, bg: theme.userPromptBg });\n    })\n    .join(\"\\n\");\n}\n\n/**\n * Render interrupt message with semantic color styling\n * Format: ⎿ Interrupted · What should Claude do instead?\n * Colors: tree (text), \"Interrupted\" (error/red), separator and text (dim)\n */\nfunction renderInterruptMessage(\n  content: string,\n  cfg: { theme: RenderTheme; width: number }\n): string {\n  const { theme } = cfg;\n\n  // Tree connector character (same as todos)\n  const TREE_CONNECTOR = \"\\u23BF\"; // ⎿\n\n  // Build parts with semantic colors\n  const parts: string[] = [];\n\n  // Tree connector - text color\n  parts.push(colorize(TREE_CONNECTOR, theme.muted));\n\n  // \"Interrupted\" label - error/red color\n  parts.push(colorize(\"Interrupted\", theme.toolBulletError));\n\n  // Separator and follow-up text - dim color\n  parts.push(colorize(\"· What should Claude do instead?\", theme.muted));\n\n  return parts.join(\" \");\n}\n\n// =============================================================================\n// Assistant Message Renderer\n// =============================================================================\n\nfunction renderAssistantMessage(msg: AssistantMessage, cfg: RenderConfig): string {\n  const output: string[] = [];\n\n  for (const item of msg.message.content) {\n    const rendered = renderContentItem(item, cfg);\n    if (rendered) {\n      output.push(rendered);\n    }\n  }\n\n  return output.join(\"\\n\\n\");\n}\n\nfunction renderContentItem(item: ContentItem, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  switch (item.type) {\n    case \"text\":\n      return renderTextContent(item.text, cfg);\n\n    case \"thinking\":\n      if (!cfg.showThinking) return \"\";\n      return renderThinkingContent(item.thinking, cfg);\n\n    case \"tool_use\":\n      return renderToolUse(item, cfg);\n\n    case \"image\":\n      return colorize(\"[Image]\", theme.muted);\n\n    default:\n      return \"\";\n  }\n}\n\nfunction renderTextContent(text: string, cfg: RenderConfig): string {\n  // Parse markdown and render with ANSI styling\n  return renderMarkdown(text, cfg);\n}\n\nfunction renderThinkingContent(thinking: string, cfg: RenderConfig): string {\n  const { theme, width } = cfg;\n  const lines = wordWrap(thinking, width - 2);\n  const header = colorize(\"∴ Thinking…\", theme.thinking);\n\n  const content = lines\n    .map((line) => \"  \" + style(line, { fg: theme.thinking, italic: true }))\n    .join(\"\\n\");\n\n  return header + \"\\n\\n\" + content;\n}\n\nfunction renderToolUse(tool: ToolUseContent, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  const bullet = colorize(BOX.bullet, theme.toolBulletSuccess);\n  const { displayName, isMcp } = formatToolName(tool.name);\n  const name = style(displayName, { bold: true });\n  const mcpSuffix = isMcp ? colorize(\" (MCP)\", theme.muted) : \"\";\n  const args = formatToolArgs(tool, theme, isMcp);\n\n  const header = `${bullet} ${name}${mcpSuffix}${args}`;\n\n  // For TodoWrite, render todos inline with the tool call\n  if (tool.name === \"TodoWrite\") {\n    const todosOutput = renderTodosFromInput(tool.input, {\n      theme,\n      indentSize: cfg.indentSize,\n      width: cfg.width,\n    });\n    if (todosOutput) {\n      return header + \"\\n\" + todosOutput;\n    }\n  }\n\n  return header;\n}\n\n// =============================================================================\n// System Message Renderer\n// =============================================================================\n\nfunction renderSystemMessage(msg: SystemMessage, cfg: RenderConfig): string {\n  const { theme } = cfg;\n\n  if (!msg.content) return \"\";\n\n  const levelColors: Record<string, string> = {\n    info: theme.muted,\n    warning: theme.toolName,\n    error: theme.toolBulletError,\n  };\n\n  const color = levelColors[msg.level ?? \"info\"] ?? theme.muted;\n  return colorize(`[${msg.level ?? \"system\"}] ${msg.content}`, color);\n}\n\n// =============================================================================\n// Queue Operation Renderer\n// =============================================================================\n\nfunction renderQueueRemove(\n  content: string | ContentItem[] | undefined,\n  cfg: RenderConfig\n): string {\n  const { theme } = cfg;\n  const text = typeof content === \"string\" ? content : extractTextContent(content ?? []);\n\n  if (!text.trim()) return \"\";\n\n  return style(`${BOX.arrow} ${text}`, { fg: theme.userPrompt, bg: theme.userPromptBg });\n}\n\n// =============================================================================\n// Content Extraction\n// =============================================================================\n\n/** Extract plain text from content (string or ContentItem array) */\nexport function extractTextContent(content: string | ContentItem[]): string {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  const texts: string[] = [];\n  for (const item of content) {\n    if (item.type === \"text\") {\n      texts.push(item.text);\n    }\n  }\n\n  return texts.join(\"\\n\");\n}\n","/**\n * User input UI renderer - emulates Claude Code's command line interface\n * Renders a fixed-position input area at the bottom of the terminal\n * with burst typing animation and proper cursor positioning\n */\n\nimport {\n  BOX,\n  colorize,\n  horizontalRule,\n  wordWrap,\n  moveTo,\n  eraseLine,\n  setScrollRegion,\n} from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface InputUIConfig {\n  /** Theme for colors */\n  theme: RenderTheme;\n  /** Terminal width */\n  width: number;\n  /** Terminal height (rows) */\n  height: number;\n  /** Text always starts at this column (0-indexed) */\n  textColumn: number;\n}\n\n/** Row positions for fixed input area (1-indexed for ANSI) */\nexport interface InputAreaRows {\n  /** Last row of scrolling content area */\n  scrollEnd: number;\n  /** Fixed spinner row (outside scroll region) */\n  spinnerRow: number;\n  /** Top horizontal line */\n  topLine: number;\n  /** Input row with arrow prompt */\n  input: number;\n  /** Bottom horizontal line */\n  bottomLine: number;\n}\n\n/** Calculate input area row positions based on terminal height\n * Layout for height=40:\n *   rows 1-36: scroll region (content)\n *   row 37: spinner (fixed, outside scroll region)\n *   row 38: topLine (input frame border)\n *   row 39: input (prompt line)\n *   row 40: bottomLine (input frame border)\n */\nexport function getInputAreaRows(height: number): InputAreaRows {\n  return {\n    scrollEnd: height - 4,    // 36 for height=40\n    spinnerRow: height - 3,   // 37 for height=40\n    topLine: height - 2,      // 38 for height=40\n    input: height - 1,        // 39 for height=40\n    bottomLine: height,       // 40 for height=40\n  };\n}\n\nexport interface BurstTypingConfig {\n  /** Initial delay between words (ms) */\n  initialGapMs: number;\n  /** Minimum delay between words (ms) */\n  minGapMs: number;\n  /** Decay factor per word (multiplied each time) */\n  decayFactor: number;\n}\n\nexport interface InputTypedSegment {\n  /** Text to output */\n  text: string;\n  /** Time offset from start (seconds) */\n  time: number;\n}\n\n// =============================================================================\n// Default Configurations\n// =============================================================================\n\nexport const DEFAULT_INPUT_UI_CONFIG: Omit<InputUIConfig, \"theme\"> = {\n  width: 100,\n  height: 40,\n  textColumn: 2, // After \"→ \" (arrow + space)\n};\n\n/**\n * Get the 1-indexed cursor column for the input area.\n * ANSI cursor positioning is 1-indexed, so textColumn (0-indexed) + 1.\n */\nexport function getCursorColumn(config: InputUIConfig): number {\n  return config.textColumn + 1;\n}\n\nexport const DEFAULT_BURST_TYPING_CONFIG: BurstTypingConfig = {\n  initialGapMs: 200,\n  minGapMs: 30,\n  decayFactor: 0.75,\n};\n\n// =============================================================================\n// Input UI Rendering\n// =============================================================================\n\n/**\n * Render the input UI frame (horizontal lines + arrow prompt)\n * Returns: [topLine, promptLine, bottomLine]\n */\nexport function renderInputFrame(config: InputUIConfig): {\n  topLine: string;\n  promptPrefix: string;\n  bottomLine: string;\n} {\n  const { theme, width } = config;\n  const lineColor = theme.muted;\n\n  return {\n    topLine: horizontalRule(width, lineColor),\n    promptPrefix: colorize(`${BOX.arrow} `, theme.userPrompt),\n    bottomLine: horizontalRule(width, lineColor),\n  };\n}\n\n/**\n * Wrap user text for input area, maintaining column 3 alignment\n * Returns lines with proper indentation for continuation lines\n */\nexport function wrapInputText(\n  text: string,\n  config: InputUIConfig\n): string[] {\n  const { width, textColumn } = config;\n  // Available width for text: total width minus prompt indent minus right margin\n  // The -1 right margin prevents text from reaching terminal edge (avoids wrap issues)\n  const textWidth = width - textColumn - 1;\n\n  // Handle explicit line breaks\n  const paragraphs = text.split(\"\\n\");\n  const allLines: string[] = [];\n\n  for (const para of paragraphs) {\n    const wrapped = wordWrap(para, textWidth);\n    allLines.push(...(wrapped.length > 0 ? wrapped : [\"\"]));\n  }\n\n  return allLines;\n}\n\n// =============================================================================\n// Burst Typing Animation\n// =============================================================================\n\n/**\n * Split text into words for burst typing\n * Preserves spaces as separate tokens for accurate replay\n */\nexport function splitIntoWords(text: string): string[] {\n  const tokens: string[] = [];\n  let current = \"\";\n\n  for (const char of text) {\n    if (char === \" \" || char === \"\\n\") {\n      if (current) {\n        tokens.push(current);\n        current = \"\";\n      }\n      tokens.push(char);\n    } else {\n      current += char;\n    }\n  }\n\n  if (current) {\n    tokens.push(current);\n  }\n\n  return tokens;\n}\n\n/**\n * Generate burst typing segments for user input\n * Words appear as chunks, gaps between words shrink exponentially\n */\nexport function generateBurstTypingSegments(\n  text: string,\n  startTime: number,\n  config: BurstTypingConfig = DEFAULT_BURST_TYPING_CONFIG\n): InputTypedSegment[] {\n  const words = splitIntoWords(text);\n  if (words.length === 0) {\n    return [];\n  }\n\n  const segments: InputTypedSegment[] = [];\n  let currentTime = startTime;\n  let currentGap = config.initialGapMs / 1000; // Convert to seconds\n\n  for (const word of words) {\n    segments.push({ text: word, time: currentTime });\n\n    // Only add gap after non-whitespace words\n    if (word.trim()) {\n      currentTime += currentGap;\n      // Decay the gap, but don't go below minimum\n      currentGap = Math.max(\n        config.minGapMs / 1000,\n        currentGap * config.decayFactor\n      );\n    }\n  }\n\n  return segments;\n}\n\n// =============================================================================\n// Fixed-Position Input Area\n// =============================================================================\n\nexport interface InputAnimationResult {\n  /** Segments for typing animation */\n  segments: InputTypedSegment[];\n  /** User prompt text formatted for scrolling area (→ text with wrapping) */\n  scrollOutput: string;\n  /** Total duration of animation (seconds) */\n  duration: number;\n}\n\n/**\n * Generate the initial input area setup at the bottom of the terminal\n * This sets up the scroll region and renders the 3-line input frame\n *\n * Layout for height=40:\n *   rows 1-36: scroll region (content)\n *   row 37: spinner row (outside scroll region, fixed position)\n *   rows 38-40: input frame (topLine, input, bottomLine)\n */\nexport function generateInputAreaSetup(config: InputUIConfig): string {\n  const rows = getInputAreaRows(config.height);\n  const frame = renderInputFrame(config);\n\n  // Set scroll region to exclude spinner row and input area\n  return (\n    setScrollRegion(1, rows.scrollEnd) +\n    moveTo(rows.topLine) +\n    frame.topLine +\n    moveTo(rows.input) +\n    frame.promptPrefix +\n    moveTo(rows.bottomLine) +\n    frame.bottomLine +\n    moveTo(rows.input, config.textColumn + 1) // Position cursor after \"→ \"\n  );\n}\n\n/**\n * Redraw the input frame (use after content output to restore corrupted frame)\n * This clears and redraws all 3 lines of the input area\n */\nexport function redrawInputFrame(config: InputUIConfig): string {\n  const rows = getInputAreaRows(config.height);\n  const frame = renderInputFrame(config);\n\n  return (\n    // Clear and redraw top line\n    moveTo(rows.topLine) +\n    eraseLine() +\n    frame.topLine +\n    // Clear and redraw input line with prompt\n    moveTo(rows.input) +\n    eraseLine() +\n    frame.promptPrefix +\n    // Clear and redraw bottom line\n    moveTo(rows.bottomLine) +\n    eraseLine() +\n    frame.bottomLine +\n    // Position cursor after \"→ \"\n    moveTo(rows.input, config.textColumn + 1)\n  );\n}\n\n/**\n * Generate complete input animation with fixed-position typing\n *\n * The animation:\n * 1. Types text in the input row with burst animation\n * 2. On \"submit\": clears input row, outputs user text to scrolling area\n * 3. Input area remains with empty prompt ready for next input\n */\nexport function generateInputAnimation(\n  text: string,\n  startTime: number,\n  uiConfig: InputUIConfig,\n  typingConfig: BurstTypingConfig = DEFAULT_BURST_TYPING_CONFIG\n): InputAnimationResult {\n  const { theme, width, textColumn } = uiConfig;\n  const rows = getInputAreaRows(uiConfig.height);\n  const frame = renderInputFrame(uiConfig);\n\n  const segments: InputTypedSegment[] = [];\n  let currentTime = startTime;\n\n  // Position cursor at input row after arrow prompt\n  const cursorCol = textColumn + 1; // After \"→ \"\n  segments.push({\n    text: moveTo(rows.input, cursorCol),\n    time: currentTime,\n  });\n  currentTime += 0.05;\n\n  // Truncate display text if it exceeds available width on input row\n  // Available space: width - textColumn (for \"→ \") - 1 (for ellipsis if needed)\n  const maxDisplayLength = width - textColumn - 1;\n  let displayText = text.replace(/\\n/g, \" \"); // Flatten newlines for single-line display\n  let extraDelay = 0;\n\n  if (displayText.length > maxDisplayLength) {\n    displayText = displayText.slice(0, maxDisplayLength - 1) + \"…\";\n    extraDelay = 0.4; // Simulate user typing longer before submit\n  }\n\n  // Generate burst typing segments for the truncated display text\n  const typingSegments = generateBurstTypingSegments(displayText, currentTime, typingConfig);\n  segments.push(...typingSegments);\n\n  // Update time to after typing\n  if (typingSegments.length > 0) {\n    const lastSegment = typingSegments[typingSegments.length - 1]!;\n    currentTime = lastSegment.time + 0.2 + extraDelay; // Pause before \"submit\"\n  }\n\n  // \"Submit\" - clear input row and prepare for output\n  // 1. Clear the input row back to just the arrow prompt\n  segments.push({\n    text:\n      moveTo(rows.input) +\n      eraseLine() +\n      frame.promptPrefix +\n      moveTo(rows.input, cursorCol), // Cursor back to input position\n    time: currentTime,\n  });\n  currentTime += 0.1;\n\n  // 2. Move to scrolling area and output user prompt\n  // The scrollOutput will be appended separately by the converter\n  segments.push({\n    text: moveTo(rows.scrollEnd) + \"\\r\\n\", // Move to scroll area, newline to scroll\n    time: currentTime,\n  });\n\n  // Generate formatted user prompt for scrolling area (→ text with wrapping)\n  const wrappedLines = wrapInputText(text, uiConfig);\n  const indent = \" \".repeat(textColumn + 1);\n  const scrollLines = wrappedLines.map((line, i) => {\n    const styledLine = colorize(line, theme.userPrompt);\n    return i === 0 ? frame.promptPrefix + styledLine : indent + styledLine;\n  });\n  const scrollOutput = scrollLines.join(\"\\r\\n\") + \"\\r\\n\";\n\n  return {\n    segments,\n    scrollOutput,\n    duration: currentTime - startTime,\n  };\n}\n","/**\n * asciicast document builder\n * Creates asciicast v3 format documents from rendered messages\n */\n\nimport type {\n  AsciicastHeader,\n  AsciicastEvent,\n  AsciicastDocument,\n  AsciicastTheme,\n  OutputEvent,\n  MarkerEvent,\n} from \"../types/asciicast.js\";\nimport { THEMES } from \"../types/asciicast.js\";\n\n// =============================================================================\n// Builder Configuration\n// =============================================================================\n\nexport interface BuilderConfig {\n  /** Terminal width */\n  cols: number;\n  /** Terminal height */\n  rows: number;\n  /** Terminal type */\n  termType: string;\n  /** Theme to embed */\n  theme: AsciicastTheme;\n  /** Recording title */\n  title?: string;\n  /** Recording timestamp (Unix seconds) */\n  timestamp?: number;\n}\n\nexport const DEFAULT_BUILDER_CONFIG: BuilderConfig = {\n  cols: 100,\n  rows: 40,\n  termType: \"xterm-256color\",\n  theme: THEMES[\"tokyo-night\"]!,\n  title: \"Claude Code Session\",\n};\n\n// =============================================================================\n// Document Builder\n// =============================================================================\n\nexport class AsciicastBuilder {\n  private config: BuilderConfig;\n  private events: AsciicastEvent[] = [];\n  private currentTime = 0;\n  private lastEventTime = 0;\n\n  constructor(config: Partial<BuilderConfig> = {}) {\n    this.config = { ...DEFAULT_BUILDER_CONFIG, ...config };\n  }\n\n  /** Get the current timestamp */\n  get time(): number {\n    return this.currentTime;\n  }\n\n  /** Set the current timestamp */\n  set time(t: number) {\n    this.currentTime = t;\n  }\n\n  /** Add time to current timestamp */\n  addTime(seconds: number): this {\n    this.currentTime += seconds;\n    return this;\n  }\n\n  /** Add an output event (ANSI text) */\n  output(text: string): this {\n    if (text.length > 0) {\n      // asciicast v3 uses relative time (interval since previous event)\n      // Math.max(0, ...) prevents negative intervals if time goes backward\n      const interval = Math.max(0, this.currentTime - this.lastEventTime);\n      const event: OutputEvent = [interval, \"o\", text];\n      this.events.push(event);\n      this.lastEventTime = this.currentTime;\n    }\n    return this;\n  }\n\n  /** Add output with a newline */\n  outputLine(text: string): this {\n    return this.output(text + \"\\n\");\n  }\n\n  /** Add multiple lines of output */\n  outputLines(lines: string[]): this {\n    for (const line of lines) {\n      this.outputLine(line);\n    }\n    return this;\n  }\n\n  /** Add a marker event for navigation */\n  marker(label: string): this {\n    // asciicast v3 uses relative time (interval since previous event)\n    // Markers are instant navigation points - don't update lastEventTime\n    // so subsequent output at same currentTime gets the proper interval\n    // Math.max(0, ...) prevents negative intervals if time goes backward\n    const interval = Math.max(0, this.currentTime - this.lastEventTime);\n    const event: MarkerEvent = [interval, \"m\", label];\n    this.events.push(event);\n    return this;\n  }\n\n  /** Add output and marker at the same time */\n  outputWithMarker(text: string, markerLabel: string): this {\n    this.marker(markerLabel);\n    this.output(text);\n    return this;\n  }\n\n  /** Add a blank line */\n  blank(): this {\n    return this.output(\"\\n\");\n  }\n\n  /** Add multiple blank lines */\n  blanks(count: number): this {\n    for (let i = 0; i < count; i++) {\n      this.blank();\n    }\n    return this;\n  }\n\n  /** Clear the screen (ANSI escape sequence) */\n  clear(): this {\n    return this.output(\"\\x1b[2J\\x1b[H\");\n  }\n\n  /** Build the header */\n  buildHeader(): AsciicastHeader {\n    return {\n      version: 3,\n      term: {\n        cols: this.config.cols,\n        rows: this.config.rows,\n        type: this.config.termType,\n        theme: this.config.theme,\n      },\n      timestamp: this.config.timestamp ?? Math.floor(Date.now() / 1000),\n      title: this.config.title,\n    };\n  }\n\n  /** Build the complete document */\n  build(): AsciicastDocument {\n    return {\n      header: this.buildHeader(),\n      events: [...this.events],\n    };\n  }\n\n  /** Get current event count */\n  get eventCount(): number {\n    return this.events.length;\n  }\n\n  /** Reset builder state (keeps config) */\n  reset(): this {\n    this.events = [];\n    this.currentTime = 0;\n    this.lastEventTime = 0;\n    return this;\n  }\n}\n\n// =============================================================================\n// Serialization\n// =============================================================================\n\n/** Serialize asciicast document to .cast file format (NDJSON) */\nexport function serializeCast(doc: AsciicastDocument): string {\n  const lines: string[] = [];\n\n  // Header as first line\n  lines.push(JSON.stringify(doc.header));\n\n  // Events as subsequent lines\n  for (const event of doc.events) {\n    lines.push(JSON.stringify(event));\n  }\n\n  return lines.join(\"\\n\") + \"\\n\";\n}\n\n/** Parse .cast file content back to document */\nexport function parseCast(content: string): AsciicastDocument {\n  const lines = content.trim().split(\"\\n\");\n\n  if (lines.length === 0) {\n    throw new Error(\"Empty cast file\");\n  }\n\n  const header = JSON.parse(lines[0]!) as AsciicastHeader;\n  const events: AsciicastEvent[] = [];\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i]!.trim();\n    if (line) {\n      events.push(JSON.parse(line) as AsciicastEvent);\n    }\n  }\n\n  return { header, events };\n}\n","/**\n * Timing logic for asciicast generation\n * Handles timing presets and calculations\n */\n\nimport type { TranscriptEntry } from \"../types/messages.js\";\nimport type { TimingConfig } from \"../types/asciicast.js\";\nimport { TIMING_PRESETS } from \"../types/asciicast.js\";\nimport { getTimestamp } from \"../parser/loader.js\";\n\n// =============================================================================\n// Timing Configuration\n// =============================================================================\n\nexport interface TimingOptions extends TimingConfig {\n  /** Preset name (overrides individual settings) */\n  preset?: \"speedrun\" | \"default\" | \"realtime\";\n}\n\nexport function resolveTimingConfig(options: Partial<TimingOptions>): TimingConfig {\n  // If preset specified, use it as base\n  const presetName = options.preset;\n  if (presetName) {\n    const presetConfig = TIMING_PRESETS[presetName];\n    if (presetConfig) {\n      return {\n        ...presetConfig,\n        // Allow overrides\n        maxWait: options.maxWait ?? presetConfig.maxWait,\n        thinkingPause: options.thinkingPause ?? presetConfig.thinkingPause,\n        typingEffect: options.typingEffect ?? presetConfig.typingEffect,\n        typingSpeed: options.typingSpeed ?? presetConfig.typingSpeed,\n      };\n    }\n  }\n\n  // Use default preset as fallback\n  return {\n    ...TIMING_PRESETS[\"default\"]!,\n    ...options,\n  };\n}\n\n// =============================================================================\n// Timing Calculator\n// =============================================================================\n\nexport class TimingCalculator {\n  private config: TimingConfig;\n  private lastTimestamp: Date | null = null;\n  private currentTime = 0;\n\n  constructor(config: TimingConfig) {\n    this.config = config;\n  }\n\n  /** Get the current playback time */\n  get time(): number {\n    return this.currentTime;\n  }\n\n  /** Set the current playback time (for syncing with external animation) */\n  set time(value: number) {\n    this.currentTime = value;\n  }\n\n  /** Reset the calculator */\n  reset(): void {\n    this.lastTimestamp = null;\n    this.currentTime = 0;\n  }\n\n  /** Calculate time for next entry */\n  nextEntry(entry: TranscriptEntry): number {\n    const timestamp = getTimestamp(entry);\n\n    // Real timing mode - use actual timestamps\n    if (this.config.maxWait === Infinity && timestamp && this.lastTimestamp) {\n      const realDelta = (timestamp.getTime() - this.lastTimestamp.getTime()) / 1000;\n      this.lastTimestamp = timestamp;\n      this.currentTime += Math.max(0, realDelta);\n      return this.currentTime;\n    }\n\n    // Calculate normalized timing\n    let delta = 0;\n\n    if (timestamp && this.lastTimestamp) {\n      // Use real delta but cap it\n      const realDelta = (timestamp.getTime() - this.lastTimestamp.getTime()) / 1000;\n      delta = Math.min(realDelta, this.config.maxWait);\n    } else {\n      // Default pause between messages\n      delta = this.getDefaultPause(entry);\n    }\n\n    if (timestamp) {\n      this.lastTimestamp = timestamp;\n    }\n\n    this.currentTime += delta;\n    return this.currentTime;\n  }\n\n  /** Add pause for assistant response (thinking time) */\n  addThinkingPause(): void {\n    this.currentTime += this.config.thinkingPause;\n  }\n\n  /** Add a fixed pause */\n  addPause(seconds: number): void {\n    this.currentTime += Math.min(seconds, this.config.maxWait);\n  }\n\n  /** Calculate typing duration for text */\n  getTypingDuration(text: string): number {\n    if (!this.config.typingEffect || this.config.typingSpeed <= 0) {\n      return 0;\n    }\n    return text.length / this.config.typingSpeed;\n  }\n\n  /** Check if typing effect is enabled */\n  get hasTypingEffect(): boolean {\n    return this.config.typingEffect && this.config.typingSpeed > 0;\n  }\n\n  /** Get the timing config */\n  getConfig(): TimingConfig {\n    return { ...this.config };\n  }\n\n  // =============================================================================\n  // Private Helpers\n  // =============================================================================\n\n  private getDefaultPause(entry: TranscriptEntry): number {\n    switch (entry.type) {\n      case \"user\":\n        // Brief pause before user message\n        if (\"toolUseResult\" in entry && entry.toolUseResult) {\n          return 0.1; // Tool results appear quickly\n        }\n        return 0.3; // User typing\n\n      case \"assistant\":\n        // Thinking pause before assistant response\n        return this.config.thinkingPause;\n\n      case \"system\":\n        return 0.2;\n\n      default:\n        return 0.1;\n    }\n  }\n}\n\n// =============================================================================\n// Typing Effect Generator\n// =============================================================================\n\nexport interface TypedSegment {\n  text: string;\n  time: number;\n}\n\n/** Generate typing effect segments for text */\nexport function generateTypingSegments(\n  text: string,\n  startTime: number,\n  charsPerSecond: number,\n  chunkSize: number = 3\n): TypedSegment[] {\n  if (charsPerSecond <= 0) {\n    return [{ text, time: startTime }];\n  }\n\n  const segments: TypedSegment[] = [];\n  const timePerChar = 1 / charsPerSecond;\n  let currentTime = startTime;\n\n  // Split into chunks for more natural typing\n  for (let i = 0; i < text.length; i += chunkSize) {\n    const chunk = text.substring(i, Math.min(i + chunkSize, text.length));\n    segments.push({ text: chunk, time: currentTime });\n    currentTime += chunk.length * timePerChar;\n  }\n\n  return segments;\n}\n\n/** Generate line-by-line output with timing */\nexport function generateLineSegments(\n  text: string,\n  startTime: number,\n  lineDelay: number\n): TypedSegment[] {\n  const lines = text.split(\"\\n\");\n  const segments: TypedSegment[] = [];\n  let currentTime = startTime;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n    // Add newline for all but last line\n    const output = i < lines.length - 1 ? line + \"\\n\" : line;\n    segments.push({ text: output, time: currentTime });\n    currentTime += lineDelay;\n  }\n\n  return segments;\n}\n","/**\n * Marker generation for asciicast navigation\n */\n\nimport type { TranscriptEntry, UserMessage, AssistantMessage } from \"../types/messages.js\";\nimport type { MarkerMode } from \"../types/asciicast.js\";\nimport { extractText, extractToolUse } from \"../renderer/content.js\";\nimport { isCommandMessage, parseCommandTags, parseLocalCommandStdout } from \"../renderer/commands.js\";\n\n// =============================================================================\n// Marker Configuration\n// =============================================================================\n\nexport interface MarkerOptions {\n  /** Which messages to create markers for */\n  mode: MarkerMode;\n  /** Maximum length for marker labels */\n  labelLength: number;\n}\n\nexport const DEFAULT_MARKER_OPTIONS: MarkerOptions = {\n  mode: \"all\",\n  labelLength: 30,\n};\n\n// =============================================================================\n// Marker Generation\n// =============================================================================\n\n/** Check if a message should have a marker based on mode */\nexport function shouldHaveMarker(\n  entry: TranscriptEntry,\n  mode: MarkerMode\n): boolean {\n  if (mode === \"none\") return false;\n\n  switch (entry.type) {\n    case \"user\":\n      // User prompts (not tool results)\n      if (entry.toolUseResult) {\n        return mode === \"all\" || mode === \"tools\";\n      }\n      return mode === \"all\" || mode === \"user\";\n\n    case \"assistant\":\n      // Assistant messages with tool calls\n      if (hasToolCalls(entry)) {\n        return mode === \"all\" || mode === \"tools\";\n      }\n      // Regular assistant messages\n      return mode === \"all\";\n\n    default:\n      return false;\n  }\n}\n\n/** Generate marker label for an entry */\nexport function generateMarkerLabel(\n  entry: TranscriptEntry,\n  maxLength: number = 30\n): string | null {\n  switch (entry.type) {\n    case \"user\":\n      return generateUserMarkerLabel(entry, maxLength);\n\n    case \"assistant\":\n      return generateAssistantMarkerLabel(entry, maxLength);\n\n    default:\n      return null;\n  }\n}\n\n// =============================================================================\n// User Message Markers\n// =============================================================================\n\nfunction generateUserMarkerLabel(msg: UserMessage, maxLength: number): string {\n  // Tool result\n  if (msg.toolUseResult) {\n    // String results are errors, object results check is_error flag\n    const isError = typeof msg.toolUseResult === \"string\" || msg.toolUseResult.is_error;\n    if (isError) {\n      return \"✗ Tool error\";\n    }\n    return \"✓ Tool result\";\n  }\n\n  // Regular user prompt\n  const text = extractText(msg.message.content).trim();\n  if (!text) return \"> (empty prompt)\";\n\n  // Check for slash command tags (e.g., <command-name>/clear</command-name>)\n  if (isCommandMessage(text)) {\n    const command = parseCommandTags(text);\n    if (command) {\n      // Preserve original Claude Code aesthetic: \"> /command (args)\"\n      // Note: command.name already includes the slash (e.g., \"/status\")\n      let marker = `> ${command.name}`;\n      if (command.args.trim()) {\n        marker += ` (${command.args})`;\n      }\n      return marker;\n    }\n    // Standalone local-command-stdout (empty output)\n    const stdout = parseLocalCommandStdout(text);\n    if (stdout !== null) {\n      return stdout ? \"> (command output)\" : \"> (command)\";\n    }\n  }\n\n  const firstLine = text.split(\"\\n\")[0] ?? \"\";\n  const cleaned = firstLine.replace(/\\s+/g, \" \").trim();\n\n  if (cleaned.length <= maxLength - 2) {\n    return `> ${cleaned}`;\n  }\n\n  return `> ${cleaned.substring(0, maxLength - 3)}…`;\n}\n\n// =============================================================================\n// Assistant Message Markers\n// =============================================================================\n\nfunction generateAssistantMarkerLabel(\n  msg: AssistantMessage,\n  maxLength: number\n): string {\n  const tools = extractToolUse(msg.message.content);\n\n  // If has tool calls, show tool info\n  if (tools.length > 0) {\n    const firstTool = tools[0]!;\n    const toolInfo = formatToolForMarker(firstTool.name, firstTool.input);\n\n    if (tools.length === 1) {\n      return truncateMarker(`● ${toolInfo}`, maxLength);\n    }\n    return truncateMarker(`● ${toolInfo} (+${tools.length - 1})`, maxLength);\n  }\n\n  // Regular text response\n  const text = extractText(msg.message.content).trim();\n  if (!text) return \"Claude: (empty)\";\n\n  const firstLine = text.split(\"\\n\")[0] ?? \"\";\n  const cleaned = firstLine.replace(/\\s+/g, \" \").trim();\n\n  if (cleaned.length <= maxLength - 8) {\n    return `Claude: ${cleaned}`;\n  }\n\n  return `Claude: ${cleaned.substring(0, maxLength - 9)}…`;\n}\n\n// =============================================================================\n// Tool Formatting for Markers\n// =============================================================================\n\nfunction formatToolForMarker(\n  name: string,\n  input: Record<string, unknown>\n): string {\n  switch (name) {\n    case \"Read\":\n    case \"Write\":\n    case \"Edit\":\n    case \"MultiEdit\":\n      if (typeof input[\"file_path\"] === \"string\") {\n        const path = input[\"file_path\"];\n        const filename = path.split(\"/\").pop() ?? path;\n        return `${name}(${filename})`;\n      }\n      return name;\n\n    case \"Bash\":\n      if (typeof input[\"command\"] === \"string\") {\n        const cmd = input[\"command\"];\n        const short = cmd.length > 20 ? cmd.substring(0, 19) + \"…\" : cmd;\n        return `Bash(${short})`;\n      }\n      return \"Bash\";\n\n    case \"Glob\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        return `Glob(${input[\"pattern\"]})`;\n      }\n      return \"Glob\";\n\n    case \"Grep\":\n      if (typeof input[\"pattern\"] === \"string\") {\n        const pattern = input[\"pattern\"];\n        const short = pattern.length > 15 ? pattern.substring(0, 14) + \"…\" : pattern;\n        return `Grep(${short})`;\n      }\n      return \"Grep\";\n\n    case \"Task\":\n      if (typeof input[\"description\"] === \"string\") {\n        return `⤵ Task(${input[\"description\"]})`;\n      }\n      return \"⤵ Task\";\n\n    case \"TodoWrite\":\n      return \"TodoWrite\";\n\n    case \"WebFetch\":\n    case \"WebSearch\":\n      return name;\n\n    default:\n      return name;\n  }\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\nfunction hasToolCalls(msg: AssistantMessage): boolean {\n  return msg.message.content.some((item) => item.type === \"tool_use\");\n}\n\nfunction truncateMarker(label: string, maxLength: number): string {\n  if (label.length <= maxLength) return label;\n  return label.substring(0, maxLength - 1) + \"…\";\n}\n","{\n  \"verbs\": [\n    \"Accomplishing\",\n    \"Flambéing\",\n    \"Perusing\",\n    \"Wandering\",\n    \"Concocting\",\n    \"Julienning\",\n    \"Smooshing\",\n    \"Baking\",\n    \"Forging\",\n    \"Pontificating\",\n    \"Whisking\",\n    \"Crafting\",\n    \"Manifesting\",\n    \"Stewing\",\n    \"Bootstrapping\",\n    \"Galloping\",\n    \"Puttering\",\n    \"Zesting\",\n    \"Deciphering\",\n    \"Misting\",\n    \"Swooping\",\n    \"Caramelizing\",\n    \"Gusting\",\n    \"Reticulating\",\n    \"Doing\",\n    \"Mustering\",\n    \"Tomfoolering\",\n    \"Channelling\",\n    \"Herding\",\n    \"Schlepping\",\n    \"Elucidating\",\n    \"Nucleating\",\n    \"Unfurling\",\n    \"Coalescing\",\n    \"Imagining\",\n    \"Shimmying\",\n    \"Finagling\",\n    \"Percolating\",\n    \"Waiting\",\n    \"Computing\",\n    \"Ionizing\",\n    \"Slithering\",\n    \"Architecting\",\n    \"Flummoxing\",\n    \"Pondering\",\n    \"Whirring\",\n    \"Cooking\",\n    \"Lollygagging\",\n    \"Sprouting\",\n    \"Booping\",\n    \"Gallivanting\",\n    \"Proofing\",\n    \"Wrangling\",\n    \"Crystallizing\",\n    \"Metamorphosing\",\n    \"Swirling\",\n    \"Canoodling\",\n    \"Germinating\",\n    \"Razzmatazzing\",\n    \"Discombobulating\",\n    \"Musing\",\n    \"Tinkering\",\n    \"Channeling\",\n    \"Hatching\",\n    \"Scheming\",\n    \"Effecting\",\n    \"Noodling\",\n    \"Undulating\",\n    \"Clauding\",\n    \"Ideating\",\n    \"Shenaniganing\",\n    \"Fermenting\",\n    \"Perambulating\",\n    \"Waddling\",\n    \"Composing\",\n    \"Infusing\",\n    \"Sketching\",\n    \"Actualizing\",\n    \"Flowing\",\n    \"Photosynthesizing\",\n    \"Whatchamacalliting\",\n    \"Contemplating\",\n    \"Levitating\",\n    \"Spinning\",\n    \"Boogieing\",\n    \"Frolicking\",\n    \"Processing\",\n    \"Working\",\n    \"Crunching\",\n    \"Meandering\",\n    \"Sussing\",\n    \"Calculating\",\n    \"Generating\",\n    \"Quantumizing\",\n    \"Determining\",\n    \"Mulling\",\n    \"Synthesizing\",\n    \"Cerebrating\",\n    \"Hashing\",\n    \"Scampering\",\n    \"Drizzling\",\n    \"Nesting\",\n    \"Twisting\",\n    \"Churning\",\n    \"Honking\",\n    \"Seasoning\",\n    \"Envisioning\",\n    \"Osmosing\",\n    \"Vibing\",\n    \"Combobulating\",\n    \"Inferring\",\n    \"Skedaddling\",\n    \"Actioning\",\n    \"Flibbertigibbeting\",\n    \"Philosophising\",\n    \"Warping\",\n    \"Considering\",\n    \"Kneading\",\n    \"Spelunking\",\n    \"Beaming\",\n    \"Forming\",\n    \"Precipitating\",\n    \"Wibbling\",\n    \"Creating\",\n    \"Marinating\",\n    \"Sublimating\",\n    \"Brewing\",\n    \"Garnishing\",\n    \"Puzzling\",\n    \"Deliberating\",\n    \"Moseying\",\n    \"Symbioting\",\n    \"Catapulting\",\n    \"Harmonizing\",\n    \"Ruminating\",\n    \"Doodling\",\n    \"Nebulizing\",\n    \"Transmuting\",\n    \"Choreographing\",\n    \"Hibernating\",\n    \"Scurrying\",\n    \"Enchanting\",\n    \"Orbiting\",\n    \"Unravelling\",\n    \"Cogitating\",\n    \"Incubating\",\n    \"Simmering\"\n  ]\n}\n","/**\n * Status spinner with shimmering verb text\n * Emulates Claude CLI's animated status line during processing\n */\n\nimport { fg, RESET, moveTo, eraseLine } from \"./ansi.js\";\nimport type { RenderTheme } from \"./theme.js\";\nimport verbsData from \"./verbs.json\" with { type: \"json\" };\n\n// =============================================================================\n// Constants\n// =============================================================================\n\n/** Spinner rotation characters (ping-pong: expands then contracts) */\nexport const SPINNER_CHARS = [\"·\", \"✢\", \"✳\", \"✻\", \"✽\", \"✻\", \"✳\", \"✢\"] as const;\n\n/** Default shimmer colors */\nexport const SHIMMER_BASE_COLOR = \"#d77757\";\nexport const SHIMMER_HIGHLIGHT_COLOR = \"#eb9f7f\";\n\n/** Default frame interval in milliseconds */\nexport const DEFAULT_FRAME_INTERVAL_MS = 200;\n\n/** Default shimmer window size (characters) */\nexport const DEFAULT_SHIMMER_WINDOW_SIZE = 3;\n\n/** Pre-loaded verbs for status spinner */\nexport const VERBS: string[] = verbsData.verbs;\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface SpinnerConfig {\n  /** Theme for fallback colors */\n  theme: RenderTheme;\n  /** Frame interval in milliseconds */\n  frameIntervalMs: number;\n  /** Shimmer highlight window size in characters */\n  shimmerWindowSize: number;\n  /** Base color for verb text */\n  baseColor: string;\n  /** Highlight color for shimmer window */\n  highlightColor: string;\n}\n\nexport interface SpinnerSegment {\n  /** ANSI escape codes + spinner + verb */\n  text: string;\n  /** Absolute timestamp in seconds */\n  time: number;\n}\n\nexport const DEFAULT_SPINNER_CONFIG: Omit<SpinnerConfig, \"theme\"> = {\n  frameIntervalMs: DEFAULT_FRAME_INTERVAL_MS,\n  shimmerWindowSize: DEFAULT_SHIMMER_WINDOW_SIZE,\n  baseColor: SHIMMER_BASE_COLOR,\n  highlightColor: SHIMMER_HIGHLIGHT_COLOR,\n};\n\n/**\n * Spinner display mode\n * - OFF: No spinner displayed\n * - INLINE: Spinner renders in content flow, scrolls away naturally\n * - FIXED: Spinner at fixed row outside scroll region, stays visible until cleared\n */\nexport enum SpinnerMode {\n  OFF = \"off\",\n  INLINE = \"inline\",\n  FIXED = \"fixed\",\n}\n\n/**\n * Spinner state for clean lifecycle management\n * Replaces scattered boolean flags with explicit state machine\n */\nexport interface SpinnerState {\n  /** Current display mode */\n  mode: SpinnerMode;\n  /** Current verb being displayed (null when OFF) */\n  verb: string | null;\n  /** Fixed row position (only used in FIXED mode) */\n  row: number | null;\n}\n\n/** Create initial spinner state (off) */\nexport function createSpinnerState(): SpinnerState {\n  return {\n    mode: SpinnerMode.OFF,\n    verb: null,\n    row: null,\n  };\n}\n\n// =============================================================================\n// Verb Selection\n// =============================================================================\n\n/**\n * Select a pseudo-random verb from the list\n * Uses Knuth multiplicative hash for better distribution while staying deterministic\n */\nexport function selectVerb(verbs: string[], seed: number): string {\n  if (verbs.length === 0) {\n    return \"Processing\";\n  }\n  // Knuth multiplicative hash for pseudo-random distribution\n  // Add 1 to avoid seed=0 always giving index 0\n  const hash = Math.abs(((seed + 1) * 2654435761) | 0);\n  const index = hash % verbs.length;\n  return verbs[index];\n}\n\n// =============================================================================\n// Shimmer Effect\n// =============================================================================\n\n/**\n * Calculate shimmer window position for a given frame\n * Window slides from left to right across the text\n */\nexport function getShimmerWindow(\n  frameIndex: number,\n  textLength: number,\n  windowSize: number\n): [start: number, end: number] {\n  // The window position cycles through the text\n  // We extend past the text length so the window fully exits\n  const totalPositions = textLength + windowSize;\n  const position = frameIndex % totalPositions;\n\n  const start = Math.max(0, position - windowSize + 1);\n  const end = Math.min(textLength, position + 1);\n\n  return [start, end];\n}\n\n/**\n * Apply shimmer effect to text at a given frame\n * Returns text with character-level ANSI coloring\n */\nexport function applyShimmer(\n  text: string,\n  frameIndex: number,\n  config: Pick<SpinnerConfig, \"shimmerWindowSize\" | \"baseColor\" | \"highlightColor\">\n): string {\n  const [windowStart, windowEnd] = getShimmerWindow(\n    frameIndex,\n    text.length,\n    config.shimmerWindowSize\n  );\n\n  let result = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    const isHighlighted = i >= windowStart && i < windowEnd;\n    const color = isHighlighted ? config.highlightColor : config.baseColor;\n    result += fg(color) + char;\n  }\n\n  return result + RESET;\n}\n\n// =============================================================================\n// Spinner Animation Generation\n// =============================================================================\n\n/**\n * Generate a single spinner frame\n * Combines spinner character with shimmered verb text\n */\nexport function renderSpinnerFrame(\n  verb: string,\n  frameIndex: number,\n  config: SpinnerConfig\n): string {\n  const spinnerChar = SPINNER_CHARS[frameIndex % SPINNER_CHARS.length];\n  const shimmeredVerb = applyShimmer(verb + \"…\", frameIndex, config);\n\n  // Spinner char in base color, space, then shimmered verb\n  return fg(config.baseColor) + spinnerChar + RESET + \" \" + shimmeredVerb;\n}\n\n/**\n * Generate status spinner animation segments\n * Creates timed segments for the thinking pause period\n *\n * @param verb - The action verb to display (e.g., \"Clauding\", \"Pondering\")\n * @param startTime - Start time in seconds\n * @param duration - Total duration in seconds\n * @param config - Spinner configuration\n * @param row - Optional row for fixed positioning (1-indexed)\n * @returns Array of timed segments for the animation\n */\nexport function generateStatusSpinnerSegments(\n  verb: string,\n  startTime: number,\n  duration: number,\n  config: SpinnerConfig,\n  row?: number\n): SpinnerSegment[] {\n  const segments: SpinnerSegment[] = [];\n  const frameIntervalSec = config.frameIntervalMs / 1000;\n  const totalFrames = Math.max(1, Math.floor(duration / frameIntervalSec));\n\n  for (let i = 0; i < totalFrames; i++) {\n    const time = startTime + i * frameIntervalSec;\n    const frameContent = renderSpinnerFrame(verb, i, config);\n\n    // Build the frame output with optional positioning\n    let text = \"\";\n    if (row !== undefined) {\n      // Fixed position mode: move to row, erase line, render frame\n      text = moveTo(row, 1) + eraseLine() + frameContent;\n    } else {\n      // Inline mode: just erase current line and render\n      // Use carriage return to go to start of line\n      text = \"\\r\" + eraseLine() + frameContent;\n    }\n\n    segments.push({ text, time });\n  }\n\n  return segments;\n}\n\n/**\n * Generate the clear sequence to remove spinner before content\n */\nexport function generateSpinnerClear(row?: number): string {\n  if (row !== undefined) {\n    return moveTo(row, 1) + eraseLine();\n  }\n  return \"\\r\" + eraseLine();\n}\n\n","/**\n * Session to asciicast conversion\n * Main orchestration for generating .cast files from parsed sessions\n */\n\nimport type { TranscriptEntry } from \"../types/messages.js\";\nimport type { AsciicastDocument } from \"../types/asciicast.js\";\nimport { AsciicastBuilder, type BuilderConfig } from \"./builder.js\";\nimport {\n  TimingCalculator,\n  resolveTimingConfig,\n  type TimingOptions,\n} from \"./timing.js\";\nimport {\n  shouldHaveMarker,\n  generateMarkerLabel,\n  type MarkerOptions,\n  DEFAULT_MARKER_OPTIONS,\n} from \"./markers.js\";\nimport {\n  renderMessage,\n  extractTextContent,\n  type RenderConfig,\n  DEFAULT_RENDER_CONFIG,\n} from \"../renderer/messages.js\";\nimport { toAsciicastTheme, type RenderTheme } from \"../renderer/theme.js\";\nimport {\n  generateInputAnimation,\n  generateInputAreaSetup,\n  redrawInputFrame,\n  getInputAreaRows,\n  DEFAULT_BURST_TYPING_CONFIG,\n  type InputUIConfig,\n  type BurstTypingConfig,\n} from \"../renderer/input.js\";\nimport { moveTo } from \"../renderer/ansi.js\";\nimport { isRenderableMessage } from \"../types/messages.js\";\nimport { isTodoWriteToolResult } from \"../renderer/todos.js\";\nimport { isBashInputMessage, parseBashInput, renderBashInput } from \"../renderer/commands.js\";\nimport {\n  generateStatusSpinnerSegments,\n  generateSpinnerClear,\n  selectVerb,\n  VERBS,\n  DEFAULT_SPINNER_CONFIG,\n  SpinnerMode,\n  createSpinnerState,\n  type SpinnerConfig,\n  type SpinnerState,\n} from \"../renderer/spinner.js\";\n\n// =============================================================================\n// Conversion Configuration\n// =============================================================================\n\nexport interface ConvertOptions {\n  /** Builder configuration (terminal size, title, etc.) */\n  builder?: Partial<BuilderConfig>;\n  /** Timing configuration */\n  timing?: Partial<TimingOptions>;\n  /** Marker configuration */\n  markers?: Partial<MarkerOptions>;\n  /** Render configuration */\n  render?: Partial<RenderConfig>;\n  /** Enable input animation for user prompts (Claude Code style UI) */\n  inputAnimation?: boolean;\n  /** Input animation timing config */\n  inputAnimationConfig?: Partial<BurstTypingConfig>;\n  /** Enable status spinner animation during thinking pauses */\n  statusSpinner?: boolean;\n  /** Duration of status spinner animation in seconds (default: 3.0) */\n  spinnerDuration?: number;\n}\n\nexport interface ConvertResult {\n  /** The generated asciicast document */\n  document: AsciicastDocument;\n  /** Statistics about the conversion */\n  stats: ConvertStats;\n}\n\nexport interface ConvertStats {\n  /** Total entries processed */\n  entriesProcessed: number;\n  /** Entries that were rendered */\n  entriesRendered: number;\n  /** Total events generated */\n  eventsGenerated: number;\n  /** Markers generated */\n  markersGenerated: number;\n  /** Total playback duration (seconds) */\n  duration: number;\n}\n\n// =============================================================================\n// Main Conversion Function\n// =============================================================================\n\n/** Convert parsed session entries to asciicast document */\nexport function convertToAsciicast(\n  entries: TranscriptEntry[],\n  options: ConvertOptions = {}\n): ConvertResult {\n  const renderConfig = { ...DEFAULT_RENDER_CONFIG, ...options.render };\n  const markerOptions = { ...DEFAULT_MARKER_OPTIONS, ...options.markers };\n  const timingConfig = resolveTimingConfig(options.timing ?? {});\n  const inputAnimation = options.inputAnimation ?? false;\n  const burstConfig: BurstTypingConfig = {\n    ...DEFAULT_BURST_TYPING_CONFIG,\n    ...options.inputAnimationConfig,\n  };\n\n  // Build asciicast theme from render theme\n  const asciicastTheme = toAsciicastTheme(renderConfig.theme);\n\n  // Create builder with theme\n  const builder = new AsciicastBuilder({\n    ...options.builder,\n    theme: asciicastTheme,\n  });\n\n  // Get terminal dimensions for input animation\n  const termRows = options.builder?.rows ?? 40;\n  const termCols = options.builder?.cols ?? 100;\n\n  // Create timing calculator\n  const timing = new TimingCalculator(timingConfig);\n\n  // Stats tracking\n  let entriesRendered = 0;\n  let markersGenerated = 0;\n\n  // Input UI configuration (used for animation and cursor positioning)\n  const inputConfig: InputUIConfig = {\n    theme: renderConfig.theme,\n    width: termCols,\n    height: termRows,\n    textColumn: 2,\n  };\n  // Set up fixed input area at start (if input animation enabled)\n  if (inputAnimation) {\n    builder.output(generateInputAreaSetup(inputConfig));\n  }\n\n  // Status spinner configuration\n  const statusSpinner = options.statusSpinner ?? false;\n  let currentActiveForm: string | null = null;\n\n  // Seed messageIndex from first entry's timestamp for varied verb selection per session\n  // This ensures different sessions get different verb sequences while remaining deterministic\n  const firstTimestamp = entries[0] && \"timestamp\" in entries[0]\n    ? new Date(entries[0].timestamp as string).getTime()\n    : Date.now();\n  let messageIndex = Math.abs(firstTimestamp | 0) % 1000; // Start at varied offset (0-999)\n\n  // Verb rotation timing - prevents rapid switching during consecutive tool calls\n  // Note: Use 2.0s since default timing preset compresses gaps to max 3s\n  const MIN_VERB_INTERVAL = 2.0; // Minimum seconds between verb changes\n  let lastVerbChangeTime = 0;\n  let lastVerb: string | null = null; // Track last verb separately (spinner.verb gets cleared)\n\n  // Spinner state machine - replaces scattered boolean flags\n  const spinner: SpinnerState = createSpinnerState();\n\n  const spinnerConfig: SpinnerConfig = {\n    ...DEFAULT_SPINNER_CONFIG,\n    theme: renderConfig.theme,\n  };\n\n  // Spinner row: use spinnerRow from InputAreaRows (outside scroll region) when input animation enabled\n  // Layout for height=40: rows 1-36 (scroll), row 37 (spinner), rows 38-40 (input frame)\n  const rows = getInputAreaRows(termRows);\n  const spinnerRow = inputAnimation ? rows.spinnerRow : undefined;\n\n  // Helper to start spinner (shows initial frame, marks as active)\n  // Clears any existing spinner first, then starts a new one\n  const startSpinner = (verb: string) => {\n    // Clear existing spinner if active (handles user prompt transitions)\n    if (spinner.mode !== SpinnerMode.OFF) {\n      builder.output(generateSpinnerClear(spinner.row ?? undefined));\n    }\n    // Generate just the first frame to establish the spinner\n    const segments = generateStatusSpinnerSegments(\n      verb,\n      builder.time,\n      0.2, // Single frame\n      spinnerConfig,\n      spinnerRow\n    );\n    const firstSegment = segments[0];\n    if (firstSegment) {\n      builder.output(firstSegment.text);\n    }\n    // Update spinner state\n    spinner.verb = verb;\n    spinner.row = spinnerRow ?? null;\n    spinner.mode = spinnerRow !== undefined ? SpinnerMode.FIXED : SpinnerMode.INLINE;\n  };\n\n  // Helper to continue spinner animation for a duration (fills time gap with animation)\n  const continueSpinner = (duration: number) => {\n    if (spinner.mode === SpinnerMode.OFF || !spinner.verb) return;\n    if (duration <= 0) return;\n\n    const segments = generateStatusSpinnerSegments(\n      spinner.verb,\n      builder.time,\n      duration,\n      spinnerConfig,\n      spinner.row ?? undefined\n    );\n    for (const segment of segments) {\n      builder.time = segment.time;\n      builder.output(segment.text);\n    }\n  };\n\n  // Helper to clear spinner and mark inactive\n  // Note: redrawSpinner removed - in FIXED mode, spinner stays at fixed row (no redraw needed)\n  // In INLINE mode, spinner scrolls away naturally (no redraw possible)\n  const clearSpinner = () => {\n    if (spinner.mode === SpinnerMode.OFF) return;\n    builder.output(generateSpinnerClear(spinner.row ?? undefined));\n    if (spinner.row !== null && inputAnimation) {\n      // In fixed row mode, no need to redraw input frame - spinner row is separate\n    } else if (spinner.row === null) {\n      builder.output(\"\\r\\n\"); // Add newline in inline mode\n    }\n    spinner.mode = SpinnerMode.OFF;\n    spinner.verb = null;\n    spinner.row = null;\n  };\n\n  // Helper to get verb with throttling - prevents rapid switching\n  // Returns current verb if MIN_VERB_INTERVAL hasn't elapsed, otherwise selects new verb\n  const getThrottledVerb = (): string => {\n    const elapsed = builder.time - lastVerbChangeTime;\n\n    // Reuse last verb if interval hasn't elapsed and we have one\n    // Note: Use lastVerb instead of spinner.verb since clearSpinner() nulls spinner.verb\n    if (lastVerb !== null && elapsed < MIN_VERB_INTERVAL) {\n      messageIndex++; // Still increment for deterministic seeding\n      return lastVerb;\n    }\n\n    // Select new verb and update timing\n    const verb = currentActiveForm ?? selectVerb(VERBS, messageIndex);\n    messageIndex++;\n    lastVerbChangeTime = builder.time;\n    lastVerb = verb;\n    return verb;\n  };\n\n  // Note: We no longer start a spinner at the beginning of the recording.\n  // Spinners only appear AFTER user prompts are rendered, not before.\n  // This keeps the initial frame clean and matches expected UX flow.\n\n  // Process each entry\n  for (const entry of entries) {\n    // Skip non-renderable entries\n    if (!isRenderableMessage(entry)) {\n      continue;\n    }\n\n    // Track activeForm from TodoWrite tool results for spinner verb\n    if (statusSpinner && entry.type === \"user\" && \"toolUseResult\" in entry && entry.toolUseResult) {\n      if (isTodoWriteToolResult(entry.toolUseResult)) {\n        const inProgressTodo = entry.toolUseResult.newTodos.find(\n          (t) => t.status === \"in_progress\"\n        );\n        currentActiveForm = inProgressTodo?.activeForm ?? null;\n      }\n    }\n\n    // Check if this is a bash output message (stdout/stderr only - NOT bash-input)\n    // bash-input should go through normal input animation, bash-output should not\n    const isBashOutput = entry.type === \"user\" &&\n      typeof entry.message?.content === \"string\" &&\n      (entry.message.content.includes(\"<bash-stdout>\") ||\n       entry.message.content.includes(\"<bash-stderr>\"));\n\n    // Check if this is a \"[Request interrupted by user]\" message\n    // Must NOT be a tool result to distinguish from tool output containing this text\n    // Handle both string and array content formats\n    const isInterruptMessage = entry.type === \"user\" &&\n      !(\"toolUseResult\" in entry && entry.toolUseResult) &&\n      (\n        // String content\n        (typeof entry.message?.content === \"string\" &&\n          entry.message.content.includes(\"[Request interrupted by user]\")) ||\n        // Array content\n        (Array.isArray(entry.message?.content) &&\n          entry.message.content.some((item) =>\n            item.type === \"text\" && item.text?.includes(\"[Request interrupted by user]\")\n          ))\n      );\n\n    // Check if this is a system message with level \"info\" (like /status command output)\n    const isSystemInfoMessage = entry.type === \"system\" &&\n      \"level\" in entry && entry.level === \"info\";\n\n    // Check if this is a meta message (system info like /status command output)\n    const isMetaMessage = entry.type === \"user\" && \"isMeta\" in entry && entry.isMeta;\n\n    // Check if this is a user prompt (not tool result, not meta, not bash output, not interrupt)\n    const isUserPrompt =\n      entry.type === \"user\" &&\n      !(\"toolUseResult\" in entry && entry.toolUseResult) &&\n      !isMetaMessage &&\n      !isBashOutput &&\n      !isInterruptMessage;\n    const useInputAnimation = inputAnimation && isUserPrompt;\n\n    // Check if this is an assistant message with text content (final response, not just tool calls)\n    // We should clear the spinner when the assistant produces actual text output\n    const isAssistantWithText = entry.type === \"assistant\" &&\n      entry.message.content.some((item) => item.type === \"text\" && item.text.trim() !== \"\");\n\n    // Check if this is a tool call (assistant message with tool_use)\n    const isToolCall = entry.type === \"assistant\" &&\n      entry.message.content.some((item) => item.type === \"tool_use\");\n\n    // Check if this is a simple tool call (no inline content like TodoWrite)\n    // Simple tool calls get tight spacing with their results\n    const isSimpleToolCall = isToolCall && entry.type === \"assistant\" &&\n      !entry.message.content.some((item) =>\n        item.type === \"tool_use\" && item.name === \"TodoWrite\"\n      );\n\n    // Check if this is a tool result (user message with toolUseResult)\n    const isToolResult = entry.type === \"user\" && \"toolUseResult\" in entry && entry.toolUseResult;\n\n    // Check if this is agentic content (thinking, tool calls, tool results)\n    // Spinner should be active during agentic work\n    const isAgenticContent =\n      // Assistant with thinking or tool_use\n      (entry.type === \"assistant\" &&\n        entry.message.content.some((item) =>\n          item.type === \"thinking\" || item.type === \"tool_use\"\n        )) ||\n      // Tool result (user message with toolUseResult)\n      isToolResult;\n\n    // Determine if spinner should clear for this message type\n    // 1. Meta messages (isMeta user messages)\n    // 2. System info messages (level: \"info\")\n    // 3. Interrupt messages (\"[Request interrupted by user]\")\n    // Note: User prompts are NOT in this list - startSpinner() handles the transition\n    const shouldClearSpinner = isMetaMessage || isSystemInfoMessage || isInterruptMessage;\n\n    // Calculate timing for this entry\n    // Skip for input animation (handles its own timing)\n    if (!useInputAnimation) {\n      const previousTime = builder.time;\n      const entryTime = timing.nextEntry(entry);\n\n      // If spinner is active, fill the time gap with animation frames\n      if (statusSpinner && spinner.mode !== SpinnerMode.OFF) {\n        const timeDelta = entryTime - previousTime;\n        if (timeDelta > 0) {\n          continueSpinner(timeDelta);\n        }\n      }\n\n      builder.time = entryTime;\n    } else if (statusSpinner && spinner.mode !== SpinnerMode.OFF) {\n      // Input animation mode: calculate timing gap and fill with spinner animation\n      const previousTime = builder.time;\n      const entryTime = timing.nextEntry(entry);\n      const timeDelta = entryTime - previousTime;\n      if (timeDelta > 0) {\n        continueSpinner(timeDelta);\n      }\n      builder.time = entryTime;\n    }\n\n    // Clear spinner AFTER timing gap is filled (so animation plays first)\n    if (statusSpinner && spinner.mode !== SpinnerMode.OFF && shouldClearSpinner) {\n      clearSpinner();\n    }\n\n    // Handle spinner visibility for assistant text\n    // In FIXED mode: spinner persists (it's outside scroll region, content can't overwrite it)\n    // In INLINE mode: spinner already scrolled away, just mark OFF\n    if (statusSpinner && spinner.mode === SpinnerMode.INLINE && isAssistantWithText) {\n      // Inline mode: spinner already scrolled away, just mark state as OFF\n      spinner.mode = SpinnerMode.OFF;\n      spinner.verb = null;\n      spinner.row = null;\n    }\n\n    // Generate marker if applicable\n    if (shouldHaveMarker(entry, markerOptions.mode)) {\n      const label = generateMarkerLabel(entry, markerOptions.labelLength);\n      if (label) {\n        builder.marker(label);\n        markersGenerated++;\n      }\n    }\n\n    // Check if this is a command message (should use renderMessage, not input animation)\n    // Only user/assistant messages have .message property\n    const entryText = \"message\" in entry ? extractTextContent(entry.message.content) : \"\";\n    const isCommand = entryText.trim().startsWith(\"<command-name>\") ||\n                      entryText.trim().startsWith(\"<local-command-stdout>\");\n\n    if (useInputAnimation && !isCommand) {\n      // Use Claude Code style fixed-position input animation\n      // For bash-input, extract just the command for typing (not the XML tags)\n      const isBashInput = typeof entry.message?.content === \"string\" &&\n        isBashInputMessage(entry.message.content);\n      const text = isBashInput\n        ? `! ${parseBashInput(entry.message.content as string)!}`\n        : entryText;\n      if (!text.trim()) continue;\n\n      const inputConfig: InputUIConfig = {\n        theme: renderConfig.theme,\n        width: termCols,\n        height: termRows,\n        textColumn: 2,\n      };\n\n      const animation = generateInputAnimation(\n        text,\n        builder.time,\n        inputConfig,\n        burstConfig\n      );\n\n      // Output each segment with timing (typing animation in input area)\n      for (const segment of animation.segments) {\n        builder.time = segment.time;\n        builder.output(segment.text);\n      }\n\n      // Output the user prompt to scrolling area\n      // For bash-input messages, render with ! prefix styling instead of default prompt\n      if (isBashInput) {\n        const bashCmd = parseBashInput(entry.message.content as string)!;\n        const bashOutput = renderBashInput(bashCmd, { theme: renderConfig.theme, width: termCols });\n        builder.output(bashOutput.replace(/\\n/g, \"\\r\\n\") + \"\\r\\n\");\n      } else {\n        builder.output(animation.scrollOutput);\n      }\n\n      // Redraw input frame after scroll output (may have been corrupted)\n      builder.output(redrawInputFrame(inputConfig));\n\n      // Sync timing calculator with animation end time\n      timing.time = builder.time;\n\n      // Start spinner after user prompt (just first frame)\n      // Spinner will continue animating as subsequent entries add time gaps\n      if (statusSpinner) {\n        startSpinner(getThrottledVerb());\n      }\n    } else {\n      // Standard rendering\n      const rendered = renderMessage(entry, renderConfig);\n      if (!rendered) continue;\n\n      // Convert \\n to \\r\\n for proper terminal line endings\n      // Use single newline after simple tool calls and bash input so results attach directly\n      const isBashInput = entry.type === \"user\" &&\n        typeof entry.message?.content === \"string\" &&\n        entry.message.content.includes(\"<bash-input>\");\n      const trailing = (isSimpleToolCall || isBashInput || isBashOutput) ? \"\\r\\n\" : \"\\r\\n\\r\\n\";\n      const output = rendered.replace(/\\n/g, \"\\r\\n\") + trailing;\n\n      // When using input animation, position in scroll region first\n      // Use scrollEnd - 1 to avoid boundary issues where content overwrites instead of scrolling\n      if (inputAnimation) {\n        builder.output(moveTo(rows.scrollEnd - 1, 1) + \"\\r\\n\");\n      }\n\n      // Regular output (no typing effect when using input animation)\n      builder.output(output);\n\n      // Redraw input frame after output (may have been corrupted by scroll/wrap)\n      if (inputAnimation) {\n        builder.output(redrawInputFrame(inputConfig));\n      }\n\n      // Spinner handling for standard rendering path\n      if (statusSpinner) {\n        if (isUserPrompt) {\n          // Start spinner after user prompt (just first frame)\n          startSpinner(getThrottledVerb());\n        } else if (isAgenticContent && spinner.mode === SpinnerMode.OFF) {\n          // Start spinner after agentic content if not already active\n          // This handles clips that start mid-conversation with thinking/tool calls\n          startSpinner(getThrottledVerb());\n        }\n        // Note: No redrawSpinner() needed anymore\n        // In FIXED mode: spinner is outside scroll region, stays visible automatically\n        // In INLINE mode: spinner scrolls away naturally with content\n      }\n    }\n\n    entriesRendered++;\n  }\n\n  // Build final document\n  const document = builder.build();\n\n  return {\n    document,\n    stats: {\n      entriesProcessed: entries.length,\n      entriesRendered,\n      eventsGenerated: document.events.length,\n      markersGenerated,\n      duration: builder.time,\n    },\n  };\n}\n\n// =============================================================================\n// Convenience Functions\n// =============================================================================\n\n/** Convert session with common presets */\nexport function convertWithPreset(\n  entries: TranscriptEntry[],\n  preset: \"speedrun\" | \"default\" | \"realtime\",\n  theme?: RenderTheme\n): ConvertResult {\n  return convertToAsciicast(entries, {\n    timing: { preset },\n    render: theme ? { theme } : undefined,\n  });\n}\n\n/** Quick conversion with defaults (default preset, all markers) */\nexport function quickConvert(entries: TranscriptEntry[]): AsciicastDocument {\n  return convertToAsciicast(entries).document;\n}\n\n// =============================================================================\n// Session Info Extraction\n// =============================================================================\n\nexport interface SessionInfo {\n  /** First message timestamp */\n  startTime: Date | null;\n  /** Last message timestamp */\n  endTime: Date | null;\n  /** Number of user messages (excluding tool results) */\n  userMessages: number;\n  /** Number of assistant messages */\n  assistantMessages: number;\n  /** Number of tool calls */\n  toolCalls: number;\n  /** Whether session contains agent/sidechain messages */\n  hasAgents: boolean;\n}\n\n/** Extract session info for title/description generation */\nexport function getSessionInfo(entries: TranscriptEntry[]): SessionInfo {\n  let startTime: Date | null = null;\n  let endTime: Date | null = null;\n  let userMessages = 0;\n  let assistantMessages = 0;\n  let toolCalls = 0;\n  let hasAgents = false;\n\n  for (const entry of entries) {\n    // Track timestamps\n    if (\"timestamp\" in entry && typeof entry.timestamp === \"string\") {\n      const timestamp = new Date(entry.timestamp);\n      if (!startTime || timestamp < startTime) startTime = timestamp;\n      if (!endTime || timestamp > endTime) endTime = timestamp;\n    }\n\n    // Track sidechain\n    if (\"isSidechain\" in entry && entry.isSidechain) {\n      hasAgents = true;\n    }\n\n    // Count message types\n    if (entry.type === \"user\") {\n      if (!entry.toolUseResult) {\n        userMessages++;\n      }\n    } else if (entry.type === \"assistant\") {\n      assistantMessages++;\n      // Count tool calls\n      for (const item of entry.message.content) {\n        if (item.type === \"tool_use\") {\n          toolCalls++;\n        }\n      }\n    }\n  }\n\n  return {\n    startTime,\n    endTime,\n    userMessages,\n    assistantMessages,\n    toolCalls,\n    hasAgents,\n  };\n}\n\n/** Generate a title from session info */\nexport function generateTitle(info: SessionInfo): string {\n  const parts: string[] = [\"Claude Code Session\"];\n\n  if (info.toolCalls > 0) {\n    parts.push(`(${info.toolCalls} tool calls)`);\n  }\n\n  return parts.join(\" \");\n}\n"],"mappings":"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","names":["agentEntries","indent","text","i","j","styledContent","prefix","chunk","bullet","bulletColor","indent","inputConfig"]}